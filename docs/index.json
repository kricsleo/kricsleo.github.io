[{"uri":"/posts/airbnb-javascript-style-guide","tags":["codeStyle"],"content":"Airbnb JavaScript Style Guide  阅读 笔记 Airbnb 的 JavaScript 代码 风格 是 世界 上 最 流行 的 JavaScript 代码 风格 之一 ,  在 阅读 的 时候 结合 我 自己 的 使用 经验 记录 如下 重点 ,  日后 多次 阅读 应该 会 持续 更新 . 在线 阅读 地址 : https://github.com/airbnb/javascript( 中文翻译 版 : https://github.com/yuche/javascript) 对象 使用 字 面值 创建对象 // badconst item = new Object();// goodconst item = {}; 使用 对象 方法 的 简写 // badconst atom = {  value: 1,  addValue: function (value) {    return atom.value + value;  },};// goodconst atom = {  value: 1,  addValue(value) {    return atom.value + value;  },}; 数组 使用 字 面值 创建 数组 // badconst items = new Array();// goodconst items = []; 使用 扩展 运算符 ... 复制 数组 // badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i   为什么 ？ 增加 属性 或者 改变 排序 不会 改变 调用 时 的 位置 。// badfunction processInput(input) {  // then a miracle occurs  return [left, right, top, bottom];}//  调用 时 需要 考虑 回调 数据 的 顺序 。const [left, __, top] = processInput(input);// goodfunction processInput(input) {  // then a miracle occurs  return { left, right, top, bottom };}//  调用 时 只 选择 需要 的 数据 const { left, right } = processInput(input); 字符串 程序化 生成 字符串 时 使用 模板 字符串 代替 字符串 连接 >  模板 字符串 更 简洁 ,  根据 可读性 // badfunction sayHi(name) {  return 'How are you, ' + name + '?';}// badfunction sayHi(name) {  return ['How are you, ', name, '?'].join();}// goodfunction sayHi(name) {  return How are you, ${name}?; 函数 使用 函数 声明 代替 函数 表达式 >  因为 函数 声明 是 可 命名 的 ,  所以 他们 在 调用 栈 中 更 容易 \b 被 识别 .>  此外 函数 声明 会 把 整个 函数 提升 (hoisted),  而 函数 表达式 只 会 把 函数 的 引用 变量名 提升 .  这 条 规则 是 的 箭头 函数 可以 取代 函数 表达式 .// badconst foo = function () {};// goodfunction foo() {} 函数 表达式 //  立即 调用 的 函数 表达式 (IIFE)(() => {    console.log('welcome!')})() 不要 使用 arguments。 可以 选择 rest 语法 ... 替代 // badfunction concatenateAll() {  const args = Array.prototype.slice.call(arguments);  return args.join('');}// goodfunction concatenateAll(...args) {  return args.join('');} 直接 给 函数 的 参数 指定 默认值 ， 不要 使用 一个 变化 的 函数参数 。// really badfunction handleThings(opts) {  //  不 ！ 我们 不 应该 改变 函数参数 。  //  更加 糟糕 :  如果 参数  opts  是  false  的话 ， 它 就 会 被 设定 为 一个 对象 。  //  但 这样 的 写法 会 造成 一些  Bugs。  //（ 译注 ： 例如 当  opts  被 赋值 为 空 字符串 ，opts  仍然 会 被 下 一行 代码 设定 为 一个 空 对象 。）  opts = opts || {};  // ...}// still badfunction handleThings(opts) {  if (opts === void 0) {    opts = {};  }  // ...}// goodfunction handleThings(opts = {}) {  // ...} 构造 器 总是 使用 class,  避免 使用 prototype>  因为 class 语法 更 易读 // badfunction Queen(contents = []) {    this._quene = [...contents];}Quene.prototype.pop = function() {    const value = this._quene[0];    this._quene.splice(0, 1);    return value;}// goodclass Queen {    constructor(contents = []) {        this._quene = [...contents];    }    pop() {        const value = this._quene[0];        this._quene.splice(0, 1);        return value;    }}Iterators and Generators 不要 使用 iterators,  使用 高阶 函数 如 map 或者 reduce 来 代替 for-ofconst numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) {  sum += num;}sum === 15;// goodlet sum = 0;numbers.forEach((num) => sum += num);sum === 15// best (use the functional force)const sum = numbers.reduce((total, num) => total += num, 0)sum === 15 比较 运算符 和 等 号 条件 表达式 例如  if  语句 通过 抽象 方法 ToBoolean 强制 计算 它们 的 表达式 并且 总是 遵守 下面 的 规则 ： 对象   被 计算 为  trueUndefined  被 计算 为  falseNull  被 计算 为  false 布尔值   被 计算 为   布尔 的 值 数字   如果 是  +0、-0、 或  NaN  被 计算 为  false,  否则 为  true 字符串   如果 是 空 字符串  ''  被 计算 为  false， 否则 为  true 注释 给 注释 增加  FIXME  或  TODO  的 前缀 可以 帮助 其他 开发者 快速 了解 这 是 一个 需要 复查 的 问题 ， 或是 给 需要 实现 的 功能 提供 一个 解决 方式 。 这 将 有别于 常见 的 注释 ， 因为 它们 是 可 操作 的 。 使用  FIXME -- need to figure this out  或者  TODO -- need to implement。class Calculator {  constructor() {    // FIXME: shouldn't use a global here    total = 0;  }}class Calculator {  constructor() {    // TODO: total should be configurable by an options param    this.total = 0;  }} 空白 使用 2 个 空格 作为 缩进 。 在 文件 末尾 插入 一个 空行 。 逗号 增加 结尾 的 逗号 :  需要 。> JavaScript 支持 这种 做法 , 并且 会 自动 处理 结尾 多余 的 逗号 ,  好处 是 会 让 git diff 更 干净 ,  新增 字 段 更 方便 .>  另外 ， 像  babel  这样 的 转译 器 会 移除 结尾 多余 的 逗号 ， 也就是说 你 不必 担心 老 旧 浏览器 的 尾 逗号 问题 。// bad - git diff without trailing commaconst hero = {     firstName: 'Florence',lastName: 'Nightingale'lastName: 'Nightingale',inventorOf: ['coxcomb graph', 'modern nursing']}// good - git diff with trailing commaconst hero = {     firstName: 'Florence',     lastName: 'Nightingale',inventorOf: ['coxcomb chart', 'modern nursing'],}// badconst hero = {  firstName: 'Dana',  lastName: 'Scully'};const heroes = [  'Batman',  'Superman'];// goodconst hero = {  firstName: 'Dana',  lastName: 'Scully',};const heroes = [  'Batman',  'Superman',]; 类型转换 字符串 //  => this.reviewScore = 9;// badconst totalScore = this.reviewScore + '';// goodconst totalScore = String(this.reviewScore); 如果 因为 某些 原因  parseInt  成为 你 所 做 的 事 的 瓶颈 而 需要 使用 位操作 解决 性能 问题 时 ， 留 个 注释 说 清楚 原因 和 你 的 目的 。// good/**  使用  parseInt  导致 我 的 程序 变慢 ，  改成 使用 位操作 转换 数字 快 多 了 。 */const val = inputValue >> 0; 命名 规则 别 保存 this 的 引用 。 使用 箭头 函数 或 Function#bind。// badfunction foo() {  const self = this;  return function() {    console.log(self);  };}// badfunction foo() {  const that = this;  return function() {    console.log(that);  };}// goodfunction foo() {  return () => {    console.log(this);  };} 如果 你 的 文件 只 输出 一个 类 ， 那 你 的 文件名 必须 和 类 名 完全 保持一致 。// file contentsclass CheckBox {  // ...}export default CheckBox;// in some other file// badimport CheckBox from './checkBox';// badimport CheckBox from './check_box';// goodimport CheckBox from './CheckBox'; 当 你 导出 默认 的 函数 时 使用 驼峰 式 命名 。 你 的 文件名 必须 和 函数 名 完全 保持一致 。function makeStyleGuide() {}export default makeStyleGuide; 当 你 导出 单 例 、 函数库 、 空 对象 时 使用 帕斯卡 式 命名 。const AirbnbStyleGuide = {  es6: {  }};export default AirbnbStyleGuide; 事件 当 给 事件 附加 数据 时 （ 无论是  DOM  事件 还是 私有 事件 ）， 传入 一个 哈希 而 不是 原始 值 。 这样 可以 让 后面 的 贡献者 增加 更 多 数据 到 事件 数据 而 无需 找出 并 更新 事件 的 每 一个 处理器 。// bad$(this).trigger('listingUpdated', listing.id);...$(this).on('listingUpdated', function(e, listingId) {  // do something with listingId});// good$(this).trigger('listingUpdated', { listingId : listing.id });...$(this).on('listingUpdated', function(e, data) {  // do something with data.listingId});`","title":"Airbnb-JavaScript-Style-Guide","oriTitle":"Airbnb-JavaScript-Style-Guide"},{"uri":"/posts/iife","tags":["javascript"],"content":" 增 [ 译 ]JavaScript： 立即 执行 函数 表达式 （IIFE）>  原文 : http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife>  译文 : https://segmentfault.com/a/1190000003985390 by Murphywuwu 可能 你 并 没有 注意 到 ， 我 是 一个 对于 专业术语 有 一点 坚持 细节 人 。 所有 ， 当 我 听到 流行 的 但是 还 存在 误解 的 术语 “ 自 执行 匿名 函数 ” 多次 时 ， 我 最终 决定 将 我 的 想法 写 进 这 篇文章 里 。 除了 提供 关于 这种 模式 事实上 是 如何 工作 的 一些 全面 的 信息 ， 更进一步 的 ， 实际上 我 建议 我们 应该 知道 我们 应该 叫 它 什么 。 而且 ， 如果 你 想 跳 过 这里 ， 你 可以 直接 跳 到 立即 调用函数 表达式 进行 阅读 ， 但是 我 建议 你 读完 整篇文章 。 它 是 什么 在  JavaScript  里 ， 每个 函数 ， 当 被 调用 时 ， 都 会 创建 一个 新 的 执行 上下文 。 因为 在 函数 里 定义 的 变量 和 函数 是 唯一 在 内部 被 访问 的 变量 ， 而 不是 在 外部 被 访问 的 变量 ， 当 调用函数 时 ， 函数 提供 的 上下文 提供 了 一个 非常简单 的 方法 创建 私有 变量 。function makeCounter() {    var i = 0;    return function(){        console.log(++i);    };}// 记住 ：counter 和 counter2 都 有 他们 自己 的 变量  ivar counter = makeCounter();counter();//1counter();//2var counter2 = makeCounter();counter2();//1counter2();//2i;//ReferenceError: i is not defined( 它 只 存在 于 makeCounter 里 ) 在 许多 情况 下 ， 你 可能 并不需要 makeWhatever 这样 的 函数 返回 多次 累加 值 ， 并且 可以 只 调用 一次 得到 一个 单一 的 值 ， 在 其他 一些 情况 里 ， 你 甚至 不 需要 明确 的 知道 返回值 。 它 的 核心 现在 ， 无论 你 定义 一个 函数 像 这样 function foo(){} 或者 var foo = function(){}， 调用 时 ， 你 都 需要 在 后面 加上 一对 圆括号 ， 像 这样 foo()。// 向 下面 这样 定义 的 函数 可以 通过 在 函数 名 后 加 一对 括号 进行 调用 ， 像 这样 foo()，// 因为 foo 相对 于 函数 表达式 function(){/* code */} 只是 一个 引用 变量 var foo = function(){/* code */}// 那 这 可以 说明 函数 表达式 可以 通过 在 其后 加上 一对 括号 自己 调用 自己 吗 ？function(){ /* code */}(); //SyntaxError: Unexpected token ( 正如 你 所 看到 的 ， 这里 捕获 了 一个 错误 。 当 圆括号 为了 调用函数 出现 在 函数 后面 时 ， 无论 在 全局 环境 或者 局部 环境 里 遇到 了 这样 的 function 关键字 ， 默认 的 ， 它 会 将 它 当作 是 一个 函数 声明 ， 而 不是 函数 表达式 ， 如果 你 不 明确 的 告诉 圆括号 它 是 一个 表达式 ， 它 会 将 其 当作 没有 名字 的 函数 声明 并且 抛出 一个 错误 ， 因为 函数 声明 需要 一个 名字 。( 个人 理解 :  见 扩展 ' 函数 声明 与 函数 表达式 ') 问题 1： 这里 我 么 可以 思考 一个 问题 ， 我们 是不是 也 可以 像 这样 直接 调用函数 var foo = function(){console.log(1)}()， 答案 是 可以 的 。 问题 2： 同样 的 ， 我们 还 可以 思考 一个 问题 ， 像 这样 的 函数 声明 在 后面 加上 圆括号 被 直接 调用 ， 又 会 出现 什么 情况 呢 ？ 请 看 下面 的 解答 。 函数 ， 圆括号 ， 错误 有趣 的 是 ， 如果 你 为 一个 函数 指定 一个 名字 并 在 它 后面 放 一对 圆括号 ， 同样 的 也 会 抛出 错误 ， 但 这次 是因为 另外 一个 原因 。( 个人 理解 :  见 扩展 ' 报错 原因 分析 ') 当 圆括号 放在 一个 函数 表达式 后面 指明 了 这 是 一个 被 调用 的 函数 ， 而 圆括号 放在 一个 声明 后面 便 意味着 完全 的 和 前面 的 函数 声明 分开 了 ， 此时 圆括号 只是 一个 简单 的 代表 一个 括号 ( 用来 控制 运算 优先 的 括号 )。// 然而 函数 声明 语法 上 是 无效 的 ， 它 仍然 是 一个 声明 ， 紧跟着 的 圆括号 是 无效 的 ， 因为 圆括号 里 需要 包含 表达式 function foo(){ /* code */ }();//SyntaxError: Unexpected token// 现在 ， 你 把 一个 表达式 放在 圆括号 里 ， 没有 抛出 错误 ..., 但是 函数 也 并 没有 执行 ， 因为 ：function foo(){/* code */}(1)// 它 等同于 如下 ， 一个 函数 声明 跟着 一个 完全 没有 关系 的 表达式 :function foo(){/* code */}(1); 立即 执行 函数 表达式 （IIFE） 幸运 的 是 ， 修正 语法错误 很 简单 。 最 流行 的 也 最 被 接受 的 方法 是 将 函数 声明 包裹 在 圆括号 里 来 告诉 语法分析 器 去 表达 一个 函数 表达式 ， 因为 在 Javascript 里 ， 圆括号 不能 包含 声明 。 因为 这点 ， 当 圆括号 为了 包裹 函数 碰上 了 function 关键词 ， 它 便 知道 将 它 作为 一个 函数 表达式 去 解析 而 不是 函数 声明 。 注意 理解 这里 的 圆括号 和 上面 的 圆括号 遇到 函数 时 的 表现 是 不 一样 的 ， 也就是说 。 当 圆括号 出现 在 匿名 函数 的 末尾 想要 调用函数 时 ， 它 会 默认 将 函数 当成 是 函数 声明 。 当 圆括号 包裹 函数 时 ， 它 会 默认 将 函数 作为 表达式 去 解析 ， 而 不是 函数 声明 。// 这 两种 模式 都 可以 被 用来 立即 调用 一个 函数 表达式 ， 利用 函数 的 执行 来 创造 私有 变量 (function(){/* code */}());//Crockford recommends this one， 括号 内 的 表达式 代表 函数 立即 调用 表达式 (function(){/* code */})();//But this one works just as well， 括号 内 的 表达式 代表 函数 表达式 // Because the point of the parens or coercing operators is to disambiguate// between function expressions and function declarations, they can be// omitted when the parser already expects an expression (but please see the// \"important note\" below).var i = function(){return 10;}();true && function(){/code/}();0,function(){}();// 如果 你 并 不 关心 返回值 ， 或者 让 你 的 代码 尽可能 的 易读 ， 你 可以 通过 在 你 的 函数 前面 带上 一个 一元 操作符 来 存储 字节 !function(){/* code */}();~function(){/* code */}();-function(){/* code */}();+function(){/* code */}();// Here's another variation, from @kuvos - I'm not sure of the performance// implications, if any, of using the new keyword, but it works.// http://twitter.com/kuvos/status/18209252090847232new function(){ /* code */ }new function(){ /* code */ }() // Only need parens if passing arguments 关于 括号 的 重要 笔记 在 一些 情况 下 ， 当 额外 的 带 着 歧义 的 括号 围绕 在 函数 表达式 周围 是 没有 必要 的 ( 因为 这时候 的 括号 已经 将 其 作为 一个 表达式 去 表达 )， 但 当 括号 用于 调用函数 表达式 时 ， 这 仍然 是 一个 好 主意 。 这样 的 括号 指明 函数 表达式 将 会 被 立即 调用 ， 并且 变量 将 会 储存 函数 的 结果 ， 而 不是 函数 本身 。 当 这 是 一个 非常 长 的 函数 表达式 时 ， 这 可以 节约 比 人 阅读 你 代码 的 时间 ， 不用 滚 到 页面 底部 去 看 这个 函数 是否 被 调用 。 作为 规则 ， 当 你 书写 清楚 明晰 的 代码 时 ， 有 必要 阻止  JavaScript  抛出 错误 的 ， 同样 也 有 必要 阻止 其他 开发者 对 你 抛出 错误 WTFError! 保存 闭 包 的 状态 就 像 当 函数 通过 他们 的 名字 被 调用 时 ， 参数 会 被 传递 ， 而 当 函数 表达式 被 立即 调用 时 ， 参数 也 会 被 传递 。 一个 立即 调用 的 函数 表达式 可以 用来 锁定 值 并且 有效 的 保存 此时 的 状态 ， 因为 任何 定义 在 一个 函数 内 的 函数 都 可以 使用 外面 函数 传递 进来 的 参数 和 变量 ( 这种 关系 被 叫做 闭 包 )。( 个人 理解 :  见 扩展 ' 关于 闭 包 ')//  它 的 运行 原理 可能 并 不 像 你 想 的 那样 ， 因为 i 的 值 从来 没有 被 锁定 。//  相反 的 ， 每个 链接 ， 当 被 点击 时 （ 循环 已经 被 很 好 的 执行 完毕 ）， 因此 会 弹 出 所有 元素 的 总数 ，//  因为 这 是  i  此时 的 真实 值 。var elems = document.getElementsByTagName('a');for(var i = 0;i  log -> i, 那么 在 之后 的 js 执行 过程 中 , 由于 外部 的 变量 logger 通过 一系列 的 指向 , 最终 时 能够 访问 的 最 开始 的 那个 变量 i 的 , 那么 按照 垃圾 回收 机制 , 函数 foo 的 作用域 将 一直 不 能够 被 销毁 , 因为 它 内部 的 变量 i 还有 人 用 着 呢 ! 并且 我们 发现 类似 i 这样 的 变量 能够 保存 很 重要 的 一些 信息 , 比如 函数 被 调用 的 次数 等等 , 我们 就 可以 用来 计数 或者 其它 你 能 发挥 创造力 的 用途 . 关于 缺点 的话 也 是 很 明显 的 , 因为 闭 包 内 的 变量 一直 将 被 保留 着 , 如果 我们 创建 大量 这样 的 变量 或者 大量 的 闭 包 , 那么 浏览器 可用内存 就 会 越来越 小 造成 卡 顿 , 应该 考虑 情况 适当 使用 .","title":"IIFE","oriTitle":"IIFE"},{"uri":"/posts/mini-program","tags":["Mini Program"],"content":" 微 信 小 程序 跳 坑 记录 开发 微 信 小 程序 还是 踩 了 不少 坑 的 ,  官方 的 文档 并 不 详细 ,  更新 也 不 及时 ,  碰到问题 还是 多 google 吧 . 数据 绑定 微 信 小 程序 通过 状态 模式 - 单向 数据流 来 实现 数据 绑定 . 状态 模式定义 一个 对象 ,  当 对象 发生 改变 时 ,  状态 就 发生 改变 ,  然后 通知 与 之 绑定 的 视图 刷新 ,  注意 :  数据流 向 是 单向 的 , \b 即 视图 变化 不会 引起 对象 状态 变化 . 如果 想要 视图 改变 的 时候 让 对象 状态 也 一并 改变 ,  那么 就 需要 依赖 事件 来 实现 ,  即 视图 变化  ->  触发 事件  ->  捕获 事件  ->  回调 处理 ( 在 这里 可以 操作 对象 ) 生命周期    一个 页面 要 正常 显示 ， 必须 经历 以上 3 个 生命周期 ： 加载  ->  显示  ->  渲染 ,  对应 回调 函数 顺序 :onLoad -> onShow -> onReady.   官方 给出 的 示例 中 onReady 放在 onShow 之前 ,  但是 这 并 不是 真正 的 顺序 ,  容易 误导 开发者 组件   hidden 属性    有时候 想要 通过 组件 的 hidden 属性 来 控制 某个 组件 不 显示 ,  但是 hidden=\"true\" 在 遇到 你 已经 设置 过 display: flex; 的 组件 时 是 不会 生效 的 ,  原因 是 hidden=\"true\" 实际上 就是 会 设置 组件 的 css 属性 display: \"none\";,  二者 冲突 导致 覆盖 然后 hidden 不 生效 ,  如果 设置 为 display: block; 变成 块状 布局 就 可以 正常 使用 该 属性 .   或者 采取 如下 解决方案 :     当然 最好 的 办法 就是 别 去 用 这个 有 坑 的 属性 .  [ ] TODO:  测试 是否 如此    对于 不怎么 切换 显示 隐藏 的 组件 可以 使用 wx:if,  这样 的 渲染 支出 是 可以 接受 的 ,  但是 如果 一个 组件 会 经常 的 切换 显示 隐藏 ,  那么 最好 考虑 采取 display: \"none;\" 的 方法 ,  因为 这样 不 需要 重复 渲染 组件 ,  只要 切换 显示 隐藏 即可 ,  可以 减少 cpu 支出 ,  提高 页面 效率 .  官方 说法   scroll-view   注意 ： 使用 竖向 滚动 时 ， 需要 给 scroll-view 一个 固定 高度 ,  否则 无法 点击 回到 顶部 以及 滚动 到 指定 位置   text  text 组件 内 只 支持 嵌套 textrequestGET 一般 都 正常 ,  但是 POST 请求 真 可谓 是 ' 一千个 读者 有 一千个 哈姆雷特 ',  各种 失败 的 情况 都 有 ,  可 尝试 如下 方法 :   首先 method 是 必须 设置 为 POST 的 ;  header 中 设置 \"Content-Type\": \"application/x-www-form-urlencoded\",  也 有 说 小写 \"content-type\": \"application/x-www-form-urlencoded\" 能 成功 ;  data 有 说 不能 直接 传 json 格式 ,  需要 先 转 格式 :function json2Form(json) {    var str = [];    for(var p in json){        str.push(encodeURIComponent(p) + \"=\" + encodeURIComponent(json[p]));    }    return str.join(\"&\");}let data = {  name: ' 张 三 ',  age: '23'};const ajaxData = json2Form(data); //  然后 将 ajaxData 附 在 请求 的 data 中 字 段 中   也 有 说 服务端 必须 是 https 的 ;  实在 不行 服务端 就 改成 GET 吧 ...","title":"Mini-Program","oriTitle":"Mini-Program"},{"uri":"/posts/base64-md5","tags":["encrypt"],"content":"Base64 编码 与 md5 摘要 算法 探究 及 日常 应用 Base64 编码 和 md5 摘要 算法 我们 经常 听到 , 本文 主要 对 着 两者 算法 做 一个 简单 的 了解 探究 Base64Base64 是 一种 基于 64 个 可 打印 字符 来 表示 二进制 数据 的 表示 方法 , 常用 于 在 通常 处理 文本 数据 的 场合 ， 表示 、 传输 、 存储 一些 二进制 数据 ， 包括 MIME 的 电子邮件 及 XML 的 一些 复杂 数据 。Base64 来源 Base64 来源于 电子邮件 的 发展 , 早期 的 电子邮件 是 不 支持 二进制 文件 ( 例如 图片 ) 的 , 并且 邮件 中 也 不 支持 非 英语 字符 , 邮件 也 不能 有 附件 , 再 后来 的 发展 中 工程师 对 电子邮件 的 技术规范 就行了 扩充 , 也 就 产生 了 常 说 的 MIME, 全称 是 全 \"Multipurpose Internet Mail Extensions\"， 中 译 为 \" 多用途 互联网 邮件 扩展 \", 它 包括 了 多项 技术规范 . 一封 传统 的 电子邮件 格式 如下 :From: \"Tommy Lee\"To: \"Jack Zhang\"Subject: TestDate: Wed, 17 May 2000 19:08:29 -0400Message-ID:Hello World. 它 包含 两个 部分 , 第一 部分 是 信封 , 里面 包含 发件人 , 收件人 , 邮件 主题 , 邮件 发送 时间 , 邮件 的 唯一 标识 Message-ID, 第二 部分 是 正文 , 也 就是 邮件 的 内容 , 第一 部分 和 第二 部分 之间 用 一个 空行 隔开 ,MIME 对 传统 邮件 的 扩展 体现 在 在 信封 里面 新增 了 三行 语句 MIME-Version: 1.0 这 行 语句 标志 着 该 邮件 使用 了 MIME 规范 , 收信 端 将 按照 该 规范 进行 解析 邮件 内容 Content-Type: text/plain; charset=\"UTF-8\" 这 行 语句 说明 了 改 邮件 的 信息 类型 和 编码方式     Content-Type 表明 信息 类型 ， 缺省值 为 \" text/plain\"     它 包含 了 主要 类型 （primary type） 和 次要 类型 （subtype） 两个 部分 ， 两者之间 用 \"/\" 分割 。 主要 类型 有 9 种 ， 分别 是 application、audio、example、image、message、model、multipart、text、video, 每种 主要 类型 下面 又 分为 多种 次要 类型 , 常用 的 一些 Content-Type 类型 如下 :        text/plain： 纯 文本 ， 文件 扩展名 .txt    text/html：HTML 文本 ， 文件 扩展名 .htm 和 .html    image/jpeg：jpeg 格式 的 图片 ， 文件 扩展名 .jpg    image/gif：GIF 格式 的 图片 ， 文件 扩展名 .gif    audio/x-wave：WAVE 格式 的 音频 ， 文件 扩展名 .wav    audio/mpeg：MP3 格式 的 音频 ， 文件 扩展名 .mp3    video/mpeg：MPEG 格式 的 视频 ， 文件 扩展名 .mpg    application/zip：PK-ZIP 格式 的 压缩文件 ， 文件 扩展名 .zip         如果 信息 的 主要 类型 是 \"text\"， 那么 还 必须 指明 编码 类型 \"charset\"， 缺省值 是 ASCII， 其他 可能 值 有 \"ISO-8859-1\"、\"UTF-8\"、\"GB2312\" 等等 。Content-transfer-encoding: Base64 这里 我们 的 主角 就 登场 了 , 这 行 语句 表明 邮件 编码 转换 的 方式 , 因为 现代 邮件 里面 会 有 图片 或者 其它 原始 邮件 不 支持 的 内容 , 那么 在 发送 的 时候 就 需要 对 内容 进行 编码 转换 , 将 内容 转换成 邮件 支持 的 ASCII 字符 ,Content-transfer-encoding 的 值 有 5 种 ----\"7bit\"、\"8bit\"、\"binary\"、\"quoted-printable\" 和 \"Base64\"---- 其中 \"7bit\" 是 缺省值 ， 即 不用 转化 的 ASCII 字符 。 真正 常用 是 \"quoted-printable\" 和 \"Base64\" 两种 .quoted-printable 编码 关于 'quoted-printable' 简单 介绍 一下 , 它 主要 用于 ACSII 文本 中 夹杂 少量 非 ASCII 码 字符 的 情况 ， 不 适合 于 转换 纯 二进制 文件 . 它 规定 将 每 一个 8 位 的 字节 ， 转换 为 3 个字符 , 规则 如下 : 所有 可 打印 的 ASCII 码 字符 （ 十进制 值 从 33 到 126） 都 保持 原样 不变 ，\"=\"（ 十进制 值 61） 除外 , 其余 的 字符 都 要 进行 编码 。 编码 后 第一个 字符 是 \"=\" 号 ， 这 是 固定 不变 的 ; 编码 后 二 个字符 是 二个 十六进制 数 ， 分别 代表 了 这个 字节 前 四位 和 后 四位 的 数值 。 例如 ASCII 码 中 的 换页 键 的 码 值 是 12, 那么 先 转 成 8 位 的 二进制 是 00001100, 再 转 成 16 进制 是 0C, 然后 再 在 前面 加上 一个 '=' 号 , 最后 的 编码 结果 是 '=0C'.Base64 编码 首先 选出 一个 字符集 , 分别 是 小写字母 a-z、 大写字母 A-Z、 数字 0-9、 符号 \"+\"、\"/\" 加 起来 是 64 个 , 另外 有 一个 垫 字符 '=', 然后 将 其它 所有 不 在 这个 字符集 里面 的 字符 都 转换 到 到 这个 字符集 里面 去 , 转换规则 如下 : 将 每 三个 字节 作为 一组 ， 一共 是 24 个 二进制位 ; 再 将 这 24 个 二进制位 分为 四组 ， 每个 组 有 6 个 二进制位 ; 在 每组 前面 加 两个 00， 扩展 成 32 个 二进制位 ， 即 四个 字节 ; 查询 字符 表 , 找到 每个 字节 在 表 中 对应 的 符号 ， 这 就是 Base64 的 编码 值 ; 所以 分析 最终 的 结果 的话 , 原始 的 三个 字节 经过 转换 以后 会 变成 4 个 字节 , 因此 Base64 编码 后 的 文本 ， 会 比 原文 本 大 出 三分之一 左右 。Base64 编码 示例 编码 译文 单词 'six':s i x ->> 115 105 120 -> 01110011 01101001 01111000 -> 011100 110110 100101 111000 -> 00011100 00110110 00100101 00111000 -> 28 54 37 56 -> c 2 l 4 则 'six' 编码 后 的 结果 是 'c2l4', 你 可以 用 这个 工具 来 验证 你 的 转码 结果 是否 正确 . 如果 字节数 不足 三 ， 则 处理 如下 : 二个 字节 的 情况 ： 将 这 二个 字节 的 一共 16 个 二进制位 ， 按照 上面 的 规则 ， 转 成 三组 ， 最后 一组 除了 前面 加 两个 0 以外 ， 后面 也 要 加 两个 0。 这样 得到 一个 三位 的 Base64 编码 ， 再 在 末尾 补 上 一个 \"=\" 号 。 比如 ，\"Ma\" 这个 字符串 是 两个 字节 ， 可以 转化成 三组 00010011、00010110、00010000 以后 ， 对应 Base64 值 分别 为 T、W、E， 再 补 上 一个 \"=\" 号 ， 因此 \"Ma\" 的 Base64 编码 就是 TWE=。 一个 字节 的 情况 ： 将 这 一个 字节 的 8 个 二进制位 ， 按照 上面 的 规则 转 成 二组 ， 最后 一组 除了 前面 加 二个 0 以外 ， 后面 再 加 4 个 0。 这样 得到 一个 二位 的 Base64 编码 ， 再 在 末尾 补 上 两个 \"=\" 号 。 比如 ，\"M\" 这个 字母 是 一个 字节 ， 可以 转化 为 二组 00010011、00010000， 对应 的 Base64 值 分别 为 T、Q， 再 补 上 二个 \"=\" 号 ， 因此 \"M\" 的 Base64 编码 就是 'TQ=='。 再 举 一个 中文 的 例子 ， 汉字 \" 严 \" 如何 转化成 Base64 编码 ？ 这里 需要 注意 ， 汉字 本身 可以 有 多种 编码 ， 比如 gb2312、utf-8、gbk 等等 ， 每 一种 编码 的 Base64 对应 值 都 不 一样 。 下面 的 例子 以 utf-8 为 例 。 首先 ，\" 严 \" 的 utf-8 编码 为 E4B8A5， 写成 二进制 就是 三 字节 的 \"11100100 10111000 10100101\"。 将 这个 24 位 的 二进制 字符串 ， 按照 第 3 节 中 的 规则 ， 转换成 四组 一共 32 位 的 二进制 值 \"00111001 00001011 00100010 00100101\"， 相应 的 十进制 数 为 57、11、34、37， 它们 对应 的 Base64 值 就 为 5、L、i、l。 所以 ， 汉字 \" 严 \"（utf-8 编码 ） 的 Base64 值 就是 5Lil。Base64 在 js 中 的 使用 Base64 的 js 实现 如下 :/**Base64 encode / decode@author haitao.tu@date   2010-04-26@email  tuhaitao@foxmail.com*/function Base64() {\t// private property\t_keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\t// public method for encoding\tthis.encode = function (input) {\t\tvar output = \"\";\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4;\t\tvar i = 0;\t\tinput = utf8encode(input);\t\twhile (i > 2;\t\t\tenc2 = ((chr1 & 3) > 4);\t\t\tenc3 = ((chr2 & 15) > 6);\t\t\tenc4 = chr3 & 63;\t\t\tif (isNaN(chr2)) {\t\t\t\tenc3 = enc4 = 64;\t\t\t} else if (isNaN(chr3)) {\t\t\t\tenc4 = 64;\t\t\t}\t\t\toutput = output +\t\t\tkeyStr.charAt(enc1) + keyStr.charAt(enc2) +\t\t\tkeyStr.charAt(enc3) + keyStr.charAt(enc4);\t\t}\t\treturn output;\t}\t// public method for decoding\tthis.decode = function (input) {\t\tvar output = \"\";\t\tvar chr1, chr2, chr3;\t\tvar enc1, enc2, enc3, enc4;\t\tvar i = 0;\t\tinput = input.replace(//g, \"\");\t\twhile (i > 4);\t\t\tchr2 = ((enc2 & 15) > 2);\t\t\tchr3 = ((enc3 & 3)  127) && (c > 6) | 192);\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\t\t\t} else {\t\t\t\tutftext += String.fromCharCode((c >> 12) | 224);\t\t\t\tutftext += String.fromCharCode(((c >> 6) & 63) | 128);\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\t\t\t}\t\t}\t\treturn utftext;\t}\t// private method for UTF-8 decoding\tutf8decode = function (utftext) {\t\tvar string = \"\";\t\tvar i = 0;\t\tvar c = c1 = c2 = 0;\t\twhile ( i  191) && (c > 5] |= 0x80 >> 9)  16) bkey = core_md5(bkey, key.length * chrsz);  var ipad = Array(16), opad = Array(16);  for(var i = 0; i > 16) + (y >> 16) + (lsw >> 16);  return (msw >> (32 - cnt));}/* Convert a string to an array of little-endian words If chrsz is ASCII, characters >255 have their hi-byte silently ignored. */function str2binl(str){  var bin = Array();  var mask = (1 >5] |= (str.charCodeAt(i / chrsz) & mask) >5] >>> (i % 32)) & mask);  return str;}/* Convert an array of little-endian words to a hex string. */function binl2hex(binarray){  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";  var str = \"\";  for(var i = 0; i >2] >> ((i%4)*8+4)) & 0xF) +           hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);  }  return str;}/* Convert an array of little-endian words to a base-64 string */function binl2b64(binarray){  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";  var str = \"\";  for(var i = 0; i > 2] >> 8 * ( i   %4)) & 0xFF) > 2] >> 8 * ((i+1)%4)) & 0xFF) > 2] >> 8 * ((i+2)%4)) & 0xFF);    for(var j = 0; j  binarray.length * 32) str += b64pad;      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);    }  }  return str;}`","title":"Base64-md5","oriTitle":"Base64-md5"},{"uri":"/posts/git-workflow","tags":"git","content":"git 的 日常 使用 流程 记录 内容 参考 于 阮 一峰 老师 的 Git 使用 规范 流程 ， 记录 一下 git 的 日常 使用 流程 。1.  新建 分支 开发新 功能 时 都 应该 新建 一个 分支 ， 在 分支 上 开发 ， 当 功能 开发 完成 时 再 合并 到 主 分支 ， 并 销毁 新建 的 分支 。git checkout—— 检出 ， 是 我们 的 常用命令 。 最为 常用 的 两种 情形 是 创建 分支 和 切换 分支 先 切换 到 主 分支 ， 获取 最新 代码 git checkout mastergit pull 然后 新建 分支 ， 在 这个 分支 上 进行 新 功能 开发 git checkout -b myfeature2.  提交 分支 新 功能 开发 完成 以后 提交 代码 默认 保存 所有 改动  --allgit add 查看 发生 改动 的 地方 git status 提交 改动 ， 也 可以 跟上  --verbose， 然后 就 可以 列出 diff 比较 的 结果 ， 并且 附上 本次 提交 信息 git commit3.  同步 代码 开发 过程 中 可以 经常 同步 主 分支 的 最新 代码 ， 保证 一直 在 最新 的 基础 上 进行 开发 git fetch  表示 取回 最新 代码 git fetch origin 将 有 更新 的 代码 与 当前 分支 合并 所 取回 的 更新 ， 在 本地 主机 上 要 用 \" 远程 主机名 / 分支 名 \" 的 形式 读取 。 比如 origin 主机 的 master， 就要 用 origin/master 读取 。 或者 使用 ： git merge origin/mastergit rebase origin/master4.  合并 多个 commit 新 功能 开发 过程 中 一般 会 多次 commit， 但是 在 功能 开发 完成 以后 需要 合并 到 主干 时 ， 一般 把 之前 的 commit 合并 成 一个 或 几个 关键 的 commitgit rebase 命令 的 i 参数 表示 互动 （interactive）， 具体 如何 合并 请 参见 原文 git rebase -i origin/master5.  推送 到 远程 仓库 多个 commit 经过 合理 的 处理 以后 就 可以 把 当前 分支 推送 到 远程 仓库 了 git push 命令 要 加上 force 参数 ， 因为 rebase 以后 ， 分支 历史 改变 了 ， 跟 远程 分支 不 一定 兼容 ， 有 可能 要 强行 推送 git push --force master myfeature6.  发出 Pull Request 提交 到 远程 仓库 以后 ， 就 可以 发出  Pull Request  到 master 分支 ， 然后 请求 别人 进行 代码 review， 确认 可以 合并 到 master。 参考 文档 : http://www.ruanyifeng.com/blog/2014/06/git_remote.html(end)","title":"git-workflow","oriTitle":"git-workflow"},{"uri":"/posts/markdown","tags":["markdown"],"content":"markdown 语法 整理 经常 使用 markdown 来 做 笔记 ， 这里 把 现在 常用 的 语法 先 记录 一下 ， 万一 老年人 了 记忆 不好 ， 也 可以 查 一 查 标题 h1......h6 分隔符 最少 三个 --- 或 * 目录 ( 部分 markdown 软件 不 支持 )[TOC] 引用 > quote(\b 每行 最后 添加 两个 空格 即 表示 换行 )quote> quote( 或者 采取 每行 前面 都 添加 引用 标志 )> quote> quote( 多行 嵌套 引用 )>> quote2>>> quote3 代码 行内 代码 code 行内 代码 多行 代码 ， 支持 \b 高 亮 语言 链接 个人 博客 或者 [blog]: https://kricsleo.github.io/ 'krics 的 个人 博客 ' 个人 博客 图片 或者 [avatar]: https://kricsleo.github.io/images/avatar.jpg 'krics 的 个人头像 ' 图片 带 链接 序 表 有序 节点 节点 1     节点 1.1 节点 2 无序 节点 节点 $     节点 $.^ 节点      节点 #.& 任务 [ ]  未 完成 [x]  已 完成 表格 附上 在线 生成 表格 工具 |    a    |       b       |      c     ||:-------:|:------------- | ----------:||    居中    |       左 对齐     |     右 对齐    | 语义 性 斜体  or  斜体 加粗  or  加粗 斜体 加粗  or  强调 删除 线 上标 u 下标 d 键盘 按键 Ctrl 格式化 显示     ... 公式 [ ]  目前 还 不 常用 ， 之后 补齐 脚注 Markdown 在 页面 底端 注解 : Markdown 是 一种 纯 文本 标记 语言 定义 型 列表 Markdown:   Markdown 是 一种 纯 文本 标记 语言   ( 冒号 后 跟 一个 'Tab' 或者 四个 空格 ) 邮箱 流程图 markdown 的 代码 绘制 流程图 个人感觉 比较复杂 ， 个人 使用 的 在线 绘制 工具 ProcessOn","title":"markdown","oriTitle":"markdown"},{"uri":"/posts/practical-function-in-javascript","tags":["funtion"],"content":"JavaScript 中 的 常用 函数 本文 主要 整理 了 平时 JavaScript 中 常用 的 函数 ,  持续 更新 . 数组 Array.concat() 作用 :  合并 数组 ,  返回 新 数组 ,  不 影响 原 数组 备注 :  字符串 中 也 有 此 同名 函数 ,  作用 可 类比 Array.filter() 作用 :  对 数组 每个 元素 进行 测试 ,  返回 符合条件 的 元素 组成 的 新 数组 ,  不 影响 原 数组 Array.find() 作用 :  返回 数组 中 满足 提供 的 测试函数 的 第一个 元素 的 值 ,  否则 返回  undefinedArray.forEach() 作用 :  对 数组 的 每个 元素 执行 一次 提供 的 函数 ,  不 影响 原 数组 Array.includes() 作用 :  判断 数组 是否 包含 某个 值 ,  是 则 返回 true,  否则 返回 false 备注 :  字符串 中 也 有 此 同名 函数 String.includes(subSring, fromIndex),  用于 判断 字符串 是否 包含 另 一个 字符串 Array.indexOf() 作用 :  返回 数组 中 给定 元素 的 索引 值 ， 若 给定 元素 不 存在 ， 则 返回值 是 -1 备注 :  字符串 中 也 有 此 同名 函数 ,  作用 可 类比 ###Array.join() 作用 :  将 数组 中 的 所有 元素 用 给定 方式 连接成 一个 字符串 ， 默认 用 ， 连接 ,  可用 空 字符串 '' 连接 ,  不 影响 原 数组 Array.map()  作用 :  对 数组 中 的 每个 元素 都 调用 一个 提供 的 函数 后 返回 的 结果 组成 一个 新 数组 ,  返回 新 数组 ,  不 影响 原 数组 Array.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue) 作用 :  对 累加器 和 数组 中 的 每个 元素 （ 从左到右 ） 应用 一个 函数 ， 将 其 减少 为 单个 值 ,  此 函数 功能强大 ,  建议 参考 官方 文档 Array.slice() 作用 :  将 数组 的 制定 部分 ( 包括 开始 位置 ,  不 包括 结束 位置 ) 浅 拷贝到 一个 新 数组 ,  不 影响 原 数组 备注 :  字符串 中 也 有 此 同名 函数 ,  作用 可 类比 Array.splice() 作用 :  通过 删除 现有 元素 和 / 或 添加 新元素 来 更改 一个 数组 的 内容 ,  返回 被 删除 的 元素 组成 的 数组 ,  如果 没有 删除 ,  则 返回 空 数组 ,  会 改变 原 数组 ,  此 函数 功能强大 ,  建议 参考 官方 文档 字符串 String.charAt() 作用 :  返回 字符串 中 指定 位置 的 字符 ,  不 存在 则 返回 空 字符串 \"\"String.charCodeAt() 作用 :  返回 字符串 中 指定 位置 的 字符 的 UTF-16 代码 单元 值 的 数 ,  在 0 到 65535 之间 ,  超出范围 返回 NaNString.match() 作用 :  将 字符串 与 正则表达式 匹配 ,  返回 匹配 后 的 结果 数组 , 数组 的 第一项 是 进行 匹配 完整 的 字符串 ， 之后 的 项 是 用 圆括号 捕获 的 结果 。 如果 没有 匹配 到 ， 返回 null,  不 影响 原 数组 如果 给 的 参数 不是 正则表达式 ,  那么 会 隐 式 的 转换成 正则表达式 ,  此 函数 功能 很 强大 ,  请 参考 官方 文档 备注 : RegExp.text() 用来 测试 字符串 是否 与 正则 匹配   速度 会 更 快 ,  如果 匹配 则 返回 true,  否则 返回 falseString.search() 也 类似 test() 方法 ,  只不过 返回 的 值 是 第一个 匹配 的 地方 的 索引 值 ,  如果 没有 匹配 则 返回 -1RegExp.exec() 的 行为 和 String.match() 很 相似 ,  在 非 全局 匹配 下 表示 一样 ,  但是 对于 全局 匹配 /g 他们 的 表现 就 不同 ,  简单 来说 就是 match() 的 全局 匹配 会 一次 找到 全部 的 匹配 项 放在 数组 中 返回 ,  但是 exec() 的 全局 匹配 是 每 调用 一次 exec() 就 返回 在 上 一次 执行 的 基础 上 继续 搜索 的 下 一个 匹配 结果 ,  直到 最后 找 不到 的 时候 就 会 返回 null,  参考 这里 Sring.replace() 作用 :  将 字符串 中 的 匹配 值 ( 字符串 或者 正则表达式 匹配 到 的 值 ) 用 另外 的 值 ( 替换 的 字符串 或者 一个 方法 返回 的 值 ) 替换 ,  然后 返回 新 的 字符串 ,  不 影响 原 字符串 使用 字符串 匹配 时 只 会 替换 第一个 匹配 的 结果 关于 第二个 参数 如果 使用 字符串 ,  那么 $&, $n, ... 等 能够 作为 代替 匹配 的 结果 字符串 使用 ,  如果 使用 函数 ,  那么 match, p1, p2, ... 能够 代替 匹配 的 结果 在 函数参数 中 使用 ,  具体 请 参见 官方 文档 没有 replaceAll 方法 ,  可 自己 实现 替代 方法 String.split() 作用 :  将 字符串 按照 匹配 的 字符串 或者 正则表达式 进行 分割 ,  返回 分割 的 结果 组成 的 数组 ,  不 影响 原 字符串 关于 分割 的 结果 中 有时 会 产生 空 字符串 '' 的 原因 可以 参考 KevinYue 的 这 篇文章 ,  评论 中 的 ' 切 黄瓜 ' 的 比喻 也 有助于 理解 ,  另外 使用 正则表达式 时会 忽略 全局 匹配 符 /gString.substr() 作用 :  将 字符串 中 从 指定 位置 开始 的 指定 长度 ( 不 指定 长度 则 到 字符串 末尾 ) 的 部分 拷贝 为 新 字符串 返回 ,  不 影响 原 字符串 String.substring() 作用 :  将 字符串 中 从 指定 位置 开始 ( 包含 ) 到 指定 位置 结束 ( 不 包含 )( 或者 默认 到 结尾 ) 的 部分 拷贝 伟 新 字符串 返回 ,  不 影响 原 字符串 String.trim() 作用 :  返回 字符串 开头 和 结尾 的 空白 字符 ( 包括 space, tab, no-break space 等 以及 所有 行 终止符 字符 如  LF，CR) 都 移出 的 新 字符串 ,  不 影响 原 字符串 参考 文档 1","title":"Practical-Function-In-Javascript","oriTitle":"Practical-Function-In-Javascript"},{"uri":"/posts/ssh-git","tags":["ssh","github"],"content":"github 的 https 和 ssh 连接 方式 探究 在 本 机 连接 github 仓库 提交 代码 时 有 两种 可 选 方法 ， 一种 是 使用 github 账号 的 用户名 和 密码 的 认证 方式 通过 https 连接 ， 另 一种 是 使用 ssh-key 的 认证 方式 通过 ssh 连接 ， 本文 主要 研究 这 两种 方式 的 工作 过程 以及 可能 会 扩展 探究 一些 相关 的 知识 。 两种 方式 首先 在 本 机 下载安装 Git， 一路 点 next 默认 安装 即可 ;clone 一个 github 上 的 项目 到 本地 选择 使用 https 以 我 的 博客 所 使用 hexo 的 materialFlow 主题 项目 为 例 ( 这个 项目 我 没有 管理权限 )， 一行 命令 git clone https://github.com/stkevintan/hexo-theme-material-flow.git 即可 clone 到 本地 选择 使用 ssh 此时 你 就 无法 直接 使用 git clone git@github.com:stkevintan/hexo-theme-material-flow.git 命令 来 clone 上面 那个 项目 到 本地 ， 会 产生 如下 错误 提示 ：> fatal: Could not read from remote repository.> Please make sure you have the correct access rights and the repository exists. 因为 ssh 的 方式 是 需要 进行 认证 的 ， 你 必须 是 这个 项目 的 所有者 或者 管理者 ， 才能 有 权限 去 使用 ssh 方式 clone 该 项目 ， 而 上面 的 https 方式 则 允许 任何 一个 人 在 不 需要 验证 的 情况 下去 clone 项目 . 那么 接下来 看 一下 对于 一个 我们 有 管理权限 的 仓库 应该 如何 使用 ssh 方式 去 clone 到 本地 ssh 方式 是 基于 不对称性 加密 来 通信 的 ， 你 需要 使用 不对称性 算法 来 生成 一对 密钥 ， 然后 将 私钥 放置 在 你 本 机上 ， 将 公 钥 放置 在 github 服务器 上 ， 之后 在 进行 ssh 通信 时 将 会 使用 这 对 秘 钥 来 完成 认证 登陆 及 加密 和 解密 信息 ， 在 window 上 和 mac 上 我们 都 可以 使用 ssh-keygen 这个 命令行 工具 来 生成 我们 需要 的 密钥 ， 这 是 我们 想要 使用 ssh 通信 的 第一步 生成 一对 密钥 打开 你 的 命令行 （window 下 使用 cmd.exe，mac 下 使用 terminal.app）， 然后 按照 \b 如下 命令 来 生成 密钥 ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 参数 说明 ：ssh-keygen:  表示 将要 使用 ssh-keygen 这个 工具 来 生成 密钥 -t:  指定 要 生成 的 密钥 类型 ， 有 rsa1(SSH1),dsa(SSH2),ecdsa(SSH2),rsa(SSH2) 等 类型 ， 较为 常用 的 是 rsa 类型 ， 此处 指定 为 rsa 类型 -b:  指定 要 生成 的 密钥 长度  ( 单位 :bit)， 对于 RSA 类型 的 密钥 ， 最小 长度 768bits, 默认 长度 为 2048bits。DSA 密钥 必须 是 1024bits， 此处 指定 为 4096bits-C:  制定 要 生成 的 密钥 的 注释 ， 这个 可以 自己 随意 填写 ， 就 相当于 给 这个 密钥 留 个 名 ， 好 分辨 ， 比如 此处 可以 用 注册 github 的 邮箱 号 之后 会 出现 如下 提示 内容 ：> Generating public/private rsa key pair.> Enter file in which to save the key (C:/Users/xxxxx/.ssh/id_rsa): 意思 是 让 你 输入 这个 密钥 文件 的 文件名 ， 一般 情况 保存 默认 就 可以 ， 直接 回车 确认 。（ 如果 你 有 多个 git 的 账号 需要 配置 ， 比如 你 自己 在 github 上 有 账号 需要 提交 代码 ， 同时 自己 在 公司 也 有 git 的 账号 ， 有时候 需要 提交 代码 到 公司 的 仓库 里 ， 那么 这时候 你 就 需要 额外 的 配置 来 保证 提交 的 时候 不会 冲突 ， 详见 下面 ） 然后 会 出现 下 一个 提示 内容 ：> Enter passphrase (empty for no passphrase): 意思 是 要 不要 对 私钥 设置 口令 （passphrase）， 如果 担心 私钥 的 安全 ， 你 可以 设置 一个 ， 这里 一般 不 设置 ， 直接 回车 确认 即可 ， 最后 会 出现 类似 如下 的 提示 内容 ：> +---[RSA 4096]----+| o+o     ..  .o  || oo... o ... =   ||+ +.+ o.o.o.+ o  ||oB =.o..E.o* o   ||o = o.o Soo+=    ||   . o .+++ .    ||       o.o       ||      ..         ||      ..         |+----[SHA256]-----+ 那 \b 么 恭喜 你 ， 你 已经 生成 了 一对 密钥 文件 ，\b 他们 存储 在 C:/Users/xxxxx/.ssh/（windows） 或者 ~/.ssh（mac） 目录 下 ， 默认 的 文件 是 idrsa（ 私钥 文件名 ） 和 idrsa.pub（ 公 钥 文件名 ）， 你 可以 去 打开 查看 一下 里面 的 内容 。 部署 密钥 之前 说 过 了 你 需要 将 私钥 保存 在 本 机 ， 公 钥 放置 在 服务器 上 ， 这样 之后 才能 用 这 对 密钥建立 ssh 通信 ， 那么 在 github 上 我们 按照 如下 做法 来 部署 密钥      用 文本编辑 器 打开 刚才 生成 的 公 钥 文件 id_rsa.pub， 拷贝 里面 的 全部内容 ；     打开 浏览器 登陆 你 的 github 账户 ， 依次 打开 你 头像 上 的 Settings > SSH and GPG keys > New SSH key;     填写 相关 信息 ，title 可以 类似 之前 生成 密钥 时 填写 的 注释 信息 那样 填写 你 的 邮箱 名 ， 然后 key 里面 填 上 刚才 拷贝 的 公 钥 内容 ， 点击 Add SSH key 之后 输入 一次 你 的 github 账户 密码 进行 确认 ， 然后 你 的 公 钥 就 被 保存 部署 到 github 服务器 上 了 ； 测试 连接 ， 使用 如下 命令 来 测试 是否 能够 通过 ssh 连接 到 githubssh git@github.com 参数 说明 ：ssh:  使用 ssh 进行 连接 git@github.com: ssh 连接 时 需要 指定 登陆 用户名 和 远程 主机名 ， 这里 的 git 就是 github 的 远程 服务器 的 用户名 ，github.com 就是 远程 服务器 的 主机名 ， 用 '@' 符号 连接起来 当 你 是 第一次 连接 的 时候 会 提示 你 如下 信息 ：> The authenticity of host 'github.com (52.74.223.119)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 这 是因为 你 是 第一次 连接 该 主机 ， 该 主机 不 在 你 本 机 的 known hosts（ 已知 主机 ） 名单 里面 ， 所以 询问 你 是否 要 继续 连接 这个 陌生 的 主机 ， 输入 yes 然后 回车 确认 即可 ， 之后 再次 连接 的 时候 就 不会 有 这个 提示信息 了 。 如果 你 配置 步骤 没 问题 的话 应该 可以 看到 下面 的 连接 上 之后 的 欢迎 信息 (xxxxx 代表 你 的 github 的 账户 名 )：> Warning: Permanently added 'github.com,52.74.223.119' (RSA) to the list of known hosts.PTY allocation request failed on channel 0Hi xxxxx! You've successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 使用 ssh 方式 clone 项目 之前 说 过 了 ssh 方式 只能 操作 我们 有 管理权限 的 项目 ， 所以 这里 我 拿 自己 做 的 一个 微 信 小 程序 的 虚拟 车牌 键盘 的 项目 为 例 git clone git@github.com:kricsleo/vehicleKeyboard.git 这个 时候 我们 就 能 顺利 clone 该 项目 到 本 机 了 ， 因为 在 我们 上面 这 条 命令 请求 数据 的 过程 中 ， 我们 本 机 和 github 的 服务器 会 使用 我们 之前 生成 的 那 对 密钥 来 进行 相互 认证 ， 从而 使 我们 不 需要 手动 输入 github 的 账户 名 和 密码 信息 来 完成 认证 登陆 ， 同时 我们 以后 修改 了 项目 代码 在 进行 提交 的 时候 也 可 直接 进行 提交 等 相关 操作 ， 无需 再 考虑 登陆 及 连接 的 问题 ，git 的 使用 可以 参考 我 之前 的 一篇 小 总结 配置 个人信息 使用 git 提交 更改 的 时候 会 为 本次 提交 附上 提交 人 的 \b 一些 信息 ， 比如 提交 人 的 用户名 及 邮箱 信息 ， 我们 可以 使用 git 提供 的 配置 功能 来 提前 配置 好 这些 信息 ， 使用 如下 ：git config --global user.name \"John Doe\"git config --global user.email \"johndoe@example.com\" 参数 说明 ：git config:  表示 使用 git 的 配置 工具 --global:  表示 配置 全局 的 信息 ， 你 也 可以 在 某个 项目 下面 单独 配置 这个 信息 ， 只 需要 去掉 '--global' 即可 ，<-  这样 不同 的 项目 就 会 有 不同 提交 人 信息 user.name / user.email:  后面 跟上 你 自己 的 用户名 和 邮箱 信息 即可 之后 我们 可以 使用 如下 命令 来 查看 我们 配置 的 信息 #git config user.name#git config user.email 多 git 账户 配置 如果 你 需要 生成 多 对 密钥 ， 比如 你 需要 和 两个 不 一样 的 服务器 A 和 B 进行 ssh 通信 ， 那么 这个 时候 你 就 可以 生成 两对 密钥 ， 一对 用来 和 A 通信 ， 另 一对 用来 和 B 通信 ， 最 常见 的 情况 就是 我们 自己 在 github 上面 会 有 自己 的 github 账户 ， 自己 平时 会 开发 一些 自己 的 项目 ， 然后 提交 到 github 上面 ， 在 公司 里面 公司 一般 会 有 自己 的 gitlab 服务器 ， 然后 给 员工 开通 一个 gitlab 的 账号 ， 有关 公司 内部 的 项目 就 会 让 员工 用 gitlab 的 账户 进行 开发 ， 然后 提交 代码 到 公司 的 gitlab 上面 ， 那么 这时候 我们 可以 按照 如下 的 方法 来 配置 一下 ， 保证 自己 随时 提交 代码 的 时候 都 是 能够 提交 到 正确 的 地方 ， 而 不会 混乱 。 再 生成 一对 密钥 在 上面 的 操作 中 你 已经 生成 了 一对 密钥 ， 名字 叫做 idrsa 和 idrsa.pub（ 如果 你 没有 改名 的话 ）， 这个 密钥 我们 已经 拿来 和 github 进行 通信 了 ， 此时 我们 要 想 和 公司 的 gitlab 通信 就 需要 再 生成 一对 密钥 ， 为了 避免 这次 生成 的 密钥 覆盖 我们 之前 的 那 对 密钥 ， 可以 执行 如下 命令 ：ssh-keygen -t rsa -b 4096 -C \"youremail@yourcompany.com” -f ~/.ssh/idrsaxx 参数 说明 这次 我们 生成 密钥 的 命令 只 比 之前 多 了 一个 参数 ： -f-f:  表示 将 这次 什么 的 密钥 文件 保存 为 idrsaxx， 同样 放在 了 之前 的 那个 文件夹 ， 这个 文件名 你 可以 自己 随意 指定 ， 不过 最 好容易 区分 一些 后面 你 的 操作 就 和 之前 生成 密钥 一样 了 ， 生成 好 密钥 之后 再 看 下 一步 部署 新 生成 的 密钥 和 之前 部署 github 密钥 的 步骤 类似 ， 你 登录 你 公司 的 gitlab， 找到 添加 ssh-key 的 地方 ， 然后 拷贝 新 生成 的 公 钥 idrsaxx.pub 文件 内容 到 gitlab 里面 去 并且 保存 ， 这样 你 公司 的 gitlab 服务器 上 的 公 钥 信息 就 配置 好 了 新建 配置文件 因为 现在 我们 本 机上 有 了 两对 密钥 ， 提交 代码 到 github 时 需要 使用 之前 生成 的 那 一对 ， 提交 代码 到 公司 的 gitlab 上 需要 我们 现在 刚刚 生成 的 这 一对 ， 那么 我们 就要 写 一个 简单 的 配置文件 来 告诉 git 该 如何 再 提交 代码 时 选择 正确 的 密钥 ， 实际上 就是 编写 SSH 的 用户 配置文件 config。 在 目录 ~/.ssh(mac 环境 ) 或者 C:/Users/xxxxx/.ssh/ 下 新建 文件 config， 注意 没有 后缀名 的 ， 然后 在 里面 填写 上 如下 内容 ：#githubHost github.com    HostName github.com    User git    IdentityFile ~/.ssh/id_rsa#yourcompanyHost git.XXXXX.com    HostName git.XXXXX.com    User git    IdentityFile ~/.ssh/idrsaXX 参数 说明 ， 此 段 内容 不用 拷贝 ， 是 为了 加以 说明 Host:  别名 ， 为了 方便 记忆 和 区分 ， 可以 任意 填写 HostName：  主机名   服务器 的 主机名 ， 也 可以 是 服务器 的 ip 地址 ， 需要 准确 填写 User：  用户名 ，ssh 登录 服务器时 的 用户名 ， 一般 是 gitIdentityFile：  密钥 文件 的 路径 ， 填写 上 你 要 用来 和 这个 服务器 通信 使用 的 密钥 文件 的 路径 PreferredAuthentications：  强制 使用 Public Key 验证 ， 我 这里 没有 要求 这个 ， 你 也 可以 加上 测试 连接 使用 如下 命令 来 分别 测试 能否 连接 到 对应 的 服务器 测试 连接 公司 ssh git@git.XXXXX.com 测试 连接 githubssh git@github.com 如果 能 分别 看到 对应 的 欢迎 信息 ， 那么 恭喜 你 配置 正确 了 。 配置 个人信息 这次 我们 因为 有 不同 的 项目 ， 提交 时 需要 附加 上 的 个人信息 也 不 一样 ， 你 提交 github 时会 用 你 自己 的 github 账户 名 和 邮箱 信息 ， 但是 提交 公司 的 gitlab 时会 使用 公司 给 你 的 账户 名 和 公司 个人 邮箱 ， 那么 我们 就 需要 到 具体 的 项目 下面 执行 如下 的 命令 ：git config user.name \"yourname\"git config user.email \"youremail@XXXXX.com\" 参数 说明 与 之前 我们 执行 的 那条 配置 个人信息 命令 相比 ， 只是 少 了 个 '--global' 参数 ， 因为 我们 现在 不是 在 全局 配置 ， 而是 在 个别 项目 中 单独 配置 到 这里 为止 ， 你 的 多 git 账户 依旧 配置 完毕 了 ， 后面 就 可以 和 平常 一样 使用 git 来 提交 代码 了 ，ssh 会 为 你 选择 正确 的 密钥 来 和 服务器 认证 和 通信 。 备注 这 篇文章 里面 给 我 自己 埋 了 些 坑 要 填 [ ]  完全 使用 https 协议 该 如何 用 git 来 开发 项目 [ ]  另外 关于 ssh 其实 自己 看 了 挺 多 ， 但是 这 篇文章 里面 基本 没 怎么 写 ， 之后 可能 填 上 这个 坑 [ ]  是否 可以 github 和 gitlab 使用 同一 对 密钥 ， 那样 是不是 会 方便 些 ， 另外 需要 考虑 安全 问题 [ ]  如果 文章内容 出现 错误 或者 有 更 多 想要 了解 的 可以 在 下方 留言 ， 我会 改进 的 (end)","title":"ssh-git","oriTitle":"ssh-git"},{"uri":"/posts/unicode-utf8","tags":["encrypt"],"content":"ASCII, Unicode 和 UTF8 之间 的 关系 本文 主要 了解 一下 ASCII 码 、Unicode 码 和 UTF-8 码 的 来源 和 相互之间 的 关系 ,  顺便 也 理 了 一下 中文 编码 GB2312, GBK, GB18030 的 关系 。ASCII 码 在 上 世纪 60 年代 ， 美国 制定 了 ASCII 码 ， 主要 目的 是 为了 用 二进制 编码 的 方式 来 表达 英文 字符 ， 用 一个 8 位 的 字节 大小 对应 了 128 个字符 ， 其中 包括 了 可 打印 出来 的 96 个字符 和 32 个 不可 打印 的 控制字符 ,  规则 是 二进制 中 第 1 位 固定 为 0,  后面 7 位 用来 编码 ,  刚好 可以 表示 27 = 128 个字符 ,  例如 规定 空格 SPACE 的 编码 为 00100000,  十进制 是 32,  大写字母 A 的 编码 为 01000001,  十进制 是 65,  附上 ASCII 码表 GB2312, GBK, GB18030GB2312  是 对  ASCII  的 中文 扩展 ,  一个 小于 127 的 字符 的 意义 与 ASCII 码 相同 ,  但是 当 两个 大于 127 的 字符 连在一起 时 就 表示 汉字 ,  同时 GB2312 在 127 之外 的 地方 把 ASCII 已经 有 的 数字 ,  标点 和 字母 又 重新加入 了 一遍 ,  这些 重新加入 的 字符 占用 两个 字节 的 空间 ,  也就是说 在 GB2312 中 有 两套 数字 ,  字母 和 标点 ,  码 值 小于 127 的 那 一套 因为 是 ASCII 码 ,  只 占用 一个 字节 ,  就 叫 ' 半角 ' 符号 ,  而 新 加入 的 一套 数字 ,  字母 和 标点 就 叫 ' 全角 ' 符号 . 因为 GB2312 只 收录 了 6763 个 汉字 ,  很多 的 汉字 也 需要 加入 编码 中 ,  所以 微软 对 GB2312 进行 了 扩展 ,  规定 只要 第一个 字节 大于 127,  那么 就 不管 后面 一个 字节 是不是 大于 127 的 ,  通通 都 认为 这 两个 字节 一起 表示 了 一个 汉字 ,  这样 就 又 增加 了 近 20000 个 新 的 汉字 （ 包括 繁体字 ） 和 符号 ,  扩充 之后 就 成为 GBK 标准 ,  它 向下兼容 GB2312 编码 ， 出现 于 Windows 95 简体中文版 中 ,  但是 这个 是 微软 标准 ,  并 不是 国家标准 . 后来 又 加入 了 少数民族 文字 ， 于是 我们 再 扩展 ， 又 加 了 几千个 新 的 少数民族 的 字 ，GBK 扩 成 了 GB18030, GB18030 成为 了 国家标准 .Unicode 码 ASCII 码 虽然 满足 了 美国 的 需求 , 但是 对于 其它 语言 而言 128 个字符 是 远远不够 的 ,  比如 法语 中 字母 上方 有 注音 ,  这 是 ASCII 码 无法 表示 的 ,  又 比如 汉字 有 10 万左右 ,  这 也 是 超出 了 ASCII 码 的 范围 ,  所以 后来 Unicode 码 出现 了 .Unicode 码 有着 很大 的 容量 ,  现在 的 规模 可以 容纳 100 多万个 符号 ,  每个 符号 的 编码 都 不 一样 ,  比如 ，U+0639 表示 阿拉伯 字母 Ain，U+0041 表示 英语 的 大写字母 A，U+4E25 表示 汉字 严 。 你 可以 使用 在线 的 工具 来 转换成 Unicode 码 .Unicode 码 编码方式 Unicode 码 只是 定义 了 每个 字符 对应 的 二进制 代码 是 什么 ,  但是 并 没有 规定 字符 对应 的 二进制 应该 以 什么样 的 形式 存储 , Unicode 统一 规定 ， 每个 符号 用 三个 或 四个 字节 表示 .  比如 汉字 严 的 Unicode 码 是 十六进制 数 4E25,  转换成 二进制 就是 100111000100101 一共 是 15 位 ,  至少 占用 2 个 字节 的 空间 ,  而 其他 的 字符 可能 有 更 多 的 二进制位 数 ,  而 之前 的 ASCII 码 是 固定 为 8 位 的 ,  如果 采取 将 前面 多余 的 位数 全都 置 0 的话 ,  那么 在 存储 原来 的 ASCII 码 编码 的 文件 时 就 会 浪费 大量 的 空间 来 存储 无用 的 0 信息 ,  这 是 不可 接受 的 .  所以 如何 合理 的 用 Unicode 码 来 兼容 原先 的 ASCII 码 信息 就 产生 出 了 多种 具体 的 实现 方式 .UTF-8 实现 UnicodeUTF-8 是 目前 使用 最 多 的 Unicode 编码 实现 方式 ,  除此之外 也 有  UTF-16（ 字符 用 两个 字节 或 四个 字节 表示 ） 和  UTF-32（ 字符 用 四个 字节 表示 ） 实现 方式 ,  不过 基本 不 使用 .UTF-8  最大 的 一个 特点 ， 就是 它 是 一种 变 长 的 编码方式 。 它 可以 使用 1~4 个 字节 表示 一个 符号 ， 根据 不同 的 符号 而 变化 字节 长度 。 按照 如下 两条 规则 来 编码 字符 : 对于 单 (n = 1) 字节 的 符号 ， 字节 的 第一位 设 为 0， 后面 7 位 为 这个 符号 的  Unicode  码 。 因此 对于 英语 字母 ，UTF-8  编码 和  ASCII  码 是 相同 的 。 对于 多 (n > 1) 字节 的 符号 ， 第一个 字节 的 前 n 位 都 设 为 1， 第 n + 1 位 设 为 0， 后面 字节 的 前 两位 一律 设 为 10。 剩下 的 没有 提及 的 二进制位 ， 全部 为 这个 符号 的  Unicode  码 。 下 表 总结 了 编码 规则 ， 字母 x 表示 可用 编码 的 位 。Unicode 符号 范围      |        UTF-8 编码方式 ( 十六进制 )        |              （ 二进制 ）----------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 在 解码 的 时候 现 查看 二进制 的 第一位 ,  如果 是 0,  那么 说明 是 单字节 的 字符 ,  直接 将 该 字节 按照 Unicode 码表 转换成 对应 的 字符 即可 ,  如果 第一位 是 1,  那么 继续 查看 有 几个 连续 的 1,  有 n 个 ,  则 说明 连续 的 n 个 字节 代表 一个 字符 . 以 汉字 严 为 例 , \b 严 的 Unicode 码 是 4E25( 二进制 为 100111000100101),  根据 上表 , 4E25 处于 0000 0800 - 0000 FFFF 范围 ,  那么 严 的 编码 格式 就是 1110xxxx 10xxxxxx 10xxxxxx,  也就是说 严 的 UTF-8 编码方式 就 需要 占用 三个 字节 ,  我们 把 严 的 二进制 按照 顺序 填 到 x 的 位置 ,  最后 得到 的 结果 就是 11100100 10111000 10100101,  转 成 16 进制 就是 E4B8A5,  这 就是 严 的 UTF-8 编码 结果 . 总得来说 ,  严 的 Unicode 码 为 4E25, UTF-8 编码 为 E4B8A5,  这 就 好比 你 的 身份证 是 123456,  在 学校 站队 时 老师 按照 一定 的 排队 方式 把 你 编排 到 了 五组 三排 第二个 ,  这 两者 最后 的 结果 是 可以 相互 转换 的 ,  你 可 借助 在线 工具 验证 .JavaScript 中 的 Unicode 与 UTF-8javascript 程序 是 使用 Unicode 字符集 编写 的 ,  所以 我们 在 JavaScript 中 经常 使用 的 字符 或者 字符串 实际上 内部 是 采用 Unicode 编码 的 ,  在 有些 情况 下 ,  比如 我们 的 服务器 要求 接受 的 二进制 内容 的 编码 必须 是 UTF-8,  那么 我们 在 把 JavaScript 中 的 字符串 发送到 服务器 之前 就 需要 进行 转码 ,  将 Unicode 字符串 转为 UTF-8 字符串 .  我们 在 前端 有时候 会 看到 的 服务器返回 的 json 数据 中 乱码 实际上 就是 因为 服务器发送 数据 的 编码 跟 我们 客户端 接受 数据 的 编码方式 不 一致 导致 的 ,  你 可以 试 着 将 乱码 字 段 拷贝到 在线 工具 中 进行 转码 ,  比如 选择 将 Unicode 转为 UTF-8,  然后 你 就 能 看到 正确 的 信息 . 除了 数据 交互 之外 ,  浏览器 的 URI 也 是 我们 能够 了解 这种 编码 转换 的 地方 ,  因为 URI 中 的 querystring 必须 按照 UTF8 的 编码 进行 传输 ,  但是 JavaScript 中 是 Unicode 的 ,  如果 没有 中文信息 还好 ,  因为 英文 字符 在 这 两者之间 的 码 值 是 保持一致 的 , JavaScript 的 字符串 hello 到 了 URI 中 也 还是 hello,  如果 你 不 手动 去 转换 也 是 ok 的 ,  但是 一旦 涉及 到 中文 ( 包括 其它 非 英文 字符 ),  比如 汉字 严 ,  它 的 Unicode 码 值 和 UTF-8 码 值 就 差 的 很 远 ,  如果 你 不 进行 手动 转换 ,  直接 将 JavaScript 中 的 字符 严 丢 到 地址栏 的 URI 中 ,  那么 就 会 导致 URI 乱码 ,  你 再 想 从 URI 中 把 之前 放进去 的 严 取出 来 就 会 发现 得到 的 根本 不是 汉字 严 ,  而是 一串 乱码 . 在 JavaScript 中 如何 转换 Unicode 与 UTF-8 浏览器 提供 了 三 对 方法 来 进行 编码 转换 ,escape/unescape, encodeURI/decodeURI 和 encodeURIComponent/decodeURIComponent.   第一 对 escape/unescape 是非 标准 的 ,  已经 被 废弃 ,  这里 只 说 一下 它 的 转码 方式 , escape 在 处理 大于 127 的 字符 时 是 在 字符 的 Unicode 码 前面 直接 加上 一个 %u,  例如 严 的 Unicode 码 为 4E25,  那么 escape(' 严 ') 的 结果 就是 %u4E25,  再次 强调 ,  请 不要 使用 escape/unescape,  它 已 被 废弃 ;   第二 对 encodeURI/decodeURI 是 用来 给 整个 URL 进行 转码 的 ,  它 不会 转义 &, ?, /, = 这样 的 功能 字符 ;   第三 对 encodeURIComponent/decodeURIComponent 是 用来 给 URL 的 部分 字 段 进行 转码 的 ,  它 会 对 &, ?, /, = 这些 特殊字符 进行 转义 ,  一般 用来 处理 key-value 形式 的 query 字 段 .encodeURI 和 encodeURIComponent 都 是 先 将 非 英文 字符 的 Unicode 码 转为 UTF-8 码 ,  然后 在 每个 字节 前面 都 加上 一个 %,  比如 汉字 严 的 Unicode 码 是 4E25,  使用 encodeURI 编码 时会 先 转 成 UTF-8 码 E4 B8 A5,  在 用 % 连接起来 就 得到 最后 结果 %E4%B8%A5.// 编码 encodeURIComponent(' 严 '); // => '%E4%B8%A5'// 解码 decodeURIComponent('%E4%B8%A5'); // => ' 严 '//encodeURI 和 encodeURIComponent 对比 encodeURI('www.kricsleo.com?name=\" 张 三 \"'); // => \"www.kricsleo.com?name=%22%E5%BC%A0%E4%B8%89%22\"encodeURIComponent('www.kricsleo.com?name=\" 张 三 \"') // => \"www.kricsleo.com%3Fname%3D%22%E5%BC%A0%E4%B8%89%22\" 我们 也 可以 自己 用 js 来 使用 Unicode 和 UTF-8 之间 的 相互 转换 /**  将 字符串 格式化 为 UTF8 编码 的 字节  */const toUTF8 = function (str, isGetBytes) {      var back = [];      var byteSize = 0;      for (var i = 0; i > 6))));                back.push((128 | (63 & code)))          } else if ((0x800 > 12))));                back.push((128 | (63 & (code >> 6))));                back.push((128 | (63 & code)))          }       }       for (i = 0; i > 8, byteSize & 0xff].concat(back);        }}toUTF8(' 严 '); // =>  [0, 3, 228, 184, 165]/**  读取 UTF8 编码 的 字节 ， 并 转为 Unicode 的 字符串  */const fromUTF8 = function (arr) {    if (typeof arr === 'string') {        return arr;    }    var UTF = '', _arr = arr;    for (var i = 0; i  ' 严 ' 参考资料 : 阮 一峰 的 博客 : http://www.ruanyifeng.com/blog/2007/10/asciiunicodeand_utf-8.htmlsegmentfault 上 张 亚 涛 的 专栏 : https://segmentfault.com/a/1190000005794963","title":"ASCII-Unicode-UTF8","oriTitle":"ASCII-Unicode-UTF8"}]