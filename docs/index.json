[{"uri":"/posts/2014-multi-university-training-contest-4","tags":["只言片语"],"content":" 心情 就 像 倒数第 二楼 那样 。CLJ， 我 也 保证 不 打死 你 ……PS: 最后 一楼 朱 大神 还 暴露 了 。","title":"2014 Multi-University Training Contest 4","oriTitle":"2014 Multi-University Training Contest 4"},{"uri":"/posts/asp-net-mvc4-note1-simplemembership","tags":["asp.net mvc4","simplemembership"],"content":"`Cusing System.Web.Mvc;namespace MvcClassManageSystem.ActionFilters{    public class LogStateFilterAttribute : ActionFilterAttribute    {        public override void OnActionExecuting(ActionExecutingContext filterContext)        {            base.OnActionExecuting(filterContext);            //string controller = filterContext.RouteData.Values[\"controller\"].ToString();            //string action = filterContext.RouteData.Values[\"action\"].ToString();            //System.Diagnostics.Debug.WriteLine(\"OnAction:\" + controller + \"/\" + action);            if (WebMatrix.WebData.WebSecurity.IsAuthenticated == true)            {                filterContext.Result = new RedirectToRouteResult(new System.Web.Routing.RouteValueDictionary(new { Controller = \"Home\", action = \"Index\" }));            }        }    }}``Cpublic static class WebUtility    {        private static SimpleMembershipProvider membership = (SimpleMembershipProvider)Membership.Provider;        public static void CreateUserAndAccount(UserProfile userProfile, string Password)        {            WebSecurity.CreateUserAndAccount(userProfile.UserName, Password, new            {                //TO DO  数据库 / 模型 更改 之后 别忘记 修改 此处 ！！！                ClassId = userProfile.ClassId,                UserExtraInfo_Phone = userProfile.UserExtraInfo.Phone,                UserExtraInfo_Gender = userProfile.UserExtraInfo.Gender,                UserExtraInfo_BirthDay = userProfile.UserExtraInfo.BirthDay,                UserExtraInfo_UserDesc = userProfile.UserExtraInfo.UserDesc            });        }        public static void DeleteUserAndAccount(string UserName)        {            membership.DeleteAccount(UserName);            Roles.RemoveUserFromRoles(UserName, Roles.GetRolesForUser(UserName));            membership.DeleteUser(UserName, true);        }        public static void ResetPassword(string UserName, string NewPassword)        {            WebSecurity.ResetPassword(WebSecurity.GeneratePasswordResetToken(UserName, 1), NewPassword);        }    }``Cusing System.Web.Mvc;namespace MvcClassManageSystem.Filters{    public class MyAuthorizeAttribute : AuthorizeAttribute    {        protected override void HandleUnauthorizedRequest(AuthorizationContext filterContext)        {            base.HandleUnauthorizedRequest(filterContext);            if (filterContext.HttpContext.User.Identity.IsAuthenticated)            {                filterContext.Result = new RedirectResult(\"/Account/AccessError\");            }        }    }}``Cusing System.Data.Entity;using System.Linq;using System.Web.Security;using WebMatrix.WebData;namespace MvcClassManageSystem.Models{    public class InitSecurityDb : DropCreateDatabaseAlways    {        protected override void Seed(DBManager context)        {            WebSecurity.InitializeDatabaseConnection(\"DefaultConnection\", \"UserProfile\", \"UserId\", \"UserName\", autoCreateTables: true);            var roles = (SimpleRoleProvider)Roles.Provider;            string[] RolesList = new string[] { \"Admin\", \"Teacher\", \"Student\" };            foreach (var item in RolesList)            {                if (!roles.RoleExists(item))                {                    roles.CreateRole(item);                }            }            // 设置 初始 班级             int ClassIndex = 0;            using (var db = new DBManager())            {                var ret = db.ClassProfiles.SingleOrDefault(m => m.ClassName.CompareTo(\" 未知 班级 \") == 0);                if (ret == null)                {                    ret = db.ClassProfiles.Add(new ClassProfile                    {                        ClassName = \" 未知 班级 \",                        Desc = \" 班级 未知 或 无 意义 \"                    });                    db.SaveChanges();                }                ClassIndex = ret.ClassId;            }            if (!WebSecurity.UserExists(\" 管理员 \"))            {                WebUtility.CreateUserAndAccount(new UserProfile()                {                    UserName = \" 管理员 \",                    ClassId = ClassIndex,                    UserExtraInfo = new UserExtraInfo()                    {                        Phone = \"18267912632\",                        Gender = MvcClassManageSystem.Models.Gender. 男 ,                        BirthDay = new System.DateTime(1993, 9, 28),                        UserDesc = \" 本站 的 管理员 ！\"                    }                }, \"admin\");                System.Web.Security.Roles.AddUserToRole(\" 管理员 \", \"Admin\");            }        }    }}``C protected void Application_Start()        {            Database.SetInitializer(new InitSecurityDb());            DBManager db = new DBManager();            db.Database.Initialize(true);            if (!WebSecurity.Initialized)            {                WebSecurity.InitializeDatabaseConnection(\"DefaultConnection\", \"UserProfile\", \"UserId\", \"UserName\", autoCreateTables: true);            }            AreaRegistration.RegisterAllAreas();            WebApiConfig.Register(GlobalConfiguration.Configuration);            FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);            RouteConfig.RegisterRoutes(RouteTable.Routes);            BundleConfig.RegisterBundles(BundleTable.Bundles);            AuthConfig.RegisterAuth();        }`","title":"ASP.NET MVC4 笔记 （ 一 ）  扩展 Simplemembership","oriTitle":"ASP.NET MVC4笔记（一） 扩展Simplemembership"},{"uri":"/posts/asp-net-mvc4note2","tags":["asp.net mvc4"],"content":" 有 Timestamp 修饰 的 表 在 修改 已有 的 记录 是 一定 要 将 该 字 段 复制 ， 也就是说 一定 要 在 Edit 网页 里面 添加 一行 ：   @Html.HiddenFor(model => model.RowVersion)WebSecurity.CreateAccount 必须 在 Userprofile 里面 先 创建 账户 。   System.Diagnostics.Debug.WriteLine(\"OnAction:\" + controller + \"/\" + action); 转换 string 数组 到 int 数组    int[] HostsList = Array.ConvertAll(Request[\"HostsId\"].Split(','), u => int.Parse(u));","title":"ASP.NET MVC 4 笔记 （ 二 ）","oriTitle":"ASP.NET MVC 4笔记（二）"},{"uri":"/posts/basic-algorithms-in-go","tags":["algorithm","golang"],"content":" 最近 学 Go， 感觉 挺不错 的 。 闲来无事 用 它 写 了 几种 常用 的 基础 算法 。 快 排 思想 很 简单 ， 实现 起来 为了 方便 每次 以 left 作为 基准 ， 也 可以 使用 BFS 来 节省 递归 栈 ：// QuickSort returns a sorted slicefunc QuickSort(arr []int) {\tif len(arr)  arr[left] {\t\t\tarr[left+1], arr[right] = arr[right], arr[left+1]\t\t\tright--\t\t} else {\t\t\tarr[left+1], arr[left] = arr[left], arr[left+1]\t\t\tleft++\t\t}\t}\tQuickSort(arr[:left])\tQuickSort(arr[left+1:])} 最 短路 最 短路 核心思想 就是 Relax 操作 。 效率高 的 单 源 最 短路 有 下面 两种 算法 ：Dijikstra， 不能 处理 负 权 路 , 但是 时间 复杂度 比较稳定 .SPFA 是 我 比较 喜欢 的 一种 算法 ， 可以 判断 负 权 路 。 正常 情况 的 时间 复杂度 为 O(kE)   其中 `k dist[u]+e.w {\t\t\t\tdist[e.v] = dist[u] + e.w\t\t\t\tif !visit[e.v] {\t\t\t\t\tQ = append(Q, e.v)\t\t\t\t\tvisit[e.v] = true\t\t\t\t}\t\t\t}\t\t}\t\t// pop the front node\t\tQ = Q[1:]\t\tvisit[u] = false\t}\treturn dist[end]}KMP 字符串 匹配 经典 算法 。 关键在于 维护 一个 这样 的 关系 ：x[i-next[i]...i-1]=x[0...next[i]-1]type Kmp struct {\tpattern string\tnext    []int}// x[i-p...i-1]=x[0...p-1]func (K *Kmp) getNext() {\tK.next = make([]int, len(K.pattern)+1)\tK.next[0] = -1\ti := 0\tp := -1\tfor i = len(K.pattern) {\t\t\tret++\t\t\tp = K.next[p]\t\t}\t}\treturn ret}To Be Continue...","title":"Basic Algorithms in Go","oriTitle":"Basic Algorithms in Go"},{"uri":"/posts/centos11-3","tags":["centos"],"content":" 换 源 备份 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 写入 国内 源 (centos 7)ustc： https://lug.ustc.edu.cn/wiki/mirrors/help/centos163：CentOS-Base.repoThe mirror system uses the connecting IP address of the client and theupdate status of each mirror to pick mirrors that are updated to andgeographically close to the client.  You should use this for CentOS updatesunless you are manually picking other mirrors.If the mirrorlist= does not work for you, as a fall back you can try theremarked out baseurl= line instead.[base]name=CentOS-$releasever - Base - 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=osbaseurl=http://mirrors.163.com/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7#released updates[updates]name=CentOS-$releasever - Updates - 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=updatesbaseurl=http://mirrors.163.com/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extras - 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=extrasbaseurl=http://mirrors.163.com/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - 163.combaseurl=http://mirrors.163.com/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7 更新 yum clean allyum makecache 设置 代理 #! /bin/bashAuthor: Kevin TanUpdate-Date: 2017-1-14URL=$1ACTION=('\\nSet' '\\nDel')mode=1if [ -z $URL ]; then    echo '[Warning]: URL parameter is empty, default action change to remove'    mode=2fiset_proxy(){  file=$1;prefix=$2;value=\"$2=$3\";  echo \"Set \\\"$value\\\" to \\\"$file\\\"\"  if [ -e \"$file\" ]; then    if grep -q \"^\\s*$prefix\" \"$file\"; then        sed -i \"s#^\\s$prefix=.#$value#g\" $file    else        echo $value >> $file    fi  fi}del_proxy(){    file=$1;prefix=$2    echo \"Del \\\"$prefix\\\" from \\\"$file\\\"\"    if [ -e \"$file\" ]; then        sed -i \"/^\\s$prefix=./d\" $file    fi    eval $prefix=\"\"}SHELL_NAME=ps -p $$ | awk 'NR==2 {print $4}'echo 'Current shell is '$SHELL_NAMEsource_file(){bash    if [ \"$SHELL_NAME\" = \"bash\" ]; then        source $HOME'/.bashrc'    fizsh    if [ \"$SHELL_NAME\" = \"zsh\" ]; then        source $HOME'/.zshrc'    fi}yumecho -n ${ACTION[$mode]}' the yum? (y/n/r) ';read Fif [ $F = 'y' ] && [ $mode -eq 1 ]; then    set_proxy '/etc/yum.conf' 'proxy' $URLelif [ $F = 'r' ] || ([ $F = 'y' ] && [ $mode -eq 2 ]); then    del_proxy '/etc/yum.conf' 'proxy'fienvironmentecho -n ${ACTION[$mode]}' the environment var?(y/n/r) ';read Fshell_names=(zsh bash)if [ $F = 'y' ] && [ $mode -eq 1 ]; then    for name in ${shell_names[@]}; do        setproxy \"$HOME/.${name}rc\" \"export httpproxy\" $URL        setproxy \"$HOME/.${name}rc\" \"export httpsproxy\" $URL    done    source_fileelif [ $F = 'r' ] || ([ $F = 'y' ] && [ $mode -eq 2 ]); then    for name in ${shell_names[@]}; do        delproxy \"$HOME/.${name}rc\" \"export httpproxy\"        delproxy \"$HOME/.${name}rc\" \"export httpsproxy\"    donefi#curlecho -n ${ACTION[$mode]}' the curl proxy alias?(y/n/r) ';read Fshell_names=(zsh bash)if [ $F = 'y' ] && [ $mode -eq 1 ]; then    for name in ${shell_names[@]}; do    \tset_proxy \"$HOME/.${name}rc\" \"alias curl\" \"\\\"curl -x $URL\\\"\"    done    source_fileelif [ $F = 'r' ] || ([ $F = 'y' ] && [ $mode -eq 2 ]); then    for name in ${shell_names[@]}; do        del_proxy \"$HOME/.${name}rc\" \"alias curl\"        unalias curl    donefikubernetesecho -n ${ACTION[$mode]}' kube environment var?(y/n/r) ';read Fif [ $F = 'y' ] && [ $mode -eq 1 ]; then    for name in ${shell_names[@]}; do        setproxy \"$HOME/.${name}rc\" \"export KUBERNETESHTTP_PROXY\" $URL        setproxy \"$HOME/.${name}rc\" \"export KUBERNETESHTTPS_PROXY\" $URL        setproxy \"$HOME/.${name}rc\" \"export KUBEBUILDHTTPSPROXY\" $URL        setproxy \"$HOME/.${name}rc\" \"export KUBEBUILDHTTPPROXY\" $URL    done    source_fileelif [ $F = 'r' ] || ([ $F = 'y' ] && [ $mode -eq 2 ]); then    for name in ${shell_names[@]}; do        delproxy \"$HOME/.${name}rc\" \"export KUBERNETESHTTP_PROXY\"        delproxy \"$HOME/.${name}rc\" \"export KUBERNETESHTTPS_PROXY\"        delproxy \"$HOME/.${name}rc\" \"export KUBEBUILDHTTPSPROXY\"        delproxy \"$HOME/.${name}rc\" \"export KUBEBUILDHTTPPROXY\"    donefidockerecho -n ${ACTION[$mode]}' the docker?(y/n/r) ';read Fif type \"docker\" &>/dev/null && ([ $F = 'y' ] || [ $F = 'r' ]); then        DOCKERCONFDIR='/etc/systemd/system/docker.service.d'        DOCKERCONF=$DOCKERCONF_DIR'/http-proxy.conf'        REGISTRY=\"87129800.m.daodocker.io\"        sudo mkdir -p \"$DOCKERCONFDIR\"        sudo rm -rf $DOCKER_CONF        if [ $F = 'y' ] && [ $mode -eq 1 ]; then            printf \"[Service]\\nEnvironment=\" | sudo tee $DOCKER_CONF > /dev/null            printf \"\\\"HTTPPROXY=%s\\\" \" $URL | sudo tee -a $DOCKERCONF > /dev/null            printf \"\\\"HTTPSPROXY=%s\\\" \" $URL | sudo tee -a $DOCKERCONF > /dev/null            printf \"\\\"NOPROXY=localhost,%s\\\"\" $REGISTRY | sudo tee -a $DOCKERCONF > /dev/null        fi        sudo systemctl daemon-reload        sudo systemctl restart docker        echo \"Daemon reloaded\"        systemctl show --property=Environment dockerfi 将 上面 脚本 保持 为 setproxy， 然后 执行 , 注意 ， 如果 当前 环境 下 已经 有 了 http_proxy 等 变量 。 则 需要 我们 手动 resetchmod u+x setproxysource setproxy http://10.100.100.136:4411 基础 建设 git && gccyum install git gccpipcurl \"https://bootstrap.pypa.io/get-pip.py\" | pythonEPELrpm -ivh http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmZSH 安装  &  激活 yum install zshchsh -s /bin/zsh","title":"Centos 初始化 ","oriTitle":"Centos初始化"},{"uri":"/posts/centos21-4","tags":["centos","tmux","prezto"],"content":"proxychains-nggit clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng./configure --prefix=/usr --sysconfdir=/etcmakemake installmake install-config   #  生成 配置文件 echo 'http 10.100.100.136 4411' >> /etc/proxychains.conf  #  输入 代理 设置 TMUXCentOS 的 版本 太 老 ， 手动 编译 最新 版本 yum install ncurses-devel libevent-develcurl -L https://github.com/tmux/tmux/releases/download/2.3/tmux-2.3.tar.gz | tar xzcd tmux-2.3./configuremakemake install 如果 出现 protocol version mismatch 错误 ， 说明 现在 tmux 正在 运行 ， 手动 结束 掉 即可 。kill -9 pidof tmuxthemegit clone https://github.com/gpakosz/.tmux.gitln -s -f .tmux/.tmux.confcp .tmux/.tmux.conf.local .vim .tmux.conf.local # 编辑 配置文件 去掉 status left/right sections separators 后面 几行 的 注释 （ 终端 字体 需要 支持 Powerline） 启用  force vi modeshortcutsSession:new[-s name]  # new session:kill-session[-t name] # kill session:ls # list sessionsC-c # new sessions  # list and select sessions$  # name sessionWindowc  # create windoww  # list windowsn  # next windowp  # previous windowf  # find window,  # name window&  # kill windowPanes%  #vertical split\"  # horizontal splito  # swap panesq  # show pane numbersx  # kill pane 最大化 pane， 再 按 一次 还原 restore pane from window⍽  # space - toggle between layoutsq  # (Show pane numbers, when the numbers show up type the key to goto that pane){  # (Move the current pane left)}  # (Move the current pane right)z  # toggle pane zoom 方向键  # select the sibling paneC- 方向键  # resize current paneMiscd  # detacht  # big clock?  # list shortcuts:  # promptTmux Plugin Manager && tmux-yanktmux-yank 可以 将 tmux 的 paste-buffer 中 的 文字 拷贝到 系统 剪贴板 yumi xclip #  安装 依赖 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpmvim .tmux.conf #  在 最后 添加 下面 几行 ， 注意 不是  .tmux.conf.local!!!List of pluginsset -g @plugin 'tmux-plugins/tpm'set -g @plugin 'tmux-plugins/tmux-yank'Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)run '~/.tmux/plugins/tpm/tpm' 然后 ， 重新 加载 tmux， 按  + I  安装 tmux-yank 插件 然后 ， 并 不能 奏效 ， 因为 xclip 需要 有 X 服务 。 然而 ssh 客户端 Centos 只是 纯 命令行 。 需要 开启 X11ForwardingX11Forwarding 在 远程 Centos 中 的 /etc/ssh/ssh_config 文件 中 ， 添加 X11Forwarding yes 在 远程 Centos 中 安装 认证 软件 ：yumi xorg-x11-xauth 在 本地 ssh 连接 命令 添加 -Y 参数     启用 x11 转发 之后 就 可以 在 Centos 中 启动 x11 程序 了 ， 可以 安装 轻量级 的 xfce4-terminal 方便 操作 。Prezto  git clone --recursive https://github.com/sorin-ionescu/prezto.git \"${ZDOTDIR:-$HOME}/.zprezto\"rm -rf .zshrc .zpreztorc .zlogin .zlogout .zprofile .zshenv .zhistory .zcompdumpsetopt EXTENDED_GLOBfor rcfile in \"${ZDOTDIR:-$HOME}\"/.zprezto/runcoms/^README.md(.N); do  ln -s \"$rcfile\" \"${ZDOTDIR:-$HOME}/.${rcfile:t}\"done 主题 列表 prompt -l 预览 主题 prompt -p NAME 做 个 备份 mv .zpreztorc .zpreztorc.tmp 添加 常用 插件 ( 不要 第二次 运行 ， 而是 手动 修改 .zpreztorc 文件 )awk -v s=\"syntax-highlighting git command-not-found yum history-substring-search autosuggestions\" \\'BEGIN{n=split(s,m)}/'\\''utility'\\''\\s+\\\\/{for(i=1;i .zpreztorc 修改 默认 主题 （ 推荐  skwp）sed -i \"s/\\(zstyle.theme\\s\\)./\\1'skwp'/\" .zpreztorcYum Aliasesyumc removes package(s) and leaves.yumi installs package(s).yumh displays history.yuml lists packages.yumL lists installed packages.yumq displays package information.yumr removes package(s).yums searches for a package.yumu updates packages.yumU upgrades packages.spf13 Vimcurl https://j.mp/spf13-vim3 -L > spf13-vim.sh && sh spf13-vim.sh","title":"Centos 初始化 2","oriTitle":"Centos初始化2"},{"uri":"/posts/graphql-learn-1---queries-and-mutations","tags":["GraphQL"],"content":" 在 此 页面 上 ， 你 将 详细 了解 如何 查询 GrahQL 服务器 。 字 段 （Fields） 最 简单 的 ，GraphQL 是 关于 要求 对象 上 的 特定 字 段 。 我们 先 来看 一个 非常简单 的 查询 ， 当 我们 运行 它 时 得到 结果 ：{  hero {    name  }}{  \"data\": {    \"hero\": {      \"name\": \"R2-D2\"    }  }} 可以 看到 ， 查询 与 结果 的 形状 完全相同 。 这 对于 GraphQL 是 至关重要 的 ， 因为 您 总是 收到 您 期望 的 内容 ， 并且 服务器 确切 知道 客户端 要求 哪些 字 段 。 字段名 返回 一个 String 类型 ， 在 这种 情况 下 是 星球大战 主角 “R2-D2” 的 名称 。> 哦 ， 还有 一件 事 :  上面 的 查询 是 互动 的 。 这 意味着 您 可以 随意 更改 它 ， 并 看到 新 的 结果 。 尝试 在 查询 中 向 hero 对象 添加 一个 appearIn 字 段 ， 并 查看 新 结果 。 在 前面 的 例子 中 ， 我们 只是 要求 我们 返回 一个 String 类型 的 主角 名字 ， 但 字 段 也 可以 引用 对象 。 在 这种 情况 下 ， 您 可以 对 该 对象 的 字 段 进行 子 查询 。 GraphQL 查询 可以 遍历 相关 对象 及其 字 段 ， 让 客户端 在 一个 请求 中 获取 大量 相关 数据 ， 而 不是 像 传统 的 REST 架构 中 一样 需要 进行 几次 往返 。{  hero {    nameQueries can have comments!    friends {      name    }  }}{  \"data\": {    \"hero\": {      \"name\": \"R2-D2\",      \"friends\": [        {          \"name\": \"Luke Skywalker\"        },        {          \"name\": \"Han Solo\"        },        {          \"name\": \"Leia Organa\"        }      ]    }  }} 请 注意 ， 在 此 示例 中 ，friends 字 段 返回 一个 项目 数组 。 GraphQL 查询 对于 单个 项 或 多个 项 列表 写法 上 相同 ， 但是 我们 根据 schema 中 记录 的 内容 知道 预期 获得 的 是 哪 一种 。 参数 （Arguments） 如果 我们 唯一 可以 做 的 是 遍历 对象 及其 字 段 ， 则 GraphQL 已经 是 数据 提取 的 非常 有用 的 语言 。 但是 如果 你 还 能 将 参数传递 给 字 段 的话 ， 事情 会 变得 更 有趣 。{  human(id: \"1000\") {    name    height  }}{  \"data\": {    \"human\": {      \"name\": \"Luke Skywalker\",      \"height\": 1.72    }  }} 在 像 REST 这样 的 系统 中 ， 您 只能 传递 一组 参数 (paramter 和 url query)。 但是 在 GraphQL 中 ， 每个 字 段 和 嵌套 对象 都 可以 获取 自己 的 参数 集 ， 从而 使 一次 GraphQL 查询 可以 完全 代替 多个 传统 的 API 请求 。 您 甚至 可以 将 参数传递 到 标量 字 段 中 并 在 服务器 上 实现 数据 转换 ， 而 不 需要 在 客户端 上 进行 。{  human(id: \"1000\") {    name    height(unit: FOOT)  }}{  \"data\": {    \"human\": {      \"name\": \"Luke Skywalker\",      \"height\": 5.6430448    }  }} 参数 可以 是 很多 不同 的 类型 。 在 上面 的 例子 中 ， 我们 使用 了 一个 枚举 类型 ， 它 表示 一组 有限 的 选项 之一 （ 在 这种 情况 下 是 长度 单位 ，METER 或 FOOT）。 GraphQL 带有 默认 的 类型 ， 但是 GraphQL 服务器 也 可以 声明 自定义 类型 。 只要 能 将 它们 序列化 为 可 传输 的 格式 。 别名 （Aliases） 也许 您 已经 注意 到 ， 相对 应 的 结果 字段名 与 查询 字段名 相同 ， 但 却 不 包括 该 字 段 的 查询 参数 ， 因此 您 不能 直接 使用 不同 的 参数 查询 相同 的 字 段 。 这 就是 为什么 你 需要 别名 的 原因 。{  empireHero: hero(episode: EMPIRE) {    name  }  jediHero: hero(episode: JEDI) {    name  }}{  \"data\": {    \"empireHero\": {      \"name\": \"Luke Skywalker\"    },    \"jediHero\": {      \"name\": \"R2-D2\"    }  }} 片段 （Fragments） 假设 我们 的 应用 中 存在 一个 比较复杂 的 页面 ， 可以 一次性 展示 两个 角色 并列 出 他们 的 朋友 信息 。 可以 想象 ， 这样 一个 查询 可能 会 很快 变得复杂 ， 因为 我们 需要 重复 写 角色 字 段 至少 两次 。 这 就是 为什么 GraphQL 包含 “ 片段 ” 这种 可 重用 单元 。 片段 让 您 构建 一组 字 段 ， 然后 我们 可以 将 它们 包含 在 需要 的 查询 中 。 以下 是 使用 片段 解决 上述情况 的 示例 ：{  leftComparison: hero(episode: EMPIRE) {    ...comparisonFields  }  rightComparison: hero(episode: JEDI) {    ...comparisonFields  }}fragment comparisonFields on Character {  name  appearsIn  friends {    name  }}{  \"data\": {    \"leftComparison\": {      \"name\": \"Luke Skywalker\",      \"appearsIn\": [        \"NEWHOPE\",        \"EMPIRE\",        \"JEDI\"      ],      \"friends\": [        {          \"name\": \"Han Solo\"        },        {          \"name\": \"Leia Organa\"        },        {          \"name\": \"C-3PO\"        },        {          \"name\": \"R2-D2\"        }      ]    },    \"rightComparison\": {      \"name\": \"R2-D2\",      \"appearsIn\": [        \"NEWHOPE\",        \"EMPIRE\",        \"JEDI\"      ],      \"friends\": [        {          \"name\": \"Luke Skywalker\"        },        {          \"name\": \"Han Solo\"        },        {          \"name\": \"Leia Organa\"        }      ]    }  }} 如果 重复 这些 字 段 ， 您 可以 看到 上述 查询 将 如何 重复 。 片段 的 概念 经常 用于 将 复杂 的 应用程序 数据 需求 分解成 更 小 的 块 ， 特别 是 当 您 需要 将 大量 具有 不同 片段 的 UI 组件 合并 到 一个 初始 数据 请求 时 。 变量 （variables） 到 目前为止 ， 我们 一直 在 查询 字符串 中 写入 所有 的 参数 。  但 在 大多数 应用程序 中 ， 字 段 的 参数 将 是 动态 的 ： 例如 ， 可能 会 有 一个 下 拉 列表 ， 您 可以 选择 您 感兴趣 的 星球大战 插曲 ， 或 搜索 字 段 或 一组 过滤器 。 在 查询 字符串 中 直接 传递 这些 动态 参数 并 不是 一个 好 主意 ， 因为 我们 的 客户端 代码 需要 在 运行 时 动态 地 处理 查询 字符串 ， 并 将 其 序列化 为 特定 于 图形 的 格式 。  相反 ，GraphQL 具有 将 查询 中 的 动态 值 参数 化 的 一级 方法 (first-class way)， 并 将 其 作为 单独 的 字典 传递 。  这些 值 称为   变量  。 当 开始 使用 变量 之 时 ， 我们 需要 做 三件 事情 ： 用 $variableName 替换 查询 语句 中 静态 的 值 声明 $variableName 为 一个 被 查询 语句 接收 的 变量 之一 将 $variableName: value 写入 到 一种 传输 专用 的 变量 字典 中 ( 通常 是 JSON)， 用来 与 查询 语句 分别 传输 到 服务器 上 。 整合 后 的 结果 ：query    query HeroNameAndFriends($episode: Episode) {    hero(episode: $episode) {      name      friends {        name      }    }  }variables    {    \"episode\": \"JEDI\"  }result    {    \"data\": {      \"hero\": {        \"name\": \"R2-D2\",        \"friends\": [          {            \"name\": \"Luke Skywalker\"          },          {            \"name\": \"Han Solo\"          },          {            \"name\": \"Leia Organa\"          }        ]      }    }  } 现在 ， 在 我们 的 客户端 代码 中 ， 我们 可以 简单 地 传递 一个 不同 的 变量 ， 而 不 需要 构造 一个 全新 的 查询 。  这 通常 也 是 一个 好 的 做法 ， 表示 我们 的 查询 中 的 哪些 参数 预期 是 动态 的  -  我们 不 应该 使用 字符串 插值 来 从 用户 提供 的 值 构造 查询 。 变量 定义 变量 定义 是 上面 查询 中 的 （$episode：Episode） 部分 。  它 的 作用 就 像 类型 语言 中 函数 的 参数 定义 一样 。  它 列出 所有 变量 ， 前缀 为 $， 后 跟 其 类型 （ 当前 为 Episode）。 所有 声明 的 变量 必须 是 标量 ， 枚举 或 输入 对象 类型 。  因此 ， 如果 要 将 复杂 对象 传递 到 字 段 中 ， 则 需要 知道 在 服务器 上 匹配 的 输入 类型 。  在 “ 架构 ” 页面 上 了解 有关 输入 对象 类型 的 更 多 信息 。 变量 定义 可以 是 可 选 的 或 必需 的 。  在 上面 的 情况 下 ， 因为 没有 ！  在 Episode 类型 后面 ， 所以 它 是 可 选 的 。  但是 ， 如果 要 将 变量 传递 给 需要 非 空 参数 的 字 段 ， 那么 该 变量 也 必须 是 必需 的 。 要 了解 有关 这些 变量 定义 的 语法 的 更 多 信息 ， 学习 GraphQL 模式语言 非常 有用 。  模式语言 在 Schema 页面 中 有 详细 的 说明 。 默认 变量 可以 在 变量 的 类型 声明 后面 添加 该 变量 的 默认值 query HeroNameAndFriends($episode: Episode = \"JEDI\") {  hero(episode: $episode) {    name    friends {      name    }  }} 操作 名 （Operation  name） 从 上面 的 查询 例子 我们 可以 看到 一个 HeroNameAndFriends 的 操作 名 。 但 到 目前为止 ， 我们 大部分 是 在 速记 语法 ， 省略 查询 关键字 和 查询 名称 ， 但 在 生产 中 ， 这 钟 写法 会 使 我们 的 代码 不 明确 。 想想 这 就 像 你 最 喜欢 的 编程语言 中 的 函数 名 。  例如 ， 在 JavaScript 中 ， 我们 可以 轻松 地 使用 匿名 函数 ， 但是 当 我们 给 一个 函数 一个 名字 时 ， 跟踪 它 更 容易 ， 调试 我们 的 代码 ， 并 在 被 调用 时 记录 。  以 同样 的 方式 ，GraphQL 查询 和 变量 名称 以及 片段 名称 可以 作为 服务器端 的 一个 有用 的 调试 工具 来 识别 不同 的 GraphQL 请求 。 指令 （Directives） 我们 上面 讨论 了 变量 如何 使 我们 避免 进行 手动 字符串 插值 来 构造 动态 查询 。  在 参数 中 传递 变量 解决 了 这些 问题 的 一部分 ， 但是 我们 也 可能 需要 一种 使用 变量 来 动态 地 更改 查询 的 结构 和 形状 的 方法 。  例如 ， 我们 可以 想象 一个 UI 组件 ， 它 具有 一个 总结 和 详细 的 视图 ， 其中 一个 包含 比 另 一个 更 多 的 字 段 。 让 我们 来 为 这样 的 组件 构建 一个 查询 语句 ：query    query Hero($episode: Episode, $withFriends: Boolean!) {    hero(episode: $episode) {      name      friends @include(if: $withFriends) {        name      }    }  }variables    {    \"episode\": \"JEDI\",    \"withFriends\": false  }result    {    \"data\": {      \"hero\": {        \"name\": \"R2-D2\"      }    }  } 尝试 编辑 上面 的 变量 （ 比如 将 true 传给 withFriends）， 看看 结果 如何 变化 。 我们 需要 在 GraphQL 中 使用 一个 新 功能 ， 称为 一个 指令 。  一个 指令 可以 附加 到 字 段 或 片段 包含 ， 并且 可以 以 服务器 的 任何 方式 影响 查询 的 执行 。  核心 GraphQL 规范 仅 包含 两个 指令 ， 这些 指令 必须 由 任何 符合规范 的 GraphQL 服务器 实现 支持 ：@include(if: Boolean)  仅 当 参数 为 true 时 返回 结果 才 包括 这个 字 段 @skip(if: Boolean)  当 参数 为 true 时 跳 过 这个 字 段 指令 可 用于 摆脱 需要 执行 字符串 操作 以 在 查询 中 添加 和 删除 字 段 的 情况 。  服务器 实现 也 可以 通过 定义 全新 的 指令 来 添加 实验 功能 。 修改 （Mutations） 大多数 关于 GraphQL 的 讨论 集中 于 数据 获取 ， 但是 任何 完整 的 数据 平台 也 需要 一种 修改 服务器端 数据 的 方法 。 在 REST 中 ， 任何 请求 可能 会 导致 在 服务器 上 造成 一些 副作用 ， 但 按照 惯例 ， 建议 不要 使用 GET 请求 来 修改 数据 。 GraphQL 是 类似 的 ： 技术 上 任何 查询 都 可以 被 实现 来 进行 数据 写入 。  但是 ， 建立 一个 约定 ， 任何 导致 写入 的 操作 都 应该 通过 修改 操作 显 式 发送 。 就 像 查询 一样 ， 如果 修改 字 段 返回 一个 对象 类型 ， 可以 要求 嵌套 字 段 。  这 可以 在 更新 后 获取 对象 的 新 状态 。  我们 来看 一个 简单 的 例子 ：mutation    mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {    createReview(episode: $ep, review: $review) {      stars      commentary    }  }varialbes    {    \"ep\": \"JEDI\",    \"review\": {      \"stars\": 5,      \"commentary\": \"This is a great movie!\"    }  }result    {    \"data\": {      \"createReview\": {        \"stars\": 5,        \"commentary\": \"This is a great movie!\"      }    }  } 注意 createReview 字 段 是 如何 返回 新创建 的 review 中 的 commentary 和 stars 字 段 的 。  这 在 修改 已有 字 段 的 时候 尤其 有用 ， 例如 ， 当 增加 一个 字 段 时 ， 我们 可以 通过 一个 请求 来 同时 修改 该 字 段 并 查询 该 字 段 的 新 值 。 您 可能 还 会 注意 到 ， 在 本 示例 中 ， 我们 传入 的 评论 变量 不是 标量 。  它 是 一个 输入 对象 类型 ， 可以 作为 参数 传入 的 特殊 种类 的 对象 类型 。  详细 了解 “ 架构 ” 页面 上 的 输入 类型 。 修改 多个 字 段 像 查询 操作 一样 ， 一个 修改 操作 可以 包含 多个 字 段 ， 但是 两者之间 有 一个 重大 的 差异 ： 查询 操作 是 并行 的 ， 而 修改 操作 是 串行 的 这 意味着 ， 如果 我们 在 一个 修改 操作 中 两次 修改 incremenetCredits 字 段 的 操作 ， 第一个 操作 在 保证 结束 后 才 会 执行 第二个 操作 。 避免出现 竞争 情况 。 内联 片段 （inline Fragments） 跟 其他 类型 系统 一样 ，GraphQL 也 可以 定义 接口 （Interfaces） 和 联合 类型 （Union Types）。 详情 见 schema guide 你 可以 使用 内联 片段 来 访问 一个 接口 或者 联合 类型 中 所 包含 的 数据 。 用 下面 这个 例子 可以 很 方便 的 说明 ：query    query HeroForEpisode($ep: Episode!) {    hero(episode: $ep) {      name      ... on Droid {        primaryFunction      }      ... on Human {        height      }    }  }variables    {    \"ep\": \"JEDI\"  }result    {    \"data\": {      \"hero\": {        \"name\": \"R2-D2\",        \"primaryFunction\": \"Astromech\"      }    }  } 在 这个 查询 中 ，hero 字 段 返回 类型 为 Character， 它 可能 是 Human 或 Droid， 这 取决于 参数 episode。  在 直接 选择 中 ， 您 只能 访问 Character 接口 中 存在 的 字 段 ， 如 name。 要 访问 具体 类型 的 字 段 ， 您 需要 使用 特定 类型 （type condition） 的 内联 片段 。  第一个 片段 在 Droid 上 被 标记 为 ...， 所以 只有 当 从 hero 返回 的 Character 是 Droid 类型 时 ，primaryFunction 字 段 才 会 被 执行 。  类似 于 Human 类型 中 的 height 字 段 。 命名 片段 也 可以 以 相同 的 方式 使用 ， 因为 命名 片段 始终 包含 限定 类型 。 元 字 段 （Meta fields） 鉴于 有些 情况 下 您 不 知道 从 GraphQL 服务 返回 的 类型 ， 您 需要 一些 方法 来 确定 如何 处理 客户端 上 的 数据 。 GraphQL 允许 您 在 查询 中 的 任何 位置 请求 __typename， 一个 元 字 段 ， 以 获取 该 点 上 对象 类型 的 名称 。query    {    search(text: \"an\") {      __typename      ... on Human {        name      }      ... on Droid {        name      }      ... on Starship {        name      }    }  }result    {    \"data\": {      \"search\": [        {          \"__typename\": \"Human\",          \"name\": \"Han Solo\"        },        {          \"__typename\": \"Droid\",          \"name\": \"Leia Organa\"        },        {          \"__typename\": \"Starship\",          \"name\": \"TIE Advanced x1\"        }      ]    }  } 在 上述 查询 中 ，search 返回 可以 是 三个 选项 之一 的 联合 类型 。  在 没有 __typename 字 段 的 情况 下 ， 不 可能 将 客户端 的 不同 类型 告诉 客户端 。GraphQL 服务 提供 了 少量 的 元 字 段 ， 其余 的 公开   于 “ 内省 ” 系统 。","title":"GraphQL Learn (1) - Queries and Mutations","oriTitle":"GraphQL Learn (1) - Queries and Mutations"},{"uri":"/posts/graphql-learn-2---schemas-and-types","tags":["GraphQL"],"content":" 在 此 页面 上 ， 您 将 了解 有关 GraphQL 类型 系统 的 所有 知识 ， 以及 如何 描述 可 查询 哪些 数据 。  由于 GraphQL 可以 与 任何 后 端 框架 或 编程语言 一起 使用 ， 因此 我们 将 远离 实现 特定 的 详细信息 ， 仅 讨论 概念 。 类型 系统 （Type System） 如果 您 以前 看过 GraphQL 查询 ， 那么 你 应该 知道 GraphQL 查询语言 基本上 是 在 对象 上 选择 字 段 。  所以 在 以下 查询 中 ：{  hero {    name    appearsIn  }}{  \"data\": {    \"hero\": {      \"name\": \"R2-D2\",      \"appearsIn\": [        \"NEWHOPE\",        \"EMPIRE\",        \"JEDI\"      ]    }  }} 从 一个 特殊 的  \"root\" 对象 开始 在 它 里面 选择 一个 hero 字 段 在 hero 返回 的 对象 中 ， 我们 继续 选择  name  和  appearsIn  字 段 因为 GraphQL 查询 的 形状 与 结果 非常 相似 ， 所以 您 可以 预测 什么 是 查询 将 返回 ， 而 不必 关心 服务器 的 设置 。  但是 我们 还是 需要 对 我们 所 请求 的 数据 进行 详细 的 描述 ： 我们 可以 选择 哪些 字 段 ？ 他们 可能 返回 什么样 的 对象 ？ 这些 子 对象 里面 包含 哪些 字 段 ？ 这 就是 schema 所 需要 解决 的 问题 。 每个 GraphQL 服务 定义 一组 完全 描述 可以 在 该 服务 上 查询 的 可能 数据 的 类型 。  然后 ， 当 收到 查询 时 ， 它们 将 根据 该 架构 进行 验证 和 执行 。. 类型 语句 （Type language）GraphQL 服务 可以 用 任何 语言 编写 。 我们 不能 依赖 特定 的 编程语言 语法 （ 如 JavaScript）， 因此 我们 将 使用 “GraphQL schema  语言 ” ， 它 类似 于 查询语言 ， 并 允许 我们 以 语言 无关 的 方式 谈论 GraphQL 的 架构 。 对象 的 类型 和 字 段 （Object types and fields）GraphQL 的 最 基本 的 组件 是 对象 类型 ， 表示 你 可以 从 服务 中 获取 的 一种 对象 ， 以及 它 具有 哪些 字 段 。  在 GraphQL schema 语言 中 ， 我们 可以 这样 表示 ：type Character {  name: String!  appearsIn: [Episode]!} 可读性 已经 很 高 了 ， 但是 让 我们 再 过 一遍 ， 以便 于 让 我们 在 细节 上 拥有 共同 的 语言 ：Character 是 一个 对象 类型 ， 大多数 情况 下 ，schema 里面 的 type 都 是 一个 对象 name 和 appearsIn 是 Character 中 的 字 段 。 意味着 在 任何 查询 包含 Character  类 的 时候 name 和 appearsIn 是 仅 有 且 必须 出现 在 其中 的 字 段 String 是 内置 的 标量 类型 之一 ， 标量 是 GraphQL 中 的 最小 的 类型 ， 不能 再 做 子 选择 了 。  我们 会 稍后 再 看 标量 类型 。String! 代表 着 这个 字 段 是 不 为 空 的 ，GraphQL 服务 保证 在 这个 字 段 上 返回 一个 不 为 空 的 值 。[Episode]! 代表 着 一个 包含 Episode 对象 的 数列 ， 它 也 是 不 为 空 的 ， 因此 当 你 查询 appearsIn 字 段 时 ，GraphQL 永远 会 返回 一个 数组 ， 即使 是 一个 空 数组 。 现在 ， 您 知道 GraphQL 对象 类型 是 什么 样子 了 ， 并且 掌握 了 如何 读取 GraphQL 类型 语言 的 基础知识 。 参数 （Arguments）GraphQL 对象 类型 上 的 每个 字 段 都 可以 有 零个 或 多个 参数 ， 例如 下面 的 length 字 段 ：type Starship {  id: ID!  name: String!  length(unit: LengthUnit = METER): Float} 所有 参数 都 是 有 命名 的 。 与 JavaScript 和 Python 这样 的 语言 不同 ， 函数 采用 有序 参数 列表 ，GraphQL 中 的 所有 参数 都 是 通过 名称 进行 传递 。 上面 例子 中 ，length 字 段 有 一个 定义 的 参数 ，unit。 参数 可以 是 必需 的 或 可 选 的 。 当 参数 是 可 选 的 时候 ， 我们 可以 定义 一个 默认值  。 上面 例子 中 ， 如果 unit 参数 没有 被 传递 ， 默认 情况 下 它 将 被 设置 为 METER。Query 和 Mutation 类型 （The Query and Mutation types）schema 中 的 大多数 类型 将 只是 普通 对象 类型 ， 但 其中 有 两种 特殊 的 类型 ：schema {  query: Query  mutation: Mutation} 每个 GraphQL 服务 都 有 一个 query 类型 ， 但 可能 有 也 可能 没有 mutation 类型 。  这些 类型 与 常规 对象 类型 相同 ， 但 它们 是 特殊 的 ， 因为 它们 定义 了 每个 GraphQL 查询 的 入口 点 。  所以 如果 你 看到 一个 查询 ：query {  hero {    name  }  droid(id: \"2000\") {    name  }}{  \"data\": {    \"hero\": {      \"name\": \"R2-D2\"    },    \"droid\": {      \"name\": \"C-3PO\"    }  }} 这 意味着 GraphQL 服务 需要 一个 具有 hero 和 droid 字 段 的 query 类型 ：type Query {  hero(episode: Episode): Character  droid(id: ID!): Droid}Mutation 相同 ， 您 可以 定义 Mutation 类型 上 的 字 段 ， 这些 字 段 就是 你 能 变更 的 根 字 段 。 重要 的 是 要 记住 ， 除了 作为 模式 的 “ 入口 点 ” 的 特殊 状态 之外 ，“ 查询 和 变更 ” 类型 与 任何 其他 GraphQL 对象 类型 相同 ， 它们 的 字 段 的 工作 方式 完全相同 。 标量 类型 （Scalar types）GraphQL 对象 类型 具有 名称 和 字 段 ， 但 在 某些 时候 ， 这些 字 段 必须 解析 为 某些 具体 数据 。  这 就是 标量 类型 的 来历 ： 它们 代表 查询 最低 端的 叶子 节点 。 下面 查询 中 ，name 和 appearsIn 将 会 被 解析 为 标量 类型 （ 因为 这 两个 字 段 没有 任何 子 字 段 ， 他们 是 本次 查询 的 叶子 节点 ）：{  hero {    name    appearsIn  }}{  \"data\": {    \"hero\": {      \"name\": \"R2-D2\",      \"appearsIn\": [        \"NEWHOPE\",        \"EMPIRE\",        \"JEDI\"      ]    }  }}GraphQL 默认 自带 了 一些 变量 类型 ：Int:  带符号 32 位 的 整数 .Float:  带符号 的 双 精度 浮点数 .String: UTF-8 的 字符串 .Boolean: true  或 false.ID: ID 标量 类型 表示 一个 唯一 的 标识 ， 通常 用于 重新 获取 对象 或 作为 缓存 中 的 键 。 ID 类型 其实 就是 String 类型 ;  然而 将 其 定义 为 ID 表示 它 是 没有 可读性 的 。 在 大多数 GraphQL 服务 实现 中 ， 还有 一种 方法 来自 定义 标量 类型 。  例如 ， 我们 可以 定义 一个 日期 类型 ：scalar Date 然后 由 我们 的 自己 来 实现 该 自定义 类型 如何 序列化 ， 反 序列化 和 验证 。  例如 ， 您 可以 指定 Date 类型 应 始终 序列化 为 整数 时间 戳 ， 并且 让 你 的 客户端 也 知道 该 格式 。 枚举 类型 （Enumeration types） 也 称为 枚举 （ Enums ）， 枚举 类型 是 一种 特殊 类型 的 标量 ， 仅限于 一组 特定 的 允许值 。  这样 你 可以 ： 验证 此 类型 的 任何 参数 是 允许 的 值 之一 通过 类型 系统 沟通 一个 字 段 永远 是 一组 有限 的 值 以下 是 GraphQL Schema 语言 中 的 枚举 定义 ：enum Episode {  NEWHOPE  EMPIRE  JEDI} 这 意味着 无论 何时 我们 在 Schema 中 使用 Episode 类型 时 ， 其 对应 的 值 永远都是 NEWHOPE, EMPIRE,  JEDI 中间 的 一个 。 请 注意 ， 各种 语言 的 GraphQL 服务 实现 将 以 自己 的 语言 特定 方式 来 处理 枚举 。  以 支持 枚举 作 “ 为 一流 公民 ” 的 语言 ， 某些 实现 可能 会 利用 这 一点 ;  在 没有 枚举 支持 的 JavaScript 语言 中 ， 这些 值 可能 在 内部 映射 到 一组 整数 。  但是 ， 这些 细节 不会 泄露 给 客户端 ， 客户端 可以 完全 按照 枚举 值 的 字符串 名称 进行 操作 。 列表 和 非 空 类型 （Lists and Non-Null） 对象 类型 ， 标量 和 枚举 是 GraphQL 中 唯一 可以 定义 的 类型 。  但是 当 您 在 Schema 的 其他 部分 或 查询 变量 声明 中 使用 这些 类型 时 ， 可以 使用 类型 修饰符 来 影响 这些 值 的 验证 规则 。  我们 来看 一个 例子 ：type Character {  name: String!  appearsIn: [Episode]!} 在 这里 ， 我们 使用 一个 String 类型 ， 并 通过 在 它 之后 添加 一个 感叹号 将 其 标记 为 一个 非 空 类型 。  这 意味着 我们 的 服务器 总是 期望 为此 字 段 返回 一个 非 空值 ， 如果 最终 得到 一个 空值 ， 实际上 会 触发 一个 GraphQL 执行 错误 ， 让 客户端 知道 出现 了 一些 问题 。 在 定义 字 段 的 参数 时 ， 也 可以 使用 非 空 类型 修饰符 ， 如果 将 null 值 作为 该 参数传递 ， 则 GraphQL 服务器 将 返回 验证 错误 ， 无论是 在 GraphQL 字符串 还是 变量 中 。query DroidById($id: ID!) {  droid(id: $id) {    name  }}{  \"id\": null}{  \"errors\": [    {      \"message\": \"Variable \\\"$id\\\" of required type \\\"ID!\\\" was not provided.\",      \"locations\": [        {          \"line\": 1,          \"column\": 17        }      ]    }  ]} 列表 以 类似 的 方式 工作 ： 我们 可以 使用 类型 修饰符 将 类型 标记 为 List， 这 表示 该 字 段 将 返回 该 类型 的 数组 。  在 模式语言 中 ， 通过 将 类型 包装 在 方括号 [ 和 ] 中 来 表示 。  它 与 参数 的 表现 相同 但 验证 步骤 将 期望 该 值 的 数组 。 非 空 修饰符 和 列表 修饰符 可以 一起 使用 ， 例如 ， 你 可以 要求 一个 由 非 空 字符串 组成 的 列表 ：myField: [String!] 这 意味着 列表 本身 可以 为 空 ， 但 它 不能 有 任何 空 的 成员 。 例如 ， 在 返回 的 JSON 中 ：myField: null // validmyField: [] // validmyField: ['a', 'b'] // validmyField: ['a', null, 'b'] // error 现在 ， 让 我们 定义 一个 由 字符串 组成 的 非 空 数组 ：myField: [String]! 这 意味着 列表 本身 不能 为 空 ， 但 它 可以 包含 空值 ：myField: null // errormyField: [] // validmyField: ['a', 'b'] // validmyField: ['a', null, 'b'] // valid 您 可以 根据 需要 随意 嵌套 任意 数量 的 非 空 和 列表 修饰符 。 接口 （Interfaces） 像 许多 类型 的 系统 一样 ，GraphQL 支持 接口 。  接口 是 一种 抽象 类型 ， 它 包含 一组 类型 必须 包含 已 实现 该 接口 的 字 段 。 例如 ， 你 可以 有 一个 Character 接口 表示 星球大战 三部曲 中 的 任何 角色 ：interface Character {  id: ID!  name: String!  friends: [Character]  appearsIn: [Episode]!} 这 意味着 ， 任何 实现 了 Character 接口 的 类型 ， 都 必须 拥有 这些 字 段 ， 包括 他们 的 参数 和 返回 类型 。 例如 ， 下面 列举 了 一些 实现 Character 接口 的 类型 ：type Human implements Character {  id: ID!  name: String!  friends: [Character]  appearsIn: [Episode]!  starships: [Starship]  totalCredits: Int}type Droid implements Character {  id: ID!  name: String!  friends: [Character]  appearsIn: [Episode]!  primaryFunction: String} 您 可以 看到 ， 这 两种 类型 都 具有 Character 接口 中 的 所有 字 段 ， 还 可以 引入 特定 类型 字符 的 额外 字 段 ，totalCredits，starships 和 primaryFunction。 当 您 要 返回 一个 对象 或 一组 对象 时 ， 接口 很 有用 ， 但 这些 对象 可能 有 几种 不同 的 类型 。 请 注意 以下 查询 会 产生 错误 ：{ \"graphiql\": true, \"variables\": { \"ep\": \"JEDI\" } }query HeroForEpisode($ep: Episode!) {  hero(episode: $ep) {    name    primaryFunction  }}{  \"ep\": \"JEDI\"}{  \"errors\": [    {      \"message\": \"Cannot query field \\\"primaryFunction\\\" on type \\\"Character\\\". Did you mean to use an inline fragment on \\\"Droid\\\"?\",      \"locations\": [        {          \"line\": 4,          \"column\": 5        }      ]    }  ]}hero 字 段 返回 字符 类型 ， 这 意味着 它 可能 是 Human 或 Droid， 取决于 episode 参数 。  在 上面 的 查询 中 ， 您 只能 询问 Character 接口 中 存在 的 字 段 ， 不 包括 primaryFunction。 为了 得到 在 一个 特定 对象 类型 中 的 字 段 ， 你 需要 使用 内联 片段 (inline fragment)query HeroForEpisode($ep: Episode!) {  hero(episode: $ep) {    name    ... on Droid {      primaryFunction    }  }}{  \"ep\": \"JEDI\"}{  \"data\": {    \"hero\": {      \"name\": \"R2-D2\",      \"primaryFunction\": \"Astromech\"    }  }} 联合 类型 （Union types） 联合 类型 与 接口 非常 相似 ， 但 它们 不能 指定 类型 之间 的 任何 公共 字 段 。union SearchResult = Human | Droid | Starship 当 Schema 返回 了 一个 SearchResult 类型 ， 我们 实际上 可能 会 得到 一个 Human， 一个 Droid 或者 一个 Starship。  注意 ， 联合 类型 的 成员 需要 是 具体 的 对象 类型 ;  您 不能 在 接口 或 其他 联合 类型 之上 再 创造 一个 联合 类型 。（ 扁平 结构 ） 在 这种 情况 下 ， 如果 查询 返回 的 是 SearchResult 这样 的 联合 类型 字 段 ， 则 需要 使用 条件 片段 才能 查询 其中 的 任意子 字 段 ：{  search(text: \"an\") {    ... on Human {      name      height    }    ... on Droid {      name      primaryFunction    }    ... on Starship {      name      length    }  }}{  \"data\": {    \"search\": [      {        \"name\": \"Han Solo\",        \"height\": 1.8      },      {        \"name\": \"Leia Organa\",        \"height\": 1.5      },      {        \"name\": \"TIE Advanced x1\",        \"length\": 9.2      }    ]  }} 输入 类型 （Input types） 到 目前为止 ， 我们 只 谈到 将 标量 值 （ 如 枚举 或 字符串 ） 作为 参数传递 到 一个 字 段 中 。  但 您 也 可以 轻松 地 传递 复杂 的 对象 。  这 在 变更 （Mutation） 的 情况 下 特别 有 价值 ， 在 这种 情况 下 ， 您 可能 想要 传入 要 创建 的 整个 对象 。  在 GraphQL Schema 语言 中 ， 输入 类型 与 常规 对象 类型 完全相同 ， 但 使用 关键字 input 而 不是 type：input ReviewInput {  stars: Int!  commentary: String} 下面 是 如何 在 变更 语句 中 使用 输入 类型 对象 的 例子 ：mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {  createReview(episode: $ep, review: $review) {    stars    commentary  }}{  \"ep\": \"JEDI\",  \"review\": {    \"stars\": 5,    \"commentary\": \"This is a great movie!\"  }}{  \"data\": {    \"createReview\": {      \"stars\": 5,      \"commentary\": \"This is a great movie!\"    }  }} 输入 类型 对象 上 的 字 段 本身 可以 引用 其他 输入 类型 对象 ， 但是 您 不能 在 Schema 中 混合输入 和 输出 类型 。  输入 类型 对象 也 不能 在 其 字 段 上 有 参数 。","title":"GraphQL Learn (2) - Schemas and Types","oriTitle":"GraphQL Learn (2) - Schemas and Types"},{"uri":"/posts/graphql-learn-3---validation","tags":["GraphQL"],"content":" 通过 使用 类型 系统 ， 可以 预先确定 GraphQL 查询 是否 有效 。  这样 可以 让 服务器 和 客户端 有效 地 通知 开发人员 在 创建 无效 查询 时 ， 无需 在 运行 时 检查 。 对于 我们 的 星球大战 示例 ， 文件 starWarsValidation-test.js 包含 许多 无效 的 查询 ， 可以 用来 测试 当前 实现 的 验证 器 。 首先 ， 我们 来看 一个 复杂 的 有效 查询 。  这 是 一个 嵌套 查询 ， 类似 于 上 一节 的 一个 示例 ， 但 将 重复 的 字 段 分解成 一个 片段 ：{  hero {    ...NameAndAppearances    friends {      ...NameAndAppearances      friends {        ...NameAndAppearances      }    }  }}fragment NameAndAppearances on Character {  name  appearsIn}{  \"data\": {    \"hero\": {      \"name\": \"R2-D2\",      \"appearsIn\": [        \"NEWHOPE\",        \"EMPIRE\",        \"JEDI\"      ],      \"friends\": [        {          \"name\": \"Luke Skywalker\",          \"appearsIn\": [            \"NEWHOPE\",            \"EMPIRE\",            \"JEDI\"          ],          \"friends\": [            {              \"name\": \"Han Solo\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            },            {              \"name\": \"Leia Organa\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            },            {              \"name\": \"C-3PO\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            },            {              \"name\": \"R2-D2\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            }          ]        },        {          \"name\": \"Han Solo\",          \"appearsIn\": [            \"NEWHOPE\",            \"EMPIRE\",            \"JEDI\"          ],          \"friends\": [            {              \"name\": \"Luke Skywalker\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            },            {              \"name\": \"Leia Organa\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            },            {              \"name\": \"R2-D2\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            }          ]        },        {          \"name\": \"Leia Organa\",          \"appearsIn\": [            \"NEWHOPE\",            \"EMPIRE\",            \"JEDI\"          ],          \"friends\": [            {              \"name\": \"Luke Skywalker\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            },            {              \"name\": \"Han Solo\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            },            {              \"name\": \"C-3PO\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            },            {              \"name\": \"R2-D2\",              \"appearsIn\": [                \"NEWHOPE\",                \"EMPIRE\",                \"JEDI\"              ]            }          ]        }      ]    }  }} 这个 查询 是 合法 的 ， 让 我们 看 一些 非法 的 查询 ： 片段 不能引用 自身 或 创建 一个 循环 ， 因为 这 可能 导致 无限 循环 ！  以上 是 上述 相同 的 查询 ， 但 没有 弄 明白 的 三层 的 嵌套 关系 。{  hero {    ...NameAndAppearancesAndFriends  }}fragment NameAndAppearancesAndFriends on Character {  name  appearsIn  friends {    ...NameAndAppearancesAndFriends  }}{  \"errors\": [    {      \"message\": \"Cannot spread fragment \\\"NameAndAppearancesAndFriends\\\" within itself.\",      \"locations\": [        {          \"line\": 11,          \"column\": 5        }      ]    }  ]} 当 我们 查询 字 段 时 ， 我们 必须 查询 给定 类型 上 存在 的 字 段 。  所以 当 hereo 返回 一个 Character 时 ， 我们 必须 在 一个 Character 字 段 上 查询 ， 然而 该 类型 没有 favoriteSpaceship 字 段 ， 因此 此 查询 无效 ：INVALID: favoriteSpaceship does not exist on Character{  hero {    favoriteSpaceship  }}{  \"errors\": [    {      \"message\": \"Cannot query field \\\"favoriteSpaceship\\\" on type \\\"Character\\\".\",      \"locations\": [        {          \"line\": 4,          \"column\": 5        }      ]    }  ]} 每当 我们 查询 一个 字 段 并 返回 除 标量 或 枚举 之外 的 东西 时 ， 我们 需要 指定 我们 想 从 字 段 中 获取 的 数据 。 hero 返回 一个 Character， 而 我们 一直 在 请求 其中 的 字 段 ， 如 name 和 appearIn;  如果 我们 忽略 ， 查询 将 不 合法 ：INVALID: hero is not a scalar, so fields are needed{  hero}{  \"errors\": [    {      \"message\": \"Cannot query field \\\"favoriteSpaceship\\\" on type \\\"Character\\\".\",      \"locations\": [        {          \"line\": 4,          \"column\": 5        }      ]    }  ]} 类似 地 ， 如果 一个 字 段 是 一个 标量 ， 查询 其中 的 其他 字 段 就 没有 意义 ， 这样 做 会 使 查询 不 合法 ：INVALID: name is a scalar, so fields are not permitted{  hero {    name {      firstCharacterOfName    }  }}{  \"errors\": [    {      \"message\": \"Field \\\"name\\\" must not have a selection since type \\\"String!\\\" has no subfields.\",      \"locations\": [        {          \"line\": 4,          \"column\": 10        }      ]    }  ]} 之前 ， 有人 指出 ， 查询 只能 查询 有关 类型 的 字 段 ;  当 我们 查询 返回 一个 Character 的 hero 时 ， 我们 只能 查询 Character 上 存在 的 字 段 。  如果 要 直接 查询 R2-D2s 的 主要 功能 ， 会 发生 什么 ？INVALID: primaryFunction does not exist on Character{  hero {    name    primaryFunction  }}{  \"errors\": [    {      \"message\": \"Cannot query field \\\"primaryFunction\\\" on type \\\"Character\\\". Did you mean to use an inline fragment on \\\"Droid\\\"?\",      \"locations\": [        {          \"line\": 5,          \"column\": 5        }      ]    }  ]} 该 查询 无效 ， 因为 primaryFunction 不是 Character 上 字 段 。  我们 想要 一些 判断 ， 如果 Character 是 Droid， 则 获取 primaryFunction， 否则 忽略 该 字 段 。  我们 可以 使用 前面 介绍 的 片段 （Fragment） 来 做到 这 一点 。  通过 设置 一个 在 Droid 上 定义 的 片段 并 包含 它 ， 我们 确保 我们 只 查询 已 定义 的 primaryFunction。{  hero {    name    ...DroidFields  }}fragment DroidFields on Droid {  primaryFunction}{  \"data\": {    \"hero\": {      \"name\": \"R2-D2\",      \"primaryFunction\": \"Astromech\"    }  }} 这个 查询 是 合法 的 ， 但 它 有点 冗长 ;  当 我们 需要 多次 使用 它 时 ， 命名 片段 是 有 价值 的 ， 但是 如果 我们 只 使用 一次 ， 我们 可以 直接 使用 内联 片段 。{  hero {    name    ... on Droid {      primaryFunction    }  }}{  \"data\": {    \"hero\": {      \"name\": \"R2-D2\",      \"primaryFunction\": \"Astromech\"    }  }} 以上 只是 验证 系统 的 表面 一层 ， 事实上 存在 这 很多 验证 规则 来 确保 GraphQL 查询 具有 良好 的 语义 和 意义 。 规范 中 的 \"Validation\" 章节 有 更 详细 的 介绍 。validation  中 包含 了 GraphQL 符合规范 的 代码 实现 。","title":"GraphQL Learn (3) - Validation","oriTitle":"GraphQL Learn (3) - Validation"},{"uri":"/posts/graphql-learn-4---execution","tags":["GraphQL"],"content":" 经过 验证 ，GraphQL 查询 由 GraphQL 服务器 执行 ， 然后 返回 一个 与 查询 形状 相同 的 结果 ， 通常 为 JSON。GraphQL 无法 执行 没有 类型 系统 的 查询 ， 让 我们 使用 类型 系统 例子 来 说明 执行 查询 ， 这个 例子 是 我们 教程 中 使用 的 类型 系统 中 的 一部分 ：type Query {  human(id: ID!): Human}type Human {  name: String  appearsIn: [Episode]  starships: [Starship]}enum Episode {  NEWHOPE  EMPIRE  JEDI}type Starship {  name: String} 为了 解释 执行 查询 语句 时 系统 发生 了 什么 ， 我们 用 下面 的 例子 了 跑 一遍 ：{ \"graphiql\": true }{  human(id: 1002) {    name    appearsIn    starships {      name    }  }}{  \"data\": {    \"human\": {      \"name\": \"Han Solo\",      \"appearsIn\": [        \"NEWHOPE\",        \"EMPIRE\",        \"JEDI\"      ],      \"starships\": [        {          \"name\": \"Millenium Falcon\"        },        {          \"name\": \"Imperial shuttle\"        }      ]    }  }} 您 可以 将 GraphQL 查询 中 的 每个 字 段 视为 返回 下 一个 类型 的 类型 函数 或 方法 。  事实上 ， 这 正是 GraphQL 的 工作 原理 。  每个 类型 的 每个 字 段 由 GraphQL 服务器 开发人员 提供 的 称为 解析器  resolver  的 函数 支持 。  当 一个 字 段 被 执行 时 ， 相应 的 解析器 被 调用 以 产生 下 一个 值 。 如果 一个 字 段 产生 一个 标量 值 ， 如 字符串 或 数字 ， 则 执行 完成 。  但是 ， 如果 一个 字 段 产生 一个 对象 值 ， 则 该 查询 将 应用 于 他 的 子 字 段 。  这样 一直 迭代 到 标量 值 。 GraphQL 查询 始终 以 标量 值 结束 。 根 字 段 和 解析器 （Root fields & resolvers） 每个 GraphQL 服务器 的 最 顶层 是 一个 特殊 的 类型 ， 表示 GraphQL API 中 所有 可能 入口 点 ， 通常 称为 根 类型 （Root type） 或 查询 类型 (Query type)。 在 这个 例子 中 ， 我们 的 查询 类型 提供 了 一个 接受 参数 id  的 human 字 段 。 此 字 段 的 解析 函数 可能 通过 访问 数据库 来 构造 并 返回 一个 Human 对象 。Query: {  human(obj, args, context) {    return context.db.loadHumanByID(args.id).then(      userData => new Human(userData)    )  }} 该 示例 使用 JavaScript 编写 ， 但是 GraphQL 服务器 可以 使用 许多 不同 的 语言 构建 。  解析器 函数 接收 三个 参数 ：obj  前 一个 对象 ， 对于 查询 类型 （Query type） 中 的 字 段 来说 不 常用 。args GraphQL 提供 的 参数 。context  提供 给 每个 解析器 并 保存 重要 的 上下文 信息 （ 如 当前 登录 的 用户 、 访问 数据库 ） 的 值 。 异步 解析器 （Asynchronous resolvers） 我们 来 仔细 看看 这个 解析器 函数 发生 了 什么 ：human(obj, args, context) {  return context.db.loadHumanByID(args.id).then(    userData => new Human(userData)  )}context 用于 提供 对 数据库 的 访问 ， 通过 GraphQL 查询 提供 的 参数 id 来 向 数据库 查询 数据 。  由于 数据库 查询 是 异步 操作 ， 所以 返回 一个 Promise。  在 JavaScript 中 ，Promises 用于 处理 异步 值 ， 但是 在 许多 语言 中 都 存在 相同 的 概念 ， 通常 称为  Futures ， Tasks  或  Deferred 。  当 数据库 返回 时 ， 我们 可以 构造 并 返回 一个 新 的  Human  对象 。 另外 ， 虽然 解析器 函数 需要 留意 Promises 的 使用 ， 但是 GraphQL 查询 不会 。  在 执行 期间 ，GraphQL 将 等待 Promises/Futures 和 Tasks 完成 ， 然后 继续 ， 并 以 最佳 并发 方式 执行 此 操作 。 微型 解析器 （Trivial resolvers） 至此 ， 我们 已经 得到 了 Human 对象 ，GraphQL 将 在 这个 对象 内 所 要求 的 字 段 中 继续执行 。Human: {  name(obj, args, context) {    return obj.name  }}GraphQL 服务 由 类型 系统 组成 ， 它 能够 帮助 服务 确定 下 一步 做 什么 的 。  即使 在 human 字 段 返回 之前 ，GraphQL 知道 下 一步 将 是 解决 Human 中 的 字 段 ， 因为 类型 系统 告诉 human 字 段 将 返回 一个 Human。 上面 代码 中 的 名称 解析 是 很 直接 的 。  调用 名称 解析 函数 ， 然后 obj 参数 来自 于 上 一个 字 段 返回 的 新 的 Human 对象 。  我们 期望 Human 对象 有 一个 name 属性 ， 我们 可以 直接 读取 并 返回 。 实际上 ， 许多 GraphQL 库 可以 让 你 省略 这个 简单 的 解决方案 ， 一个 约定 ： 假如 一个 字 段 没有 提供 解析 函数 ， 那么 应该 读取 和 返回 同名 的 属性 。 标量 强 转 （Scalar coercion） 当 name 字 段 正在 解析 时 ，appearsIn 和 starships 字 段 也 可以 同时 进行 解析 。 appearsIn 字 段 也 可以 有 一个 微型 解析器 ， 但是 让 我们 进一步 了解 一下 ：Human: {  appearsIn(obj) {    return obj.appearsIn // returns [ 4, 5, 6 ]  }} 请 注意 ， 我们 的 类型 系统 声明 appearsIn 将 返回 一直 枚举 值 中 的 一个 ， 但 此 函数 却 返回 数字 ！ 实际上 ， 如果 我们 查看 结果 ， 我们 将 看到 正在 返回 适当 的 枚举 值 。  这 是 怎么回事 ？ 这 是 标量 强 转 的 一个 例子 。  类型 系统 知道 期望 的 类型 并 将 解析器 函数 返回 的 值 转换 为 API 约定 中 的 内容 。  在 例子 中 ， 我们 的 服务器 上 可能 会 定义 一个 Enum， 它 在 内部 使用 数字 比如 4,5 和 6， 但 在 GraphQL 类型 系统 中将 它们 表示 为 枚举 值 。 列表 解析器 （List resolvers） 之前 我们 已经 看到 了 appearsIn 字 段 返回 列表 的 情况 ， 因为 这 是 系统 期望 的 类型 ， 列表 中 的 每个 项 将 被 被 强 转为 对应 的 枚举 类型 。  当 starships 解析 时会 发生 什么 ？Human: {  starships(obj, args, context) {    return obj.starshipIDs.map(      id => context.db.loadStarshipByID(id).then(        shipData => new Starship(shipData)      )    )  }} 该 字 段 的 解析器 不是 单单 返回 一个 Promise， 它 返回 了 一个 Promises 列表 。 Human 对象 有 他们 驾驶 的 Starships 的 id 列表 ， 但是 我们 需要 通过 所有 这些 id 来 获得 真正 的 Starship 对象 。GraphQL 将 在 继续 之前 同时 等待 所有 这些 Promises， 并且 当 剩下 一个 对象 列表 时 ， 它 将 同时 继续 加载 每个 这些 项目 上 的 name 字 段 。 产出 结果 （Producing the result） 当 每个 字 段 被 解析 时 ， 结果 值 被 放置 到 键值 映射 中 ， 字段名 称 （ 或 别名 ） 作为 键 ， 解析 出来 的 值 作为 值 ， 这 这 过程 从 查询 底部 叶子 节点 的 字 段 往 上 直到 原始 字 段 的 根 查询 类型 。  总而言之 ， 它们 产生 一个 镜像 的 原始 查询 结构 ， 然后 可以 将 其 发送 （ 通常 为 JSON） 到 请求 的 客户端 。 我们 来 看看 最初 的 查询 ， 看看 这些 解析 函数 如何 产生 一个 结果 ：{ \"graphiql\": true }{  human(id: 1002) {    name    appearsIn    starships {      name    }  }}{  \"data\": {    \"human\": {      \"name\": \"Han Solo\",      \"appearsIn\": [        \"NEWHOPE\",        \"EMPIRE\",        \"JEDI\"      ],      \"starships\": [        {          \"name\": \"Millenium Falcon\"        },        {          \"name\": \"Imperial shuttle\"        }      ]    }  }}","title":"GraphQL Learn (4) - Execution","oriTitle":"GraphQL Learn (4) - Execution"},{"uri":"/posts/graphql-learn-5---introspection","tags":["GraphQL"],"content":" 查询 GraphQL 架构 有关 它 支持 的 查询 的 信息 通常 很 有用 。 GraphQL 允许 我们 使用 内省 系统 来 做到 这 一点 ！ 对于 我们 的 星球大战 例子 来说 ， 文件 starWarsIntrospection-test.js 包含 许多 查询 内省 系统 的 查询 ， 并且 是 一个 完整 的 按照 规范 实现 的 测试 文件 。 我们 设计 了 类型 系统 ， 所以 我们 应该 知道 系统 中 可用 的 类型 。 但是 如果 不 知道 ， 我们 还 可以 通过 查询 __schema 字 段 来 询问 GraphQL。 这个 字 段 始终 存在 于 根 类型 中 。{ \"graphiql\": true }{  __schema {    types {      name    }  }}{  \"data\": {    \"__schema\": {      \"types\": [        {          \"name\": \"Query\"        },        {          \"name\": \"Episode\"        },        {          \"name\": \"Character\"        },        {          \"name\": \"ID\"        },        {          \"name\": \"String\"        },        {          \"name\": \"Int\"        },        {          \"name\": \"FriendsConnection\"        },        {          \"name\": \"FriendsEdge\"        },        {          \"name\": \"PageInfo\"        },        {          \"name\": \"Boolean\"        },        {          \"name\": \"Review\"        },        {          \"name\": \"SearchResult\"        },        {          \"name\": \"Human\"        },        {          \"name\": \"LengthUnit\"        },        {          \"name\": \"Float\"        },        {          \"name\": \"Starship\"        },        {          \"name\": \"Droid\"        },        {          \"name\": \"Mutation\"        },        {          \"name\": \"ReviewInput\"        },        {          \"name\": \"__Schema\"        },        {          \"name\": \"__Type\"        },        {          \"name\": \"__TypeKind\"        },        {          \"name\": \"__Field\"        },        {          \"name\": \"__InputValue\"        },        {          \"name\": \"__EnumValue\"        },        {          \"name\": \"__Directive\"        },        {          \"name\": \"__DirectiveLocation\"        }      ]    }  }} 哇 哦 ， 这 上面 输出 了 很多 类型 ， 他们 代表 什么 ？ 让 我们 对 他们 进行 一下 分类 ： Query, Character, Human, Episode, Droid -  这些 都 是 我们 在 类型 系统 中 定义 的 类型  String, Boolean -  这些 是 类型 系统 中 内 建 的 标量 类型  * \\\\Schema, \\\\Type, \\\\TypeKind, \\\\Field, \\\\InputValue, \\EnumValue, \\\\Directive  *  这些 名字 都 用 双 下划线 做 前缀 ， 用来 表示 是 内省 系统 里 的 类型 。 现在 ， 让 我们 开始 探索 系统 可用 的 查询 。 首先 ， 当 设计 我们 的 类型 系统 时 ， 我们 指定 了 一个 起始 查询 的 类型 ， 让 内省 系统 告诉 我们 起始 查询 的 名字 ：{ \"graphiql\": true }{  __schema {    queryType {      name    }  }}{  \"data\": {    \"__schema\": {      \"queryType\": {        \"name\": \"Query\"      }    }  }} 返回 的 结果 与 类型 系统 部分 中 所 描述 的 匹配 ，Query 类型 是 我们 将要 开始 的 地方 ！  请 注意 ， 这里 的 命名 只是 为了 方便 ， 我们 可以 将 Query 类型 命名 为 其他 任何 东西 ， 如果 我们 指定 它 是 查询 的 起始 类型 ， 系统 仍然 会 返回 相应 的 结果 。 虽然 将 它 命名 为 Query  是 一个 比较 实用 的 约定 。 让 我们 来 看看 Droid 类型 ：{ \"graphiql\": true }{  __type(name: \"Droid\") {    name  }}{  \"data\": {    \"__type\": {      \"name\": \"Droid\"    }  }} 如果 我们 需要 知道 更 多 的 关于 Droid 的 信息 ， 比如说 其中 的 一个 接口 或 对象 呢 ？{ \"graphiql\": true }{  __type(name: \"Droid\") {    name    kind  }}{  \"data\": {    \"__type\": {      \"name\": \"Droid\",      \"kind\": \"OBJECT\"    }  }}kind 返回 一个 __TypeKind 的 枚举 类型 ， 值 为 OBJECT1， 如果 我们 直接 查询 Character 而 不 在 接口 里面 的话 呢 ？{ \"graphiql\": true }{  __type(name: \"Character\") {    name    kind  }}{  \"data\": {    \"__type\": {      \"name\": \"Character\",      \"kind\": \"INTERFACE\"    }  }} 知道 一个 对象 所 包含 的 所有 字 段 是 很 常见 的 需求 。 所以 ， 让 我们 继续 查询 Droid 上面 的 内省 系统 ：{ \"graphiql\": true }{  __type(name: \"Droid\") {    name    fields {      name      type {        name        kind      }    }  }}{  \"data\": {    \"__type\": {      \"name\": \"Droid\",      \"fields\": [        {          \"name\": \"id\",          \"type\": {            \"name\": null,            \"kind\": \"NON_NULL\"          }        },        {          \"name\": \"name\",          \"type\": {            \"name\": null,            \"kind\": \"NON_NULL\"          }        },        {          \"name\": \"friends\",          \"type\": {            \"name\": null,            \"kind\": \"LIST\"          }        },        {          \"name\": \"friendsConnection\",          \"type\": {            \"name\": null,            \"kind\": \"NON_NULL\"          }        },        {          \"name\": \"appearsIn\",          \"type\": {            \"name\": null,            \"kind\": \"NON_NULL\"          }        },        {          \"name\": \"primaryFunction\",          \"type\": {            \"name\": \"String\",            \"kind\": \"SCALAR\"          }        }      ]    }  }} 这些 就是 我们 在 Droid 上面 定义 的 字 段 ！id 看起来 有点 奇怪 ， 它 没有 类型 的 名称 。  因为 它 是 一种 “ 封装 ” 的 NON_NULL 类型 。  如果 我们 查询 该 字 段 类型 的 ofType 信息 ， 我们 将 会 得到 一个 ID 类型 ， 告诉 我们 这 是 一个 非 空 ID。 相似 的 ，friends 和 appearsIn 也 没有 类型 名 ， 因为 他们 是 一个 LIST 封装 过 的 类型 。 我们 可以 查询 他们 的 ofType 信息 ， 我们 将 会 得到 一个 LIST 类型 。{ \"graphiql\": true }{  __type(name: \"Droid\") {    name    fields {      name      type {        name        kind        ofType {          name          kind        }      }    }  }}{  \"data\": {    \"__type\": {      \"name\": \"Droid\",      \"fields\": [        {          \"name\": \"id\",          \"type\": {            \"name\": null,            \"kind\": \"NON_NULL\",            \"ofType\": {              \"name\": \"ID\",              \"kind\": \"SCALAR\"            }          }        },        {          \"name\": \"name\",          \"type\": {            \"name\": null,            \"kind\": \"NON_NULL\",            \"ofType\": {              \"name\": \"String\",              \"kind\": \"SCALAR\"            }          }        },        {          \"name\": \"friends\",          \"type\": {            \"name\": null,            \"kind\": \"LIST\",            \"ofType\": {              \"name\": \"Character\",              \"kind\": \"INTERFACE\"            }          }        },        {          \"name\": \"friendsConnection\",          \"type\": {            \"name\": null,            \"kind\": \"NON_NULL\",            \"ofType\": {              \"name\": \"FriendsConnection\",              \"kind\": \"OBJECT\"            }          }        },        {          \"name\": \"appearsIn\",          \"type\": {            \"name\": null,            \"kind\": \"NON_NULL\",            \"ofType\": {              \"name\": null,              \"kind\": \"LIST\"            }          }        },        {          \"name\": \"primaryFunction\",          \"type\": {            \"name\": \"String\",            \"kind\": \"SCALAR\",            \"ofType\": null          }        }      ]    }  }} 让 我们 在 这个 非常适合 作为 一个 工具 的 内省 系统 特性 上 结束 本 教程 。 让 用户 向 系统 本身 查询 文档 ！{ \"graphiql\": true }{  __type(name: \"Droid\") {    name    description  }}{  \"data\": {    \"__type\": {      \"name\": \"Droid\",      \"description\": \"An autonomous mechanical character in the Star Wars universe\"    }  }} 我们 可以 使用 内省 系统 访问 有关 类型 系统 的 文档 ， 并 创造 一种 文档 浏览器 或 富 IDE 的 体验 。 这些 只是 内省 系统 的 冰山一角 ， 我们 还 可以 查询 枚举 值 、 一个 类型 实现 的 接口 等等 。  我们 甚至 可以 内省 我们 的 内省 系统 本身 。  该 规范 在 “Introspection” 部分 中 有 关于 该 主题 的 更 多 细节 ，GraphQL.js 中 的  introspection 文件 包含 规范 的 代码 实现 。","title":"GraphQL Learn (5) - Introspection","oriTitle":"GraphQL Learn (5) - Introspection"},{"uri":"/posts/kubernetes--deepin-settings1-12","tags":["deepin","ppa","octotree","infinality fonts"],"content":"Infinality and Harfbuzz 会 发生冲突 ， 这 是 今天 Archlinux 无法 启动 输入法 界面 的 元凶 。 重新安装 freetype2\\fontconfig\\cairo 以 替换 infinality-bundle。 添加 PPA 出现 GPG 问题 问题 ：gpg: keybox '/tmp/tmpyiw6jvck/pubring.gpg' createdgpg: /tmp/tmpyiw6jvck/trustdb.gpg： 建立 了 信任度 数据库 gpg:  密钥  531EE72F4C9D234C： 公 钥 “Launchpad webupd8” 已 导入 gpg:  合计 被 处理 的 数量 ：1gpg:            已 导入 ：1gpg:  找 不到 有效 的  OpenPGP  数据 。 可能 原因 ：keyserver.ubuntu.com 使用 非标准 的 11371 端口 ， 而 一般 公司 的 防火墙 都 屏蔽掉 了 该 端口 ， 而 允许 标准 的 80 端口 。 解决 方法 ：sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 531EE72F4C9D234C 或者 sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E985B27BTelnet 需要 安装 server 的 ubuntusudo apt install telnetdsudo systemctl start inetdsudo systemctl enable inetdarchsudo systemctl start telnet.socketsudo systemctl enable telnet.socket 使用 telnet 测试 端口 是否 打开 ：telnet localhost 33171Github Online File Tree View PluginOctotree","title":"Deepin 初始化 ","oriTitle":"Deepin初始化"},{"uri":"/posts/kubernetes%E9%83%A8%E7%BD%B21-5","tags":["meow","docker","kubernetes"],"content":"MEOW 安装 curl -L git.io/meowproxy | bash 建议 安装 目录  /usr/bin/ 复制 自己 的 配置文件 in local computerxclip -sel clipboard  ~/.meow/rc 运行 MEOWHostname 执行 下面 脚本 。 不要 执行 多次   如果 出错 则 手动 修改 sed -i s/localhost\\.localdomain/NAME/g /etc/hosts /etc/hostnamehostname=\"10-10-103-144.node\"rm -rf /etc/hostnameecho $hostname > /etc/hostnamesed -i \"s/\\slocalhost\\s/ localhost $hostname /g\" /etc/hostssysctl kernel.hostname=$hostnameScreenfetchcurl -L https://raw.githubusercontent.com/KittyKatt/screenFetch/master/screenfetch-dev -o /usr/bin/screenfetchAWK 简述 awk -v var1=xxx BEGIN{[something]} [ifstatments or regex]{something match the condition}{[always run]}END{[something]} 支持 if else,for,i++ 支持 数组 （ 支持 for in 遍历 ， 但是 顺序 会 打乱 ） 最好 的 批量 初始化 的 方式 ：arr[\"\"]=0 #  批量 设 为 0str=\"a b c\"; split(str,arr[,\" \"]);# [\"a\",\"b\",\"c\"] 加 Kubernetes 源 cat  /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://yum.kubernetes.io/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0EOF 安装 Kubernetesyum install docker kubelet kubeadm kubectl kubernetes-cni 启动 进程 & 关闭 防火墙 systemctl start dockersystemctl start kubeletsystemctl enable dockersystemctl enable kubeletsystemctl stop firewalldsystemctl disable firewalldTear Down( 当 kubeadm init 失败 时 执行 )kubeadm reset && systemctl start kubeletPull Docker Images 此 方式 十分 艰难 。 后面 可以 通过 代理 直接 安装 。 见 Tech Log@1-12#! /bin/bashdeclare -a images=(    'dnsmasq-metrics-amd64:1.0'    'etcd-amd64:3.0.14-kubeadm'    'exechealthz-amd64:v1.2.0'    'kube-apiserver-amd64:v1.5.1'    'kube-controller-manager-amd64:v1.5.1'    'kube-discovery-amd64:1.0'    'kube-dnsmasq-amd64:1.4'    'kube-proxy-amd64:v1.5.1'    'kube-scheduler-amd64:v1.5.1'    'kubedns-amd64:1.9'    'kubernetes-dashboard-amd64:v1.5.0'    'pause-amd64:3.0''weave-kube:1.8.1''weave-npc:1.8.1')for imageName in ${images[@]}; do    docker pull stkevintan/$imageName    docker tag stkevintan/$imageName gcr.io/google_containers/$imageName    docker rmi stkevintan/$imageNamedonexclip -o -sel clipboard > pull_dockerchmod +x pull_docker./pull_docker 初始化 （Master） 首先 需要 使用 @17-1-3 的 脚本 设置 代理 。Del environmentSet curlSet kube envSet docker 在 /etc/default/docker 的 DOCKER_OPTS 中 加入 :--insecure-registry gcr.ioroot@10-10-103-144 ~ $ kubeadm init[kubeadm] WARNING: kubeadm is in alpha, please do not use it for production clusters.[preflight] Running pre-flight checks[init] Using Kubernetes version: v1.5.2[tokens] Generated token: \"c30875.954dc1dda4d0184b\"[certificates] Generated Certificate Authority key and certificate.[certificates] Generated API Server key and certificate[certificates] Generated Service Account signing keys[certificates] Created keys and certificates in \"/etc/kubernetes/pki\"[kubeconfig] Wrote KubeConfig file to disk: \"/etc/kubernetes/kubelet.conf\"[kubeconfig] Wrote KubeConfig file to disk: \"/etc/kubernetes/admin.conf\"[apiclient] Created API client, waiting for the control plane to become ready[apiclient] All control plane components are healthy after 16.391731 seconds[apiclient] Waiting for at least one node to register and become ready[apiclient] First node is ready after 0.509209 seconds[apiclient] Creating a test deployment[apiclient] Test deployment succeeded[token-discovery] Created the kube-discovery deployment, waiting for it to become ready[token-discovery] kube-discovery is ready after 3.505676 seconds[addons] Created essential addon: kube-proxy[addons] Created essential addon: kube-dnsYour Kubernetes master has initialized successfully!You should now deploy a pod network to the cluster.Run \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at:    http://kubernetes.io/docs/admin/addons/You can now join any number of machines by running the following on each node:kubeadm join --token=c30875.954dc1dda4d0184b 10.10.103.144 初始化 （Node） 需要 在 子 节点 上 安装 kubelet kubectl kubernetes-cni kubeadm 需要 使用 @17-1-3 的 脚本 设置 代理 。Del environmentSet curlSet kube envSet docker 在 /etc/default/docker 的 DOCKER_OPTS 中 加入 :--insecure-registry gcr.iosystemctl enable kubeletsystemctl start kubeletkubeadm join --token=ace10c.73fcdec44f7a4045 10.10.103.146 可以 在 master 节点 上 看到 该 子 节点 ：root@master ~ $ kubectl get nodeNAME      STATUS         AGEmaster    Ready,master   5dnode1     Ready          1mWeave Networkdownload config filecurl -L https://git.io/weave-kube -o weave-kube.yamlpull docker imagedocker pull stkevintan/weave-kube:1.8.1docker tag stkevintan/weave-kube:1.8.1 weaveworks/weave-kube:1.8.1docker rmi stkevintan/weave-kube:1.8.1createkubectl create -f weave-kube.yaml 或者 kubectl create -f https://git.io/weave-kube 可以 看到 结果 ：root@master ~ $ kubectl get pod --namespace=kube-systemNAME                              READY     STATUS              RESTARTS   AGEdummy-2088944543-bv5gj            1/1       Running             0          5detcd-master                       1/1       Running             0          5dkube-apiserver-master             1/1       Running             27         5dkube-controller-manager-master    1/1       Running             0          5dkube-discovery-1769846148-xbm2h   1/1       Running             0          5dkube-dns-2924299975-phn03         0/4       ContainerCreating   0          5dkube-proxy-081gt                  1/1       Running             0          5dkube-proxy-qc40l                  1/1       Running             0          1hkube-scheduler-master             1/1       Running             1          5dweave-net-4wvkm                   0/2       ContainerCreating   0          30sweave-net-l7dh0                   0/2       ContainerCreating   0          30sDashboard curl -L https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml -o kubernetes-dashboard.yaml sed -i 's/v1.5.1/v1.5.0/g' kubernetes-dashboard.yaml #  注意 此时 gcr 上面 并 没有 v1.5.1 sed -i 's/Alaways/IfNotPresent/g' kubernetes-dashboard.yaml kubectl create -f kubernetes-dashboard.yaml kubectl create -f https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yamlDelete Podkubectl delete -f xxx.yaml","title":"Kubernetes 部署 ","oriTitle":"Kubernetes部署"},{"uri":"/posts/pandorabox-transparent-proxy","tags":["路由器","科学上网","Shadowsocks","ChinaDNS"],"content":" 先 修改 Lan 接口 ， 避免 在 无线 中继 的 时候 发生 本地 Lan 接口 与 wwan 接口 发生冲突 导致 无法 登陆 路由器 。 网络  -> Lan -> IPv4 地址 ，  设置 为  192.168.33.1 更改 之后 需要 重新 连接 一下 网络 。 透明 代理 使用 shadowsocks-libev 和 ChinDNS 实现 。 使用 ssh 登陆 路由器 ， 安装 所 需 软件 。ssh root@192.168.33.1opkg updateopkg install shadowsocks-libev luci-app-shadowsocks ChinaDNS luci-app-chinadns --force-checksum 这个 版本 的 软件 源 有点 问题 ， 所以 直接 opkg install 基本上 都 过 不了 sha256sum 检测 ， 所以 需要 加上 --force-checksum 参数 强制 忽略 。 两个 luci 界面 都 有 zh-cn 汉化包 ， 为了 节省 路由器 空间 ， 就 不 装 了 。 默认 的 chnroute 表 很 老 了 ， 需要 更新 ：mv /etc/chnroute.txt /etc/chnroute.txt.bakwget -O- 'http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest' | awk -F\\| '/CN\\|ipv4/ { printf(\"%s/%d\\n\", $4, 32-log($5)/log(2)) }' > /etc/chnroute.txt 如果 没有 问题 rm -rf /etc/chnroute.txt.bak 然后 我们 需要 对 其 进行 启用 。shadowsocks 需要 启动 ss-redir 来 实现 透明 代理 和 ss-tunnel 来 实现 UDP 转发 保证 国外 DNS 查询 不 被 污染 。 下面 是 具体 需要 注意 的 配置 。SS-tunnel{  \"UDP Local Port\": 1153,  \"Forwarding Tunnel\": 8.8.8.8:53}ChinaDNS{  \"Enable DNS compression pointer\": true,  \"Local Port\": 1053, // 不能 与 ss-tunnel 冲突   \"CHNRoute File\": \"/etc/chnroute.txt\",  \"Upstream Servers\": \"223.5.5.5,127.0.0.1:1153\" // 第一个 是 国内 阿里 DNS 服务器 ， 第二个 是 进 过 ss-tunnel 转发 后 的 Google DNS 服务器 }DHCP/DNS 最后 需要 在 网络 ->DHCP/DNS-> 服务器 设置 修改 默认 的 DNS 配置 {  \" 本地 服务器 \": \"127.0.0.1#1053\", //ChinaDNS 处理 后 的 DNS 服务器 ， 可以 根据 ip 分流 。  \" 忽略 解析 文件 \": true} 总的来说 ，GoogleDNS(8.8.8.8:53) 首先 进 过 ss-tunnel 转发 到 本地 的 127.0.0.1:1153 上 ， 然后 通过 ChinaDNS 与 国内 DNS 服务器 融合 成 新 的 127.0.0.1:1053  实现 了 国内外 分流 。Update 由于 实用 过程 中 还是 经常 不 稳定 ， 决定 采用 DNS-Forwarder 方案 。 然而 ， 官方 并 没有 我 的 小米 Mini 路由 架构 的 二进制 包 ， 只能 自己 动手 丰衣足食 了 。OpenWrt SDK 首先 明确 小米 路由器 Mini 的 架构 是 ramips/mt7620a 而 现在 运行 的 Pandorabox 16.10 基于 Openwrt Barrier Breaker。 依赖 sudo apt-get install git-core build-essential libssl-dev libncurses5-dev unzip gawk zlib1g-dev subversion mercurial 下载 & 编译 curl https://downloads.openwrt.org/barrierbreaker/14.07/ramips/mt7620a/OpenWrt-SDK-ramips-for-linux-x8664-gcc-4.8-linaro_uClibc-0.9.33.2.tar.bz2 | tar -xjfcd OpenWrt-SDK-*git clone https://github.com/aa65535/openwrt-dns-forwarder.git package/dns-forwarder #  获取 Makefilemake menuconfig #  选择 要 编译 的 包 ： Network -> dns-forwardermake package/dns-forwarder/compile V=99 然而 ， 愿 景 很 好 ， 但是 在 我 的 Deepin 上 make menuconfig 这 步 就 出错 ， 想想 barrier_breaker 也 是 很 久 之前 的 版本 了 ， 出错 大概 是 ldxxxx， 感觉 应该 是 GCC 版本 不 兼容 的 缘故 ， 然而 Deepin 上 GCC 只有 6.2.0 没有 官方 要求 的 4.8， 怎么办 呢 ？ 当时 暂时 想到 下面 几条 解决方案 在 自己 电脑 上 重新 编译 一份 GCC4.8：  太 麻烦 ， 而且 还 不能 保证 一定 能 成功 。 用 虚拟机 装 老 版本 的 Ubuntu：  太 浪费时间 了 ， 本身 电脑 BIOS 就 没有 开启 虚拟化 支持 。docker?  不错 可以 试一下 。docker 运行 老 版本 ubuntu 镜像 不用 太 简单 ， 一条 命令 搞定 ： sudo docker run -t -i ubuntu:12.04.5 /bin/bash 然而 docker 版本 的 ubuntu 太 过于 精简 了 , 需要 配置 一下 ： 安装 缺失 依赖 apt-get install ccache curlopenwrt-sdk  编译 不能 以 root 用户 进行 ， 需要 新建 一个 普通用户 useradd kevinsu kevin 继续 之前 的 编译 步骤 好 了 ， 终于 编译 成功 了 ， 然而 还是 高兴 的 太 早 ， 仍然 报错 ：pkghashfetchbestinstallation_candidate: Packages for helloworld found, but incompatible with the architectures configured 还是 求助于 Google， 然后 发现 了 这 篇 博客 ： 小米 路由器 mini 折腾 之 配置 opkg 篇 ， 于是 我 的 路由器 就 成 砖 了 。hhhhhhhhh 未完待续 。。。。。。。。。。。。。。2017-8-15 update 拿 去 店里 救 砖 成功 。 刷 了 不 死 breed， 但是 现在 反而 没有 什么 折腾 劲 了 。  [1]: https://ol1kreips.qnssl.com/PandoraBox.png \"PandoraBox.png\"","title":"Pandorabox 之 透明 代理 ","oriTitle":"Pandorabox之透明代理"},{"uri":"/posts/xiaomi-openwrt--git","tags":["openwrt","git","go"],"content":" 小米 路由器 mini（Xiaomi mini R1CM） 刷 Openwrtscp /path/to/PandoraBox-xxxx.bin root@192.168.1.1:/tmp/PandoraBox.binmtd -r write /tmp/PandoraBox.bin firmware>  從 爬 文中 得知 ， 小米 路由器 Mini  官方 韌 體 是 雙 系 統 ， 由 於  ROM  有 16MB， 官方 韌 體 都 小 於 8MB， 所以 會 有 一份 備 援 系 統 （8MB+8MB）， 因此 如果 刷 了 大 於  8MB  的 第三方 韌 體 的 話 ， 會 覆 蓋 掉 第二 個 分 區 的 系 統 ， 導 致 未 來 刷 回 官方 韌 體 時 會 有 掉  SN  的 問 題 ， 而且 再也 無 法 刷 入  SSH， 從 此 以 後 就 只能 乖乖 用 官方 韌 體 ， 再也不能 玩 刷 機 ， 目前 新版 的  PandoraBox  韌 體 大 約 都 在  10MB  左右 ， 所以 刷 機 還 真 要 有 點 決 心 ， 除非 完整 備 份 小米 路由器 Mini  中 所有 分 區 的 資 料 ， 才能 在 日 後 完整 刷 回 官方 韌 體 ， 當 然 ， 如果 已 經 完全 放 棄 官方 韌 體 的 話 ， 這 些 問 題 都 是 不用 考 慮 的 。from -  http://blog.icece.tw/MiWiFi-Mini-Flash-ubootDisable middle button of mouseExecute those commands:xinput list⎡ Virtual core pointer                    \tid=2\t[master pointer  (3)]⎜   ↳ Virtual core XTEST pointer              \tid=4\t[slave  pointer  (2)]⎜   ↳ MI Dongle MI Wireless Mouse             \tid=11\t[slave  pointer  (2)]⎜   ↳ MI Dongle MI Wireless Mouse             \tid=12\t[slave  pointer  (2)]⎜   ↳ DLL0704:01 06CB:76AE Touchpad           \tid=14\t[slave  pointer  (2)]⎜   ↳ PS/2 Synaptics TouchPad                 \tid=17\t[slave  pointer  (2)]⎜   ↳ MiMouse                                 \tid=21\t[slave  pointer  (2)]xinput set-button-map 21 1 0 3ExplainationThe first number is the id of the pointer (you'll often only have one, in this case there were two, 9 and 10).The next numbers are what you do with the first, second, and third (ie, left, middle, right) mouse buttons. The \"1 0 3\" tells it that the left button should do a left click (action 1), the middle button should do nothing, and the right button should do a right click (action 3). If you want to make the middle button also do a left click you could use \"1 1 3\". If you wanted to switch the right and left actions you could use \"3 0 1\". See https://wiki.ubuntu.com/X/Config/Input for more info.git mergegit merge  #  将 特性 分支 合并 到 当前 分支 中 ， 形成 一个 新 的 提交 git rebasegit rebase  [] #  在 主 分支 的 基础 上 重演 特性 分支 的 修改 ， 修改 特性 分支 的 历史 （ 变 基 ）git rebase --onto master server client #  取出 client 分支 ， 将 client 和 server 的 共同 祖先 之后 的 变化 在 master 上 重演 一遍 > git-scm referenceVscode Go 设置 GOPATH（ 为 ~/go-workspace）cat > ~/.zshrc <<\"EOF\"Set Go Pathexport GOPATH=$HOME/go-workspaceCustomize to your needs...export PATH=$PATH:$GOPATHEOF 在 vscode 中 设置 ： 打开 用户 设置 ， 设置 go.gopath 安装 插件 ：Go 安装 依赖 ：( 事先 设置 好 httpproxy 和 httpsproxy)go get -u -v github.com/nsf/gocodego get -u -v github.com/rogpeppe/godefgo get -u -v github.com/golang/lint/golintgo get -u -v github.com/lukehoban/go-find-referencesgo get -u -v github.com/lukehoban/go-outlinego get -u -v sourcegraph.com/sqs/goreturnsgo get -u -v golang.org/x/tools/cmd/gorename","title":"Tech Daily@1-20","oriTitle":"Tech Daily@1-20"},{"uri":"/posts/acm-international-collegiate-programming-contest-asia-regional-contest-tokyo-problem-d-space-golf","tags":["暴力"],"content":" 原 题  pdf：click here 日本 的 亚洲 区域 赛 真心 简单 啊 。 两个 小时 就 刷 了  5  题 有余 了 。 排名 第一 的 队伍 才 做出  7  道 。 题目 真心 长 的 可以 了 ， 看 了 半个 小时 才 明白 。。 题意 其实 也 就是 太空 中 向 前方 抛 小球 ， 问 小球 能够 穿过  N  个 障碍物 后 到达 制定 地点 的 最小 初始 速度 是 多少 。 非常 暴力 的 模拟题 。 离散 化 后 直接 枚举 弹跳 的 次数 再 取 最小值 即可 。 注意  45°  方向 能 成功 的话 ， 那 还是  45°  最优 。`C++#include#include#include#include#include#include#include#include#include#include#include#include#include#include#includeusing namespace std;#define pr pair#define PR pair#define MP make_pair#define SI(x) set::iterator#define VI(x) vector::iterator#define MI(x, y) map::iterator#define SRI(x) set::reverse_iterator#define VRI(x) vector::reverse_iterator#define MRI(x, y) map::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x)    \\  while (!x.empty) \\    x.pop();#define clr(x, y) memset(x, y, sizeof(x));#if defined(WIN32) || defined(WIN32) || defined(WIN32) || defined(WIN32_)#define LL __int64#define LLS \"%\" \\            \"I\" \\            \"6\" \\            \"4\" \\            \"d\"#define LLU \"%\" \\            \"I\" \\            \"6\" \\            \"4\" \\            \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \\            \"l\" \\            \"l\" \\            \"d\"#define LLU \"%\" \\            \"l\" \\            \"l\" \\            \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u >> 1;const LL lnf = ~0ull >> 1;#define eps 1e-8/start/int d, n, b;PR ob[20];vector> vt;pair dpr;double a2, e[2];pair Cramer(pair dpr){  pair res;  a1 = dpr.F * dpr.F;  a1 = dpr.F;  e[1] = dpr.S;  double div = a0 * a1 - a1 * a0;  res.F = (e0] * a[1 - e1] * a[0) / div;  res.S = (e1] * a[0 - e0] * a[1) / div;  return res;}int main(int argc, char **argv){  while (~scanf(\"%d%d%d\", &d, &n, &b))  {    for (int i = 0; i = dist)        {          dpr.F -= dist;        }        if (dpr.F  res;      for (int i = 0; i < Sz(vt); i++)      {        dpr = vt[i];        if (i == 0)        {          res = Cramer(dpr);        }        else        {          double tmph = dpr.F * dpr.F * res.F + dpr.F * res.S;          if (tmph + eps < dpr.S)          {            res = Cramer(dpr);          }        }      }      res.F = -1.0 / (2 * res.F);      res.S = res.F * res.S * res.S;      ans = min(ans, sqrt(res.F + res.S));      //if the vector's angle is less than 45      if (res.S + eps < res.F)        ans = min(ans, sqrt(dist));    }    printf(\"%.5f\", ans);  }}`","title":"ACM International Collegiate Programming Contest Asia Regional Contest, Tokyo Problem D Space Golf","oriTitle":"ACM International Collegiate Programming Contest Asia Regional Contest, Tokyo Problem D Space Golf"},{"uri":"/posts/baylor6622-absurdistan-roads","tags":["图论"],"content":" 原 题 pdf：click here##DescriptionThe people of Absurdistan discovered how to build roads only last year. After the discovery, every citydecided to build their own road connecting their city with another city. Each newly built road can beused in both directions.Absurdistan is full of surprising coincidences. It took all N cities precisely one year to build theirroads. And even more surprisingly, in the end it was possible to travel from every city to every othercity using the newly built roads.You bought a tourist guide which does not have a map of the country with the new roads. It onlycontains a huge table with the shortest distances between all pairs of cities using the newly built roads.You would like to know between which pairs of cities there are roads and how long they are, becauseyou want to reconstruct the map of the N newly built roads from the table of shortest distances.You get a table of shortest distances between all pairs of cities in Absurdistan using the N roadsbuilt last year. From this table, you must reconstruct the road network of Absurdistan. There mightbe multiple road networks with N roads with that same table of shortest distances, but you are happywith any one of those networks.##InputFor each test case:• A line containing an integer N (2 ≤ N ≤ 2000) — the number of cities and roads.• N lines with N numbers each. The j-th number of the i-th line is the shortest distance from city i to city j.• All distances between two distinct cities will be positive and at most 1 000 000. Thedistance from i to i will always be 0 and the distance from i to j will be the same as the distancefrom j to i.##OutputFor each test case:• Print N lines with three integers ‘a b c’ denoting that there is a road between cities 1 ≤ a ≤ Nand 1 ≤ b ≤ N of length 1 ≤ c ≤ 1000000, where a ̸= b. If there are multiple solutions, you canprint any one and you can print the roads in any order. At least one solution is guaranteed toexist.• Print a blank line between every two test cases.##Sample Input40 1 2 11 0 2 12 2 0 11 1 1 040 1 1 11 0 2 21 2 0 21 2 2 030 4 14 0 31 3 0##Sample Output2 1 14 1 14 2 14 3 12 1 13 1 14 1 12 1 13 1 12 1 43 2 3NWERC  题目 还 挺 简单 的 。 题意 就是 一个 N 个 顶点 ，N 条 边 的 无 向 图 。 告诉 你 两 两点 之间 的 最 短路 。 让 你 重构 这个 图 。( 随意 输出 任意 一张 满足 以上 条件 的 图 ） 这 题 的 突破口 就是 N 条 边 。 要 想想 如果 只有 N-1 条 边 ， 那么 这个 图 就是 一个 树 了 。 所以 ， 我们 可以 先 构造 最小 生成 树 ， 再 来 考虑 最后 一条 边 。 可以 先 将 构造 好 的 树 求 一遍 floyd， 然后 再 跟 题目 的 最 短路 相 比较 ， 如果 两点 u,v 求 出 的 最 短路 w\\ 与 题目 给 的 最 短路 w 不 一致 （ 可以 断言 ：w\\&gt;w）， 那么 就 将 w 作为 最后 一条 边 的 边长 加 在 u，v 之间 即可 。 这样 的 边 可能 会 找到 很多 ， 事实上 只 需要 加上 任意 一条 就 使 所有 的 w\\` 都 等于 w 了 。 需要 注意 的 是 ， 可能 整个 树 就 已经 满足 题目 了 。 这样的话 ， 最后 一条 边 只 需要 重复 任意 一条 树 边 就 好 了 。`C++#include#include#include#include#includeusing namespace std;const int N = 2010;const int inf = 1  vt;vector res;int fN;int main() {\tbool first = true;\twhile (~scanf(\"%d\", &n)) {\t\tvt.clear();\t\tres.clear();\t\tif (!first) printf(\"\\n\");\t\telse first = false;\t\tfor (int i = 1; i  i)\t\t\t\t\tvt.push_back(Edge(i, j, x));\t\t\t}\t\t}\t\tfor (int i = 0; i = n - 1) break;\t\t\t}\t\t}\t\tfor (int k = 1; k  fi + fk) {\t\t\t\t\t\tfi = fi + fk;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tint flag = true;\t\tfor (int i = 0; i < (int) vt.size(); i++) {\t\t\tEdge now = vt[i];\t\t\tif (fnow.u != now.w) {\t\t\t\tres.push_back(Edge(now.u, now.v, now.w));\t\t\t\tflag = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (flag) res.push_back(res.back());\t\tfor (int i = 0; i < (int) res.size(); i++) {\t\t\tprintf(\"%d %d %d\\n\", res[i].u, res[i].v, res[i].w);\t\t}\t}}`","title":"baylor 6622 Absurdistan Roads（ NWERC Contest）","oriTitle":"baylor 6622 Absurdistan Roads（ NWERC Contest）"},{"uri":"/posts/beautifull-i3","tags":["gnome","i3wm"],"content":" 先 晒 张 日常 桌面图 。Gnome3 用 了 半年 了 一直 被 其 蹩脚 的 交互 和 层出不穷 的 Bug 所 折磨 。 虽然 Gnome3 很漂亮 ， 很 简洁 ， 但是 毕竟 漂亮 不能 当 饭 吃 。 套餐 这种 东西 虽然 简单 省事 ， 但是 终究 不是 为 你 所 量身 定制 的 ， 总 有 其中 一样 不合 你 口味 。 因此 ， 我 决定 再次 抛弃 “ 开箱 即 用 ” 的 DE(Desktop Environment)， 在 WM(Window Manager) 的 基础 上 自己 打造 一套 适合 自己 的 桌面环境 。i3WMi3 是 一个 比较 知名 的 平铺 式 的 窗口 管理器 （TilingWM）， 它 可以 通过 快捷键 来 管理程序 窗口 ， 使 他们 像 截图 那样 平铺 在 显示 屏幕 ， 控制 他们 的 大小 和 位置 。 十分 高效 也 有 几分 Geek 的 味道 。i3 的 所有 配置 全部 使用 shell 写成 ， 甚至 顶部 panel 的 各种 指示器 ， 都 由 用户 自己 写 的 bash 脚本 获得 并 显示 。 十分 简单 暴力 。 虽然 没有 图形界面 那么 直观 ， 但是 有 一种 一切 尽 在 自己 掌控 之下 的 感觉 。 这种 感觉 其实 是 十分 十分 不错 的 。 我 的 I3WM 配置文件 托管 在 了 Github。 配置 细节 I3 配置文件 的 语法 其实 跟 shell 差不多 ， 熟悉 Linux 的 用户 应该 都 能 完全 看 懂 。 我 的 配置文件 分为 几 大 模块 ：Workspaces 工作 区 配置 ， 我 根据 日常 使用 的 程序 类别 一共 设置 了 10 个 工作 区 ( 图标 显示 需要 在 本地 电脑 上 安装 Fontawesome 字体 ）：set $ws1 \t     \"1: Browser\"set $ws2         \"2: Code\"set $ws3 \t\t \"3: Chat\"set $ws4 \t\t \"4: File\"set $ws5 \t\t \"5: Terminal\"set $ws6 \t\t \"6: Video\"set $ws7 \t     \"7: Music\"set $ws8  \t     \"8:  Graphic\"set $ws9 \t\t \"9: Game\"set $ws0 \t\t \"0: Fullscreen\" 然后 ， 把 属于 各自 类别 的 程序 绑定 到 对应 的 工作 区 ， 这样 打开 这些 程序 的 时候 他们 就 能 自动 出现 在 合适 的 工作 区 了 ：assign \t[class=\"google-chrome-stable\"] \t\t\t$ws1   # Browserassign \t[class=\"vivaldi\"] \t\t\t\t\t\t            $ws1   # Browserassign \t[class=\"firefox\"] \t\t\t\t\t            \t$ws1   # Browserassign  [class=\"(?i)code\"]                                $ws2   # Code IDE...assign  [class=\"dota2\"]         \t\t                   $ws0   # Fullscreenassign\t[class=\"Minecraft 1.8.9\"]\t\t              $ws0   # FullscreenApplication 在 i3 配置文件 里面 我们 可以 对 常用 的 程序 绑定 快捷 启动 键 ：bindsym F10 exec xfce4-appfinderbindsym Print exec xfce4-screenshooterbindsym $mod+Return exec i3-sensible-terminalbindsym $mod+Return exec pantheon-terminalbindsym $mod+Control+t exec telegram-desktopbindsym $mod+Control+g exec google-chrome-stablebindsym $mod+Control+v exec vivaldibindsym $mod+Control+f exec nemobindsym $mod+Control+c exec codebindsym $mod+Control+n exec nitrogenbindsym $mod+Control+w exec electronic-wechatbindsym $mod+Control+y exec youdao-dict 然后 ， 对于 特殊 的 不 适合 平铺 的 窗口 ， 可以 直接 设置 它们 为 浮动 窗口 ：for_window [class=\"Geany\"] floating enable border normalfor_window [class=\"GParted\"] floating enable border normalfor_window [class=\"Nitrogen\"] floating enable border normalfor_window [class=\"(?i)virtualbox\"] floating enable border normalfor_window [class=\"Youdao Dict\"] floating enable border normal...PS： 可以 使用 xprop|grep WM_CLASS 来 查看 正在 运行 窗口 的 class 名称 。i3blocksi3blocks 是 I3 顶部 面板 的 一个 可 选 组件 。 它 使用 ini 格式 的 配置文件 ， 支持 多种 终端 脚本 ， 还 支持 鼠标 点击 、 滚动 事件 ， 十分 强大 。 配置文件 样本 如下 ：command=~/.config/i3/blocks/$BLOCK_NAMEalign=centercolor=#ffffffseparator=trueseparatorblockwidth=13markup=pango[disk-home]label=command=~/.config/i3/blocks/disk $HOMEinstance=/home/kevininterval=30color=#FFCC80[weather]instance=1808926 # hangzhou's city codeinterval=60color=#90CAF9... 主要 字 段 解释 ： 首先 前面 无 section 的 parameters 属于 默认 配置 项 ， 为 每个 section 的 缺省 配置 。 然后 每个 section 都 对应 顶 栏 上面 的 一个 指示器 ， 称为 block。 每个 block 必须 显示 一定 的 数据 ， 可以 通过 command 配置 项 指定 获取数据 的 命令 ， 并 使用 interval 来 设置 命令 执行 周期 间隔 。instance 为 可以 传递 到 command 脚本 中 的 环境变量 。color 和 label 为 颜色 和 标签 ， 属于 修饰 性 的 配置 项 。 所有 可用 的 block 命令 可以 参考 我 的 配置 文件夹 ：blockscomptoncompton 可以 给 i3 带来 透明 和 阴影 效果 的 支持 。 如果 只 关心 性能 而 不介意 美观 与否 ， 你 完全 可以 跳 过 此 节 。compton 默认 是 不 给 顶 栏 加 透明 效果 的 ， 需要 加入 如下 配置 ：wintypes:{    dock =    {        opacity = 0.8;    };}; 同时 ，compton 的 阴影 效果 不适 用于 某些 窗口 ， 需要 排除 它们 ：shadow-exclude = [    \"name = 'Notification'\",    \"name *= 'compton'\",    \"class_g = 'Conky'\",    \"class_g = 'Firefox'\",    \"class_g *= 'fcitx'\",    \"class_g = 'Youdao Dict'\"]; 易用性 建议 i3WM 只是 一个 地基 ， 我们 可以 在 这 之上 搭建 一个 适合 自己 的 环境 。 每个 人 的 口味 都 不 一样 ， 所以 我 简单 的 罗列 一下 我 个人 比较 喜欢 的 应用 和 配置 以 供参考 。dmenu: WM 下 使用 最 广泛 的 应用 启动器 ， 可以 自动 根据 用户 输入 的 命令 进行 提示 。rofi: dmenu 的 替代品 quickswitch.py:   跨 工作 区 窗口 快速 跳转 工具 ， 可以 整合 到 dmenu 中 。xfce4-appfinder:  xfce4 的 应用程序 列表 。 能够 自动 搜索 文件系统 中 的 desktop 文件 ， 并 生成 应用 列表 。 非常 实用 的 工具 。pantheon-terminal: elementaryOS 的 默认 终端 。 小巧 ， 依赖 少 ， 支持 背景 透明 、 多 标签 ， 很 完美 的 终端 模拟器 。（ 需要 使用 dconf-editor 来 修改 设置 ， 位置 ：/org/pantheon/terminal/settings/）nemo: linuxmint 的 默认 文件 管理器 ，forks 自 nautilus， 但是 比 nautilus 好 用 得 多 。（ 使用 之前 需要 使用 dconf-editor 设置 /org/nemo/desktop/show-desktop-icons 为 false）nitrogen:  提供 简单 的 图形界面 来 设置 壁纸 并 在 每次 开机 之后 自动 恢复 。clipit:  剪贴板 支持 lightdm:  轻量级 图形 登录 界面   [1]: https://ol1kreips.qnssl.com/%E6%88%AA%E5%9B%BE2017-03-1318-50-11.png \" 截图 2017-03-1318-50-11\"  [2]: https://github.com/stkevintan/i3dotfile  [3]: https://github.com/stkevintan/i3dotfile/tree/master/blocks","title":" 体验 I3 之 美 ","oriTitle":"体验I3之美"},{"uri":"/posts/dom-compatibility-note","tags":["javascirpt","dom","html"],"content":"Element.classList 返回 DOMTokenList,IE version>=10 不 完全 支持 。 不 支持 classList.contains 的 第二个 参数 (force)add 和 remove 方法 不 支持 多 参数 SVG,MathML 结点 没有 classList 属性 Node 种类 Node.nodeName|Interface|nodeName||:---------|:--------||Comment|#comment||Document|#document||DocumentFragment|#document-fragment|Node 的 树 遍历 Node 树 遍历 普遍 要 考虑 空白 文字 结点 。(whitespace textNode)。Node.childNodes 返回 一个 NodeList， 表示 该 结点 的 所有 子 结点 ， 包括 文字 结点 和 注释 ， 该 NodeList 里面 全部 是 object， 并 没有 string。 可以 使用 ParentNode.children 来 获得 所有 纯 Element 结点 集合 。Node.firstChild 返回 结点 的 第一个 子 结点 。 可能 是 whitespace textNode。 可以 使用 Element.firstElementChild 来 获得 Element 结点 。Node.lastChild 返回 结点 的 最后 一个 子 结点 。 可能 是 whitespace textNode。 可以 使用 Element.lastElementChild 来 获得 Element 结点 。Node.nextSibling 返回 下 一个 兄弟 结点 ， 可能 是 whitespace textNode。 可以 使用 Element.nextElementSibling 获得 Element 结点 。Node.previousSibling 返回 前 一个 兄弟 结点 ， 可能 whitespace textNode。 可以 使用 Element.previousElementSibling 获得 Element 结点 。Node.innerText 是 一个 非标准 的 属性 ， 返回 当前 结点 包括 其子 结点 的 所有 文字 。 可以 使用 标准 方法 Node.textContent 代替 。Node.textContentNode.parentElement 返回 当前 Node 的 父 Element 元素 ， 如果 没有 父 Element 元素 ， 返回 null。Node.parentNode 一个 元素 的 parentNode 可能 是 另 一个 元素 、Document 或者 DocumentFragment。Document 和 DocumentFragment 的 parentNode 是 null， 同样 ， 一个 刚刚 创建 的 node， 如果 还 没有 加 到 dom 树 里面 ， 它 的 parentNode 同样 是 null。// 移除 某 element：ele.parentNode.removeChild(ele);","title":"JS DOM API 分析 ","oriTitle":"JS DOM API分析"},{"uri":"/posts/fft-thoughts","tags":["数论","只言片语"],"content":" 离散 型 卷积 的 定义 是 ：$$y(n)=\\sum_{m=0}^{n} x(m)h(n-m)$$ 注意 ，h 函数 是 反转 的 。 在 Chipher Messages 一 题 中 ，b 串 需要 反转 再 与 a 串 匹配 。 比如说 ：a 串 ： 110110110， 则 ：b\\` 串 ：1011&lt;------ 这里 才 是 原来 b 串 的 头 。 但是 向上 对应 到 a 串 时 ， 已经 是 m-1 这个 位置 了 。 所以 说 ， 小于 m-1 的 卷积 是 没有 意义 的 。 于是 ，base=m。 整体 匹配 。 同样 的 ， 比如 杭 电 1402 用 FFT 求 A×B 那 一 题 。 可以 把 A 串 看成 卷积 中 的 x 函数 ， 而 把 B 串 的 每 一个 字符 看成 h 函数 。 那么 卷积 就 可以 看成 是 一个 模拟 乘法 的 过程 。 因为 h 函数 是 要求 逆序 的 ， 但是 此时 的 h 函数 只有 一个 字符 所以 反转 操作 无 意义 。 这时候 的 base=1。 单个 匹配 。 估计 FFT 就 这 两种 情况 了 。 因为 如果 1&lt;base&lt;m， 那么 就 应该 直接 将 b 串 分解成 若干 base 长度 的 串 了 。","title":"FFT 求 快速 卷积 的 思考 ","oriTitle":"FFT求快速卷积的思考"},{"uri":"/posts/hdu-2874-connections-between-cities","tags":["图论"],"content":"Connections between cities**Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 4759    Accepted Submission(s): 1341**Problem DescriptionAfter World War X, a lot of cities have been seriously damaged, and we need to rebuild those cities. However, some materials needed can only be produced in certain places. So we need to transport these materials from city to city. For most of roads had been totally destroyed during the war, there might be no path between two cities, no circle exists as well.Now, your task comes. After giving you the condition of the roads, we want to know if there exists a path between any two cities. If the answer is yes, output the shortest path between them.&nbsp;InputInput consists of multiple problem instances.For each instance, first line contains three integers n, m and c, 2&lt;=n&lt;=10000, 0&lt;=m&lt;10000, 1&lt;=c&lt;=1000000\\. n represents the number of cities numbered from 1 to n. Following m lines, each line has three integers i, j and k, represent a road between city i and city j, with length k. Last c lines, two integers i, j each line, indicates a query of city i and city j.&nbsp;OutputFor each problem instance, one line for each query. If no path between two cities, output “Not connected”, otherwise output the length of the shortest path between them.&nbsp;Sample Input5 3 2 1 3 2 2 4 3 5 2 3 1 4 4 5&nbsp;Sample OutputNot connected 6HintHint Huge input, scanf recommended._ _&nbsp;Source 2009 Multi-University Training Contest 8 - Host by BJNU`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define PR pair&lt;int,int&gt;#define MP make_pair#define SI(x) set&lt;x&gt;::iterator#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SRI(x) set&lt;x&gt;::reverse_iterator#define VRI(x) vector&lt;x&gt;::reverse_iterator#define MRI(x,y) map&lt;x,y&gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;/start/#define N 10004#define M 10005int n, m, c;struct Edge {    int v, w, nxt;} e[M &lt;&lt; 1];int head[N], ecnt;void initEdge() {    memset(head, -1, sizeof(head));    ecnt = 0;}void add(int u, int v, int w) {    e[ecnt].v = v;    e[ecnt].w = w;    e[ecnt].nxt = head[u];    head[u] = ecnt++;}//RMQint dpM20;int lg2[N &lt;&lt; 1];#define getL(R,L) (R-(L)+1)void initRMQ(int n) {    lg2[0] = -1;    int m;    for (int i = 1; i &lt;= n; i++)        lg2[i] = i &amp; (i - 1) ? lg2[i - 1] : lg2[i - 1] + 1;    for (int i = 1; i &lt;= lg2[n]; i++) {        m = getL(n, 1 &lt;&lt; i);        for (int j = 1; j &lt;= m; j++) {            dpMi = min(dpMi - 1, dpMi - 1)]);        }    }}int getRMQ(int a, int b) {    if (a &gt; b) swap(a, b);    int s = lg2[b - a + 1];    return min(dpMs, dpMs]);}//LCAint E[N];int T[N];int H[N];int depth, cnt;int belong[N], bcnt;int findRoot() {    for (int i = 1; i &lt;= n; i++) {        if (belong[i] == 0) return i;    }    return -1;}void getEuler(int u, int fa = -1) {    int tmp = dpM0 = ++cnt] = ++depth;    E[tmp] = u;    belong[u] = bcnt;    for (int i = head[u]; ~i; i = e[i].nxt) {        int v = e[i].v;        if (v == fa) continue;        T[v] = T[u] + e[i].w;        getEuler(v, u);        dpM0 = tmp;    }}void initLCA() {    memset(T, 0, sizeof(T));    memset(belong, 0, sizeof(belong));    bcnt = cnt = depth = 0;    int root;    while ((root = findRoot()) != -1) {        ++bcnt;        getEuler(root);    }    initRMQ(cnt);}int getLCA(int u, int v) {    if (belong[u] != belong[v]) return -1;    if (H[u] &gt; H[v]) swap(u, v);    return E[getRMQ(H[u], H[v])];}int main(int argc, char **argv) {    while (~scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;c)) {        initEdge();        int u, v, w;        for (int i = 1; i &lt;= m; i++) {            scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w);            add(u, v, w);            add(v, u, w);        }        initLCA();        while (c--) {            scanf(\"%d%d\", &amp;u, &amp;v);            int r = getLCA(u, v);            if (r == -1) puts(\"Not connected\");            else {                printf(\"%d\\n\", T[u] + T[v] - 2 * T[r]);            }        }    }}`","title":"HDU 2874 Connections between cities","oriTitle":"HDU 2874 Connections between cities"},{"uri":"/posts/hdu-4945-2048","tags":["DP"],"content":"**Time Limit: 3000/1500 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 590    Accepted Submission(s): 136**Problem DescriptionTeacher Mai is addicted to game 2048\\. But finally he finds it's too hard to get 2048\\. So he wants to change the rule:You are given some numbers. Every time you can choose two numbers of the same value from them and merge these two numbers into their sum. And these two numbers disappear meanwhile.If we can get 2048 from a set of numbers with this operation, Teacher Mai think this multiset is good.You have n numbers, A1,...,An. Teacher Mai ask you how many subsequences of A are good.The number can be very large, just output the number modulo 998244353.&nbsp;InputThere are multiple test cases, terminated by a line \"0\".For each test case, the first line contains an integer n (1&lt;=n&lt;=10^5), the next line contains n integers ai (0&lt;=ai&lt;=2048).&nbsp;OutputFor each test case, output one line \"Case #k: ans\", where k is the case number counting from 1, ans is the number module 998244353.&nbsp;Sample Input4 1024 512 256 256 4 1024 1024 1024 1024 5 1024 512 512 512 1 0&nbsp;Sample OutputCase #1: 1 Case #2: 11 Case #3: 8HintIn the first case, we should choose all the numbers. In the second case, all the subsequences which contain more than one number are good.&nbsp;&nbsp;Source 2014 Multi-University Training Contest 8&nbsp;Recommendhujie   |   We have carefully selected several similar problems for you:  4955 4954 4953 4952 4951 貌似 这 几天 第一次 做 的 DP 题 啊 。 想象 一下 二进制 就 能 明白 —— 当 子 序列 的 2 次 幂 数字 之 和 大于 等于 2048 时 这个 序列 就是 good 序列 了 。 正面 dp 要 dp 出 2048~100000 肯定 要 超时 ， 而 反面 dp 只 需要 dp 出 0~2047 就 够 了 。 复杂度 大大降低 O（11＊2048*2048）。 标 程 写 的 很 厉害 ！ 尤其 是 逆元 的 处理 ！`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define PR pair&lt;int,int&gt;#define MP make_pair#define SI(x) set&lt;x&gt;::iterator#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SRI(x) set&lt;x&gt;::reverse_iterator#define VRI(x) vector&lt;x&gt;::reverse_iterator#define MRI(x,y) map&lt;x,y&gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;/start/#define MOD 998244353int cnt[3010];LL f[101000], g[101000];int pn, n, __;int dp13; // 表示 取 了 2^0、2^1、2^2、……、2^i 种元素 ， 总和 加 起来 等于 j*2^(i+1) 的 所有 情况 inline int getint() {    int ret = 0;    bool ok = 0;    for (;;) {        int c = getchar();        if (c &gt;= '0' &amp;&amp; c &lt;= '9') ret = (ret &lt;&lt; 3) + ret + ret + c - '0', ok = 1;        else if (ok) return ret;    }}inline LL powmod(LL b, int x) {    LL res = 1;    for (b %= MOD; x; x &gt;&gt;= 1) {        if (x &amp; 1) res = res * b % MOD;        b = b * b % MOD;    }    return res;}int main(int argc, char **argv) {    f[0] = 1;    for (int i = 1; i &lt;= 100000; i++)        f[i] = f[i - 1] * i % MOD;    g[100000] = powmod(f[100000], MOD - 2);    for (int i = 99999; i &gt;= 0; i--)        g[i] = g[i + 1] * (i + 1) % MOD;    while (1) {        n = getint();        if (n == 0) break;        for (int k = 1; k &lt;= 2048; k &lt;&lt;= 1)            cnt[k] = 0;        for (int i = 0; i &lt; n; i++) {            cnt[getint()]++;        }        pn = 0;        for (int k = 1; k &lt;= 2048; k &lt;&lt;= 1)            pn += cnt[k];        for (int i = 0, m = 1024; i &lt;= 11; i++, m &gt;&gt;= 1) {            for (int j = 0; j &lt;= m; j++) {                dpi = 0;            }        }        int ct = cnt[1];        LL cof = f[ct];        for (int i = 0; i &lt;= ct &amp;&amp; i &lt; 2048; i++) {            dp0 += g[ct - i] * g[i] % MOD;            if (dp0 &gt; MOD) dp0 -= MOD;        }        for (int i = 1, m = 1024; i &lt;= 11; i++, m &gt;&gt;= 1) {            ct = cnt[1 &lt;&lt; i];            cof = cof * f[ct] % MOD;            for (int j = 0; j &lt; m; j++) {                if (dpi - 1) {                    for (int k = 0; k &lt;= ct &amp;&amp; j + k &lt; m; k++) {// 不要 把 满足 good 的 序列 转移 上去 。                        dpi &gt;&gt; 1] += dpi - 1 * g[k] % MOD * g[ct - k] % MOD;                        if (dpi &gt;&gt; 1] &gt; MOD) dpi &gt;&gt; 1] -= MOD;                    }                }            }        }        int ans = (powmod(2, pn) - dp11 * cof) % MOD                powmod(2, n - pn)%MOD;        if (ans &lt; 0) ans += MOD;        printf(\"Case #%d: %d\\n\", ++__, ans);    }}`","title":"HDU 4945 2048","oriTitle":"HDU 4945 2048"},{"uri":"/posts/hdu-4952-number-transformation","tags":["数论","暴力"],"content":"**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 612    Accepted Submission(s): 310**Problem DescriptionTeacher Mai has an integer x.He does the following operations k times. In the i-th operation, x becomes the least integer no less than x, which is the multiple of i.He wants to know what is the number x now.&nbsp;InputThere are multiple test cases, terminated by a line \"0 0\".For each test case, the only one line contains two integers x,k(1&lt;=x&lt;=10^10, 1&lt;=k&lt;=10^10).&nbsp;OutputFor each test case, output one line \"Case #k: x\", where k is the case number counting from 1.&nbsp;Sample Input2520 10 2520 20 0 0&nbsp;Sample OutputCase #1: 2520 Case #2: 2600&nbsp;Source 2014 Multi-University Training Contest 8&nbsp;Recommendhujie   |   We have carefully selected several similar problems for you:  4955 4954 4953 4951 4950`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define PR pair&lt;int,int&gt;#define MP make_pair#define SI(x) set&lt;x&gt;::iterator#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SRI(x) set&lt;x&gt;::reverse_iterator#define VRI(x) vector&lt;x&gt;::reverse_iterator#define MRI(x,y) map&lt;x,y&gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;/start/int __;#define type LLinline type getint() {    type ret=0;bool ok=0;    for(;;) {        int c=getchar();        if(c&gt;='0'&amp;&amp;c&lt;='9')ret=(ret&lt;&lt;3)+ret+ret+c-'0',ok=1;        else if(ok)return ret;    }}#undef typeint main(int argc, char **argv) {    LL x, k;    while (1) {        x=getint();        k=getint();        if (x == 0 &amp;&amp; k == 0) break;        for(int i=1;i&lt;k;i++){            if(x&lt;i+1)break;            x-=x/(i+1);        }        printf(\"Case #%d: \"LLS\"\\n\",++__,x*k);    }}`","title":"HDU 4952 Number Transformation","oriTitle":"HDU 4952 Number Transformation"},{"uri":"/posts/hdu-4965-fast-matrix-calculation","tags":["矩阵","暴力"],"content":"**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 131072/131072 K (Java/Others)Total Submission(s): 206    Accepted Submission(s): 116**Problem DescriptionOne day, Alice and Bob felt bored again, Bob knows Alice is a girl who loves math and is just learning something about matrix, so he decided to make a crazy problem for her.Bob has a six-faced dice which has numbers 0, 1, 2, 3, 4 and 5 on each face. At first, he will choose a number N (4 &lt;= N &lt;= 1000), and for N times, he keeps throwing his dice for K times (2 &lt;=K &lt;= 6) and writes down its number on the top face to make an NK matrix A, in which each element is not less than 0 and not greater than 5\\. Then he does similar thing again with a bit difference: he keeps throwing his dice for N times and each time repeat it for K times to write down a KN matrix B, in which each element is not less than 0 and not greater than 5\\. With the two matrix A and B formed, Alice’s task is to perform the following 4-step calculation.Step 1: Calculate a new NN matrix C = AB.Step 2: Calculate M = C^(N*N).Step 3: For each element x in M, calculate x % 6\\. All the remainders form a new matrix M’.Step 4: Calculate the sum of all the elements in M’.Bob just made this problem for kidding but he sees Alice taking it serious, so he also wonders what the answer is. And then Bob turn to you for help because he is not good at math.&nbsp;InputThe input contains several test cases. Each test case starts with two integer N and K, indicating the numbers N and K described above. Then N lines follow, and each line has K integers between 0 and 5, representing matrix A. Then K lines follow, and each line has N integers between 0 and 5, representing matrix B.The end of input is indicated by N = K = 0.&nbsp;OutputFor each case, output the sum of all the elements in M’ in a line.&nbsp;Sample Input4 2 5 5 4 4 5 4 0 0 4 2 5 5 1 3 1 5 6 3 1 2 3 0 3 0 2 3 4 4 3 2 2 5 5 0 5 0 3 4 5 1 1 0 5 3 2 3 3 2 3 1 5 4 5 2 0 0&nbsp;Sample Output14 56&nbsp;Source 2014 Multi-University Training Contest 9 这 题 让 我 注意 了 矩阵 模板 的 开销 问题 。1000X1000 多次 调用 就 会 爆 内存 了 。 下面 是 用 动态 数组 写 的 。 效率 非常 慢 ， 难以 接受 。`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define PR pair&lt;int,int&gt;#define MP make_pair#define SI(x) set&lt;x&gt;::iterator#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SRI(x) set&lt;x&gt;::reverse_iterator#define VRI(x) vector&lt;x&gt;::reverse_iterator#define MRI(x,y) map&lt;x,y&gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;/start/#define MOD 6int n, k;struct Matrix {    int n, m;    int** M;    Matrix(int n, int m) :n(n), m(m) {        M = new int*[n];        for (int i = 0; i &lt; n; i++)            M[i] = new int[m];    }    Matrix(int n, int m, int k) :            n(n), m(m) {        M = new int*[n];        for (int i = 0; i &lt; n; i++)            M[i] = new int[m];        Init(k);    }    ~Matrix() {        if (M) {            for (int i = 0; i &lt; n; i++) {                if (M[i]) {                    delete[] M[i];                    M[i] = NULL;                }            }            delete[] M;            M = NULL;        }    }    void Init(bool k) { //k=1  返回 单位矩阵 ，k=0  返回 零 矩阵         for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++)                Mi = k * (i == j);    }    void out() {        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++)                printf(\"%d%c\", Mi, j == m - 1 ? '\\n' : ' ');    }    Matrix &amp; operator=(const Matrix&amp; othr) {        this-&gt;~Matrix();        n = othr.n;        m = othr.m;        M = new int*[n];        for (int i = 0; i &lt; n; i++)            M[i] = new int[m];        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                Mi = othr.Mi;            }        }        return *this;    }    Matrix(const Matrix &amp; othr) {        n = othr.n;        m = othr.m;        M = new int*[n];        for (int i = 0; i &lt; n; i++)            M[i] = new int[m];        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                Mi = othr.Mi;            }        }    }    bool operator==(const Matrix&amp; othr) const {        if (n - othr.n || m - othr.m) return false;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (Mi != othr.Mi) return false;            }        }        return true;    }    Matrix operator *(const Matrix&amp; othr) const {        if (m - othr.n) exit(1); // 异常 退出         Matrix ans(n, othr.m, 0);        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; othr.m; j++)                for (int k = 0; k &lt; m; k++) {                    ans.Mi += Mi * othr.Mk % MOD;                    if (ans.Mi &gt;= MOD) ans.Mi -= MOD;                    if (ans.Mi &lt; 0) ans.Mi += MOD;                }        return ans;    }    Matrix operator *(const int&amp; x) const {        Matrix ans(n, m);        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++)                ans.Mi = Mi * x % MOD;        return ans;    }    Matrix operator +(const Matrix &amp; othr) const {        if (n - othr.n || m - othr.m) exit(1);        Matrix ans(n, m);        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++) {                ans.Mi = Mi + othr.Mi;                if (ans.Mi &gt;= MOD) ans.Mi -= MOD;                if (ans.Mi &lt; 0) ans.Mi += MOD;            }        return ans;    }    Matrix operator -(const Matrix&amp; othr) const {        if (n - othr.n || m - othr.m) exit(1);        Matrix ans(n, m);        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++) {                ans.Mi = Mi - othr.Mi;                if (ans.Mi &gt;= MOD) ans.Mi -= MOD;                if (ans.Mi &lt; 0) ans.Mi += MOD;            }        return ans;    }    Matrix operator ^(int x) const {        if (n - m) exit(1);        Matrix ans(n, m, 1), base = *this;        while (x &gt; 0) {            if (x &amp; 1) ans = ans * base;            base = base * base;            x &gt;&gt;= 1;        }        return ans;    }};int main(int argc, char **argv) {    while (~scanf(\"%d%d\", &amp;n, &amp;k)) {        if (n == 0 &amp;&amp; k == 0) break;        Matrix A(n, k, 0), B(k, n, 0);        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; k; j++) {                scanf(\"%d\", &amp;A.Mi);            }        }        for (int i = 0; i &lt; k; i++) {            for (int j = 0; j &lt; n; j++) {                scanf(\"%d\", &amp;B.Mi);            }        }        Matrix mat = B * A;        int r = n * n - 1;        Matrix res = A * (mat ^ r) * B;        int ans = 0;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; n; j++) {                ans += res.Mi;            }        }        printf(\"%d\\n\", ans);    }}` 然后 又 试了试 vector， 虽然 简单 不少 ， 但是 仍然 很 慢 ：`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define PR pair&lt;int,int&gt;#define MP make_pair#define SI(x) set&lt;x&gt;::iterator#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SRI(x) set&lt;x&gt;::reverse_iterator#define VRI(x) vector&lt;x&gt;::reverse_iterator#define MRI(x,y) map&lt;x,y&gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;/start/#define MOD 6int n, k;struct Matrix {    int n, m;    vector&lt;vector&lt;int&gt; &gt;M;    Matrix(int n, int m) :n(n), m(m) {        alloc();    }    Matrix(int n, int m, int k) :            n(n), m(m) {        alloc();        Init(k);    }    void alloc(){        M.resize(n);        for (int i = 0; i &lt; n; i++)            M[i].resize(m);    }    void Init(bool k) { //k=1  返回 单位矩阵 ，k=0  返回 零 矩阵         for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++)                Mi = k * (i == j);    }    void out() {        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++)                printf(\"%d%c\", Mi, j == m - 1 ? '\\n' : ' ');    }    bool operator==(const Matrix&amp; othr) const {        if (n - othr.n || m - othr.m) return false;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (Mi != othr.Mi) return false;            }        }        return true;    }    Matrix operator *(const Matrix&amp; othr) const {        if (m - othr.n) exit(1); // 异常 退出         Matrix ans(n, othr.m, 0);        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; othr.m; j++)                for (int k = 0; k &lt; m; k++) {                    ans.Mi += Mi * othr.Mk % MOD;                    if (ans.Mi &gt;= MOD) ans.Mi -= MOD;                    if (ans.Mi &lt; 0) ans.Mi += MOD;                }        return ans;    }    Matrix operator *(const int&amp; x) const {        Matrix ans(n, m);        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++)                ans.Mi = Mi * x % MOD;        return ans;    }    Matrix operator +(const Matrix &amp; othr) const {        if (n - othr.n || m - othr.m) exit(1);        Matrix ans(n, m);        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++) {                ans.Mi = Mi + othr.Mi;                if (ans.Mi &gt;= MOD) ans.Mi -= MOD;                if (ans.Mi &lt; 0) ans.Mi += MOD;            }        return ans;    }    Matrix operator -(const Matrix&amp; othr) const {        if (n - othr.n || m - othr.m) exit(1);        Matrix ans(n, m);        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++) {                ans.Mi = Mi - othr.Mi;                if (ans.Mi &gt;= MOD) ans.Mi -= MOD;                if (ans.Mi &lt; 0) ans.Mi += MOD;            }        return ans;    }    Matrix operator ^(int x) const {        if (n - m) exit(1);        Matrix ans(n, m, 1), base = *this;        while (x &gt; 0) {            if (x &amp; 1) ans = ans * base;            base = base * base;            x &gt;&gt;= 1;        }        return ans;    }};int main(int argc, char **argv) {    while (~scanf(\"%d%d\", &amp;n, &amp;k)) {        if (n == 0 &amp;&amp; k == 0) break;        Matrix A(n, k, 0), B(k, n, 0);        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; k; j++) {                scanf(\"%d\", &amp;A.Mi);            }        }        for (int i = 0; i &lt; k; i++) {            for (int j = 0; j &lt; n; j++) {                scanf(\"%d\", &amp;B.Mi);            }        }        Matrix mat = B * A;        int r = n * n - 1;        Matrix res = A * (mat ^ r) * B;        int ans = 0;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; n; j++) {                ans += res.Mi;            }        }        printf(\"%d\\n\", ans);    }}` 感觉 其他 方法 还 比较 麻烦 。 算了 就 这样 吧 ~&nbsp;","title":"HDU 4965 Fast Matrix Calculation","oriTitle":"HDU 4965 Fast Matrix Calculation"},{"uri":"/posts/hdu4005-the-war","tags":["tarjan","树形DP","图论"],"content":"**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65768/65768 K (Java/Others)Total Submission(s): 1992    Accepted Submission(s): 440**Problem DescriptionIn the war, the intelligence about the enemy is very important. Now, our troop has mastered the situation of the enemy's war zones, and known that these war zones can communicate to each other directly or indirectly through the network. We also know the enemy is going to build a new communication line to strengthen their communication network. Our task is to destroy their communication network, so that some of their war zones can't communicate. Each line has its \"cost of destroy\". If we want to destroy a line, we must spend the \"cost of destroy\" of this line. We want to finish this task using the least cost, but our enemy is very clever. Now, we know the network they have already built, but we know nothing about the new line which our enemy is going to build. In this condition, your task is to find the minimum cost that no matter where our enemy builds the new line, you can destroy it using the fixed money. Please give the minimum cost. For efficiency, we can only destroy one communication line.&nbsp;InputThe input contains several cases. For each cases, the first line contains two positive integers n, m (1&lt;=n&lt;=10000, 0&lt;=m&lt;=100000) standing for the number of the enemy's war zones (numbered from 1 to n), and the number of lines that our enemy has already build. Then m lines follow. For each line there are three positive integer a, b, c (1&lt;=a, b&lt;=n, 1&lt;=c&lt;=100000), meaning between war zone A and war zone B there is a communication line with the \"cost of destroy \" c.&nbsp;OutputFor each case, if the task can be finished output the minimum cost, or output ‐1.&nbsp;Sample Input3 2 1 2 1 2 3 2 4 3 1 2 1 1 3 2 1 4 3&nbsp;Sample Output-1 3HintFor the second sample input: our enemy may build line 2 to 3, 2 to 4, 3 to 4\\. If they build line 2 to 3, we will destroy line 1 to 4, cost 3\\. If they build line 2 to 4, we will destroy line 1 to 3, cost 2\\. If they build line 3 to 4, we will destroy line 1 to 2, cost 1\\. So, if we want to make sure that we can destroy successfully, the minimum cost is 3.&nbsp;&nbsp;Source The 36th ACM/ICPC Asia Regional Dalian Site —— Online Contest 求 无 向 图 边 双 连通 分量 缩 点 ， 然后 DP 求 第二 长 边 。//#pragma comment(linker, \"/STACK:1024000000,1024000000\")//C++ 加 栈 #include#include#include#include#include#include#include#include#include#include#includeusing namespace std;#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endif#define N 10005#define M 100005int n, m;const int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;struct edge {\tint v, w, nxt;\tbool mark;} e[M &lt;&lt; 1];struct bridge {\tint u, v, w;\tbridge(int u, int v, int w) {\t\tthis-&gt;u = u;\t\tthis-&gt;w = w;\t\tthis-&gt;v = v;\t}};int pos, head[N];int top, stk[N];int pre[N], dfs_clock, belong[N], bcnt;vector brg;void InitEdge() {\tmemset(head, -1, sizeof(head));\tpos = 0;}void add(int u, int v, int w) {\te[pos].v = v;\te[pos].w = w;\te[pos].nxt = head[u];\thead[u] = pos++;}int dfs(int u,int fa) {\tint lowu = pre[u] = ++dfs_clock;\tstk[top++] = u;\tbool vis=true;\tfor (int i = head[u]; ~i; i = e[i].nxt) {\t\tint v = e[i].v;\t\tif(v==fa &amp;&amp; vis){\t\t\tvis=false;// 重 边 \t\t\tcontinue;\t\t}\t\tif (!pre[v]) {\t\t\tint lowv = dfs(v,u);\t\t\tlowu = min(lowu, lowv);\t\t\tif (lowv &gt; pre[u]) { //u-v 为 桥 \t\t\t\tbrg.push_back(bridge(u, v, e[i].w));\t\t\t}\t\t} else lowu = min(lowu, pre[v]);\t}\tif (pre[u] == lowu) {\t\tbcnt++;\t\tdo {\t\t\tbelong[stk[--top]] = bcnt;\t\t} while (stk[top] != u);\t}\treturn lowu;}void tarjan() {\ttop = bcnt = dfs_clock = 0;\tmemset(pre, 0, sizeof(pre));\tmemset(belong, 0, sizeof(belong));\tbrg.clear();\tfor (int i = 1; i &lt;= n; i++) {\t\tif (!pre[i])dfs(i,-1);\t}}void rebuild() { // 根据 桥 来 缩 点 重 构图 \tInitEdge();\tfor (int i = 0; i &lt; (int) brg.size(); i++) {\t\tint u = belong[brg[i].u];\t\tint v = belong[brg[i].v];\t\tint w = brg[i].w;\t\tadd(u, v, w);\t\tadd(v, u, w);\t}}int res;int DP(int u, int fa) {\tint Min = inf;\tfor (int i = head[u]; ~i; i = e[i].nxt) {\t\tint v = e[i].v;\t\tif (v == fa)continue;\t\tint w = DP(v, u);\t\tw = min(w, e[i].w);\t\tif (Min &gt; w) {\t\t\tres = min(res, Min);\t\t\tMin = w;\t\t} else res = min(res, w);\t}\treturn Min;}int main() {\twhile (~scanf(\"%d%d\", &amp;n, &amp;m)) {\t\tint u, v, w;\t\tInitEdge();\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tscanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w);\t\t\tadd(u, v, w);\t\t\tadd(v, u, w);\t\t}\t\ttarjan();\t\trebuild();\t\tbridge minbrg(-1, -1, inf);\t\tfor (int i = 0; i &lt; (int) brg.size(); i++) {\t\t\tif (brg[i].w &lt; minbrg.w) {\t\t\t\tminbrg = brg[i];\t\t\t}\t\t}\t\tres = inf;\t\tDP(belong[minbrg.u], belong[minbrg.v]);\t\tDP(belong[minbrg.v], belong[minbrg.u]);\t\tif(res==inf)res=-1;\t\tprintf(\"%d\\n\", res);\t}}","title":"HDU4005 The war","oriTitle":"HDU4005 The war"},{"uri":"/posts/hdu4612-warm-up","tags":["tarjan","图论","树的直径"],"content":"**Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 65535/65535 K (Java/Others)Total Submission(s): 3532    Accepted Submission(s): 813**Problem Description　 　N planets are connected by M bidirectional channels that allow instant transportation. It's always possible to travel between any two planets through these channels.If we can isolate some planets from others by breaking only one channel , the channel is called a bridge of the transportation system.People don't like to be isolated. So they ask what's the minimal number of bridges they can have if they decide to build a new channel.Note that there could be more than one channel between two planets.Input　　The input contains multiple cases.Each case starts with two positive integers N and M , indicating the number of planets and the number of channels.(2&lt;=N&lt;=200000, 1&lt;=M&lt;=1000000)Next M lines each contains two positive integers A and B, indicating a channel between planet A and B in the system. Planets are numbered by 1..N.A line with two integers '0' terminates the input.Output　　For each case, output the minimal number of bridges after building a new channel in a line.Sample Input4 4 1 2 1 3 1 4 2 3 0 0Sample Output0Source 2013 Multi-University Training Contest 2`C++#pragma comment(linker, \"/STACK:1024000000,1024000000\")//C++ 加 栈 #include#include#include#include#include#include#include#include#include#include#includeusing namespace std;#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endif#define N 200005#define M 1000005int n, m;const int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;struct edge {\tint v, nxt;} e[M &lt;&lt; 1];struct bridge {\tint u, v;\tbridge(int u, int v) {\t\tthis-&gt;u = u;\t\tthis-&gt;v = v;\t}};int pos, head[N];int top, stk[N];int pre[N], dfs_clock, belong[N], bcnt;vector brg;void InitEdge() {\tmemset(head, -1, sizeof(head));\tpos = 0;}void add(int u, int v) {\te[pos].v = v;\te[pos].nxt = head[u];\thead[u] = pos++;}int dfs(int u, int fa) {\tint lowu = pre[u] = ++dfs_clock;\tstk[top++] = u;\tbool vis = true;\tfor (int i = head[u]; ~i; i = e[i].nxt) {\t\tint v = e[i].v;\t\tif (v == fa &amp;&amp; vis) {\t\t\tvis = false; //u-v 的 反向 边 一定 是 v-u 邻接 表里 的 第一条 边 。\t\t\tcontinue;\t\t}\t\tif (!pre[v]) {\t\t\tint lowv = dfs(v, u);\t\t\tlowu = min(lowu, lowv);\t\t\tif (lowv &gt; pre[u]) { //u-v 为 桥 \t\t\t\tbrg.push_back(bridge(u, v));\t\t\t}\t\t} else lowu = min(lowu, pre[v]);\t}\tif (pre[u] == lowu) {\t\tbcnt++;\t\tdo {\t\t\tbelong[stk[--top]] = bcnt;\t\t} while (stk[top] != u);\t}\treturn lowu;}void tarjan() {\ttop = bcnt = dfs_clock = 0;\tmemset(pre, 0, sizeof(pre));\tmemset(belong, 0, sizeof(belong));\tbrg.clear();\tfor (int i = 1; i &lt;= n; i++) {\t\tif (!pre[i]) dfs(i, -1);\t}}void rebuild() { // 根据 桥 来 缩 点 重 构图 \tInitEdge();\tfor (int i = 0; i &lt; (int) brg.size(); i++) {\t\tint u = belong[brg[i].u];\t\tint v = belong[brg[i].v];\t\tadd(u, v);\t\tadd(v, u);\t}}int diameter = 0;int findR(int u, int fa) {\tint h1 = 0, h2 = 0; //  以 u 为 根 ，h1 最高 的 儿子 ，h2 次 高 儿子 。 放在 dfs 里面 两者 不会 重合 。\tfor (int i = head[u]; ~i; i = e[i].nxt) {\t\tint v = e[i].v;\t\tif (v == fa) continue;\t\tint h = findR(v, u) + 1; // 若 路径 有 权重 ， 则 把 1 改为 u-v 的 权重 \t\tif (h &gt; h1) h2 = h1, h1 = h;\t\telse h2 = max(h, h2);\t}\tdiameter = max(diameter, h1 + h2);\treturn h1;}void tree_diameter() {\tdiameter = 0;\tfindR(1, -1);}int main() {\twhile (scanf(\"%d%d\", &amp;n, &amp;m), n || m) {\t\tint u, v;\t\tInitEdge();\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tscanf(\"%d%d\", &amp;u, &amp;v);\t\t\tadd(u, v);\t\t\tadd(v, u);\t\t}\t\ttarjan();\t\trebuild();\t\ttree_diameter();\t\tprintf(\"%d\\n\", bcnt - diameter - 1);\t}}`","title":"HDU4612 Warm up","oriTitle":"HDU4612 Warm up"},{"uri":"/posts/hdu4888-redraw-beautiful-drawings","tags":["网络流"],"content":"Problem DescriptionAlice and Bob are playing together. Alice is crazy about art and she has visited many museums around the world. She has a good memory and she can remember all drawings she has seen.Today Alice designs a game using these drawings in her memory. First, she matches K+1 colors appears in the picture to K+1 different integers(from 0 to K). After that, she slices the drawing into grids and there are N rows and M columns. Each grid has an integer on it(from 0 to K) representing the color on the corresponding position in the original drawing. Alice wants to share the wonderful drawings with Bob and she tells Bob the size of the drawing, the number of different colors, and the sum of integers on each row and each column. Bob has to redraw the drawing with Alice's information. Unfortunately, somtimes, the information Alice offers is wrong because of Alice's poor math. And sometimes, Bob can work out multiple different drawings using the information Alice provides. Bob gets confused and he needs your help. You have to tell Bob if Alice's information is right and if her information is right you should also tell Bob whether he can get a unique drawing.&nbsp;InputThe input contains mutiple testcases.For each testcase, the first line contains three integers N(1 ≤ N ≤ 400) , M(1 ≤ M ≤ 400) and K(1 ≤ K ≤ 40).N integers are given in the second line representing the sum of N rows.M integers are given in the third line representing the sum of M columns.The input is terminated by EOF.&nbsp;OutputFor each testcase, if there is no solution for Bob, output \"Impossible\" in one line(without the quotation mark); if there is only one solution for Bob, output \"Unique\" in one line(without the quotation mark) and output an N * M matrix in the following N lines representing Bob's unique solution; if there are many ways for Bob to redraw the drawing, output \"Not Unique\" in one line(without the quotation mark).&nbsp;Sample Input2 2 4 4 2 4 2 4 2 2 2 2 5 0 5 4 1 4 3 9 1 2 3 3&nbsp;Sample OutputNot Unique Impossible Unique 1 2 3 3&nbsp; 第一步 ， 考虑 如何 求 是否 有 解 。 使用 网络 流 求解 ， 每 一行 和 每 一列 分别 对应 一个点 ， 加上 源点 和 汇 点 一共 有 N+M+2 个 点 。 有 三类 边 ： 源点  -&gt;  每 一行 对应 的 点 ， 流量 限制 为 该行 的 和 每 一行 对应 的 点  -&gt;  每 一列 对应 的 点 ， 流量 限制 为  K 每 一列 对应 的 点  -&gt;  汇 点 ， 流量 限制 为 该 列 的 和 &nbsp; 对 上 图 做 最大 流 ， 若 源点 出发 的 边 和 到达 汇 点 的 边 全都 满 流 ， 则 有 解 ， 否则 无 解 。 若 要求 构造 方案 ， 则  (i,j)  对应 的 整数 就是 行  i–&gt;  列  j  的 流量 。 第二步 ， 考虑 解 是否 唯一 。 显然 ， 解 唯一 的 充分 必要条件 是 完成 最大 流 后 的 残余 网络 没有 长度 大于  2  的 环 。 所以 ， 判断 解 的 唯一性 可 使用 dfs， 注意 遍历 的 时候 不 可以 在 走 完 一条 边 后 马上 走 其 反向 边 ， 加 此 限制 检查 是否 有 环 即可 判断 解 是否 唯一 。 至此 ， 全 题 已 解决 。`C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstdlib&gt;using namespace std;const int maxn=500,maxm=maxn*maxn;int nextmaxm2],num[maxm2],r[maxm2],a[maxn2],rowsum[maxn],colsum[maxn],n,m,K,tt,T,d[maxn2],st[maxn2],cod[maxn;int h[maxn2],vh[maxn2];bool don[maxm2],in[maxn2];void insert(int x,int y,int rr){\tnext[++tt]=a[x];num[tt]=y;r[tt]=rr;a[x]=tt;\tnext[++tt]=a[y];num[tt]=x;r[tt]=0;a[y]=tt;}void construct(){\ttt=1;T=n+m+1;\tfor (int i=0;i&lt;=T;i++) a[i]=0;\tfor (int i=1;i&lt;=n;i++) insert(0,i,row_sum[i]);\tfor (int i=1;i&lt;=m;i++) insert(i+n,T,col_sum[i]);\tfor (int i=1;i&lt;=n;i++)\t{\t\tfor (int j=1;j&lt;=m;j++)\t\t{\t\t\tinsert(i,j+n,K);\t\t\tcodi=tt;\t\t}\t}}int dfs(int x,int y){\tif (x==T) return y;\tint sig=st[x],minh=T+1;\tdo\t{\t\tif (r[st[x]])\t\t{\t\t\tif (h[num[st[x]]]+1==h[x])\t\t\t{\t\t\t\tint k=dfs(num[st[x]],min(y,r[st[x]]));\t\t\t\tif (k)\t\t\t\t{\t\t\t\t\tr[st[x]]-=k;\t\t\t\t\tr[st[x]^1]+=k;\t\t\t\t\treturn k;\t\t\t\t}\t\t\t}\t\t\tminh=min(minh,h[num[st[x]]]+1);\t\t\tif (h[0]&gt;T) return 0;\t\t}\t\tst[x]=next[st[x]];\t\tif (st[x]==0) st[x]=a[x];\t}while (sig!=st[x]);\tif (vh[h[x]]--==0) h[0]=T+1;\tvh[h[x]=minh]++;\treturn 0;}int max_flow(){\tfor (int i=0;i&lt;=T;i++) h[i]=vh[i]=0;\tfor (int i=0;i&lt;=T;i++) st[i]=a[i];\tvh[0]=T+1;\tint ret=0;\twhile (h[0]&lt;=T) ret+=dfs(0,K+1);\treturn ret;}/*bool find_circle(){\tdeque  q;\tfor (int i=0;i&lt;=T;i++) d[i]=0;\tfor (int i=0;i&lt;=T;i++)\t{\t\tfor (int p=a[i];p;p=next[p])\t\t{\t\t\tif (r[p]) d[i]++;\t\t}\t\tif (d[i]==0) q.push_back(i);\t}\tint cnt=T+1;\twhile (!q.empty())\t{\t\tint x=q.front();\t\tcnt--;\t\tq.pop_front();\t\tfor (int p=a[x];p;p=next[p])\t\t{\t\t\tif (r[p^1])\t\t\t{\t\t\t\td[num[p]]--;\t\t\t\tif (d[num[p]]==0) q.push_back(num[p]);\t\t\t}\t\t}\t}\treturn cnt;}*/bool visit(int x,int ed){\tif (don[ed])\t\treturn in[x];\tdon[ed]=true;\tin[x]=true;\tfor (int p=a[x];p;p=next[p])\t{\t\tif (r[p] &amp;&amp; (ed^p)!=1)\t\t\tif (visit(num[p],p)) return true;\t}\tin[x]=false;\treturn false;}bool find_circle(){\tfor (int i=0;i&lt;=T;i++) in[i]=false;\tfor (int i=1;i&lt;=tt;i++) don[i]=false;\tint col=0;\tfor (int i=2;i&lt;=tt;i++)\t{\t\tif (r[i] &amp;&amp; !don[i])\t\t{\t\t\tin[num[i^1]]=true;\t\t\tif (visit(num[i],i)) return true;\t\t\tin[num[i^1]]=false;\t\t}\t}\treturn false;}void print_scheme(){\tprintf(\"Unique\\n\");\tfor (int i=1;i&lt;=n;i++)\t{\t\tprintf(\"%d\",rcod[i]);\t\tfor (int j=2;j&lt;=m;j++) printf(\" %d\",rcod[i]);\t\tprintf(\"\\n\");\t}}int main(){\twhile (scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;K)!=EOF)\t{\t\tint tmp=0;\t\tfor (int i=1;i&lt;=n;i++)\t\t{\t\t\tscanf(\"%d\",&amp;row_sum[i]);\t\t\ttmp+=row_sum[i];\t\t}\t\tint sum=tmp;\t\tfor (int i=1;i&lt;=m;i++)\t\t{\t\t\tscanf(\"%d\",&amp;col_sum[i]);\t\t\ttmp-=col_sum[i];\t\t}\t\tif (tmp)\t\t{\t\t\tprintf(\"Impossible\\n\");\t\t\tcontinue;\t\t}\t\tconstruct();\t\tif (max_flow()&lt;sum)\t\t{\t\t\tprintf(\"Impossible\\n\");\t\t\tcontinue;\t\t}\t\tif (find_circle())\t\t{\t\t\tprintf(\"Not Unique\\n\");\t\t}else print_scheme();\t}\treturn 0;}`","title":"HDU4888 Redraw Beautiful Drawings ","oriTitle":"HDU4888 Redraw Beautiful Drawings "},{"uri":"/posts/hdu4944-fsfs-game","tags":["数论"],"content":"**Time Limit: 9000/4500 MS (Java/Others)    Memory Limit: 131072/131072 K (Java/Others)Total Submission(s): 166    Accepted Submission(s): 76**Problem DescriptionFSF has programmed a game.In this game, players need to divide a rectangle into several same squares.The length and width of rectangles are integer, and of course the side length of squares are integer.After division, players can get some coins.If players successfully divide a AxB rectangle(length: A, width: B) into KxK squares(side length: K), they can get A*B/ gcd(A/K,B/K) gold coins.In a level, you can’t get coins twice with same method.(For example, You can get 6 coins from 2x2(A=2,B=2) rectangle. When K=1, AB/gcd(A/K,B/K)=2; When K=2, AB/gcd(A/K,B/K)=4; 2+4=6; )There are N*(N+1)/2 levels in this game, and every level is an unique rectangle. (1x1 , 2x1, 2x2, 3x1, ..., Nx(N-1), NxN)FSF has played this game for a long time, and he finally gets all the coins in the game.Unfortunately ,he uses an UNSIGNED 32-BIT INTEGER variable to count the number of coins.This variable may overflow.We want to know what the variable will be.(In other words, the number of coins mod 2^32)&nbsp;InputThere are multiply test cases.The first line contains an integer T(T&lt;=500000), the number of test casesEach of the next T lines contain an integer N(N&lt;=500000).&nbsp;OutputOutput a single line for each test case.For each test case, you should output \"Case #C: \". first, where C indicates the case number and counts from 1.Then output the answer, the value of that UNSIGNED 32-BIT INTEGER variable.&nbsp;Sample Input3 1 3 100&nbsp;Sample OutputCase #1: 1Case #2: 30Case #3: 15662489HintIn the second test case, there are six levels(1x1,1x2,1x3,2x2,2x3,3x3) Here is the details for this game: 1x1: 1(K=1); 1x2: 2(K=1); 1x3: 3(K=1); 2x2: 2(K=1), 4(K=2); 2x3: 6(K=1); 3x3: 3(K=1), 9(K=3); 1+2+3+2+4+6+3+9=30_ _&nbsp;AuthorUESTC&nbsp;Source 2014 Multi-University Training Contest 7&nbsp;RecommendWe have carefully selected several similar problems for you:  4943 4942 4941 4940 4939N(LogN) 的 复杂度 。`C++#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define N 500001unsigned int f[N];unsigned int g[N];int n;int main() {    int T;    for (int i = 1; i &lt; N; i++) {        for (int j = 1; i * j &lt; N; j++) {            g[i * j] += (1LL + j) * j / 2;        }    }    f[1] = 1;    for (int i = 2; i &lt; N; i++) {        f[i] = f[i - 1] + i * g[i];    }    scanf(\"%d\", &amp;T);    for (int c = 1; c &lt;= T; c++) {        scanf(\"%d\", &amp;n);        printf(\"Case #%d: %u\\n\", c, f[n]);    }}`","title":"HDU4944 FSF’s game","oriTitle":"HDU4944 FSF’s game"},{"uri":"/posts/herbustluftwm-config","tags":["DE/WM"],"content":" 一直 以来 想 折腾 一下 WM， 但是 又 感觉 麻烦 。 前天 把 笔记本 带到 机房 就 借此机会 在 虚拟机 中 玩 了 一下 。 发现 事实上 比 我 想像 的 要 简单 的 多 。 少量 配置 了 一下 两个 配置文件 就 能 用 了 。 然后 使用 compton 做 透明 特效 。 看起来 也 挺 简洁 美观 的 。WM 最大 的 特点 就是 轻便 ，herbstluftWM 也 不 例外 。 安装 只有 几百 兆 ， 附加 依赖 少 ， 几乎 一个 命令 的 事情 。 启动 、 响应速度 都 是 普通 DE 无法比拟 的 快 。 加上 compton 的 透明 效果 ， 稍加 修饰 整个 系统 的 界面 就 非常 美观 了 。 两个 配置文件 与 更 详细 的 说明 我 已经 push 到 了 github：click here","title":" 我 的 HerbstluftWM","oriTitle":"我的HerbstluftWM"},{"uri":"/posts/hexo-lightum-enhance","tags":["美化","html"],"content":" 首先 我 使用 的 是 由 zippera 基于 官方 Light 主题 改进 而 来 的 Lightum 主题 , 其他 主题 可能 稍 有 出入 。## 速度 优化 参考 之前 的 文章 ： 静态 页面 优化 。 然后 使用 了 hexo-qiniu-sync 这个 项目 ， 将 静态 的 图片 以及 css、js 同步 到 了 七 牛 云 。（PS： 主题 模板 中 包含 了 两个 不同 版本 的 jquery， 分别 在 head.ejs 与 after-footer.ejs 中 ， 随便 删除 一个 。） 对于 处于 body 区域 的 script、style 的 引用 尽可能 的 加入 data-no-instant 属性 ， 避免 InstantClick 重复 加载 。## 给 instantclick 加载 进度条 加上 阴影 效果 `CSS#instantclick-bar{-webkit-box-shadow: 0 0 8px rgba(0, 0, 0, 0.56);box-shadow: 0 0 8px rgba(0, 0, 0, 0.56);}`## 加入 Swiftype 搜索 去 Swiftype 官 网 申请 代码 ， 然后 修改 search.ejs 文件 为 ：`Html\">` 更 具体 的 指导 具体 可以 参考 这 篇文章 ：click here。## 改进 多 说 评论 框 ### 添加 data-thread-key 等 属性 `Html\" data-title=\"\" data-url=\"\">`### 美化 多 说 评论 框 进入 多 说 评论 的 管理 后台 ， 将 下面 代码 粘贴 到 ‘ 设置 -> 自定义 CSS’ 中 。`#ds-reset .ds-avatar img{width:54px;height:54px;border-radius:27px;-webkit-border-radius:27px;-moz-border-radius:27px;box-shadow:inset 0 -1px 0 #3333sf;-webkit-box-shadow:inset 0 -1px 0 #3333sf;-webkit-transition:0.4s;-webkit-transition:-webkit-transform 0.4s ease-out;transition:transform 0.4s ease-out;-moz-transition:-moz-transform 0.4s ease-out;}#ds-reset .ds-avatar img:hover{box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);-webkit-box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);transform:rotateZ(360deg);-webkit-transform:rotateZ(360deg);-moz-transform:rotateZ(360deg);}p.ds-powered-by,#ds-sync-checkbox,.ds-sync label{display:none!important;}#ds-reset .ds-rounded-top{-webkit-border-top-right-radius:0px;-webkit-border-top-left-radius:0px;border-top-right-radius:0px;border-top-left-radius:0px;}#ds-thread #ds-reset .ds-textarea-wrapper{background:#fff;border:0;margin-bottom:20px;padding-right:0px;}#ds-thread #ds-reset .ds-textarea-wrapper textarea{min-height:80px;border:1px solid #ccc;padding:10px;-webkit-appearance:none;border-radius:0;background-color:#FFFFFF;border-color:#cccccc;box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);color:rgba(0,0,0,0.75);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transition:border-color 0.15s linear,background 0.15s linear;-moz-transition:border-color 0.15s linear,background 0.15s linear;-ms-transition:border-color 0.15s linear,background 0.15s linear;-o-transition:border-color 0.15s linear,background 0.15s linear;transition:border-color 0.15s linear,background 0.15s linear;}#ds-thread #ds-reset .ds-textarea-wrapper textarea:focus{border-color:#999999;background:#fafafa;outline:none;}#ds-thread #ds-reset .ds-post-options{border-bottom-left-radius:0px;-webkit-border-bottom-left-radius:0px;border:none;background:none!important;}#ds-thread #ds-reset .ds-post-button{border-bottom-right-radius:0px;-webkit-border-bottom-right-radius:0px;}#ds-reset .ds-textarea-wrapper textarea:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);}#ds-thread #ds-reset .ds-post-button{background-image:none;text-shadow:none;border:none;font-weight:normal;line-height:normal;position:absolute;-webkit-appearance:button;-moz-appearance:button;background-color:#008CBA;border-color:#007095;color:#FFFFFF;transition:background-color 300ms ease-out;}#ds-thread #ds-reset .ds-post-button:hover,#ds-thread #ds-reset .ds-post-button:focus{background-color:#007095;color:#FFFFFF;}`## 加入 多 说 最新 评论 修改 'theme/lightum/config.yml' 文件 ， 在 widgets 下面 添加 - recentcomments 项 。 在 主题 文件 的 'theme/lightum/layout/widget' 目录 中 新建 recentcomments.ejs 文件 ， 并 放入 如下 代码 ：`..........` 然后 在 '/languages/zh-CN.yml' 文件 添加 翻译 ：recent_comments:  最新 评论 最后 ， 原来 的 评论 样式 不 太 符合 lightum 主题 ， 可以 在 '/source/css/partial' 里 建立 一个 recentcomment.styl 文件 ：`language.ds-recent-comments  li.ds-comment    &:first-child      border-top none !important` 然后 在 /theme/lightum/source/css/style 中将 之 包括 进来 ：@import 'partial/recentcomments' 多 说 的 这个 插件 同样 不 兼容 于 instantclick。 我们 可以 在 这 篇文章 的 基础 上 解决 ：click here: 将 多 说 的 公共 JS 放入 head 或 加入 'data-no-instant' 属性 放入 body 中 ， 并 删除 recent.ejs 与 comment.ejs 中 重复 的 JS。 修改 change 事件 中 的 代码 为 ：`if(typeof DUOSHUO !== 'undefined'){ //support  多 说 评论 框 if($(\".ds-thread\").length){    DUOSHUO.EmbedThread($('.ds-thread')[0]);}DUOSHUO.RecentComments($('.ds-recent-comments')[0]);}` 这样 虽然 能够 解决问题 ， 但是 会 显示 方面 又 会 出现 点 小 问题 。 可以 加入 下面 css 修复 ：`languagespan.caption{display: none;}` 加入 文章 导航 修改 '/layout/_partical/article.ejs' 文件 `Html\">  // ...        //  插入 文章 导航 ` 在 '\\source\\css\\_partial\\article.styl' 文件 后 添加 ：`language  .toc-article    float right  #toc    background #eee    margin 0 0 10px 20px    padding 12px    line-height 18px    font-size 10px    strong      font-size 15px    ol      margin-top 5px      margin-left 0    .toc      padding 0      li        list-style-type none    .toc-child      padding-left 20px` 这样 ， 我们 就 能 在 写文章 的 时候 添加 toc: true 来 启动 文章 导航 功能 。### 扩展 ： 浮动式 导航 实现 当 页面 滑动 到 下方 时 将 文章 导航 浮动 到 屏幕 右侧 。 在 '\\layout\\partial\\' 里 新建 文件 ：floatnav.ejs`Html\t→(function($, scrollSpeed, hiddenSpeed, fadeSpeed) {\tvar T = $('#toc');\tvar M = $('#menu-nav');\tvar C = $('#content-nav');\tvar Tx = T.position().top;\t$(window).scroll(function() {\t\tvar top = $(this).scrollTop();\t\tif (top >= Tx + 300) {\t\t\tM.stop().fadeIn(fadeSpeed);\t\t\tT.stop().fadeTo(fadeSpeed, 0);\t\t} else {\t\t\tM.stop().fadeOut(fadeSpeed);\t\t\tT.stop().fadeTo(fadeSpeed, 1);\t\t}\t});\t$('.toc-link').click(function(e) {\t\t// 阻止 默认 跳转 \t\te.preventDefault();\t\t// 定义 滚动 动画 \t\tvar scrollTarget = $('#' + $(this).children('.toc-text').first().text());\t\t$(\"html,body\").animate({\t\t\tscrollTop: scrollTarget.prev().offset().top\t\t}, scrollSpeed);\t});\tC.click(function(e) {\t\te.stopPropagation();\t});\tM.click(function() {\t\tC.toggle(hiddenSpeed, 'linear', function() {\t\t\tvar T = $('#title-nav div');\t\t\tT.text() == '←' ? T.text('→') : T.text('←');\t\t});\t});})(jQuery, 500, 200, 100);` 在 'layout/_partial/article.ejs' 中 添加 对 其 的 引用 ：`Html` 添加 css 样式 ：`languagenavbcolor=rgba(100, 100, 100, 0.74)#menu-nav  position fixed;  display none;  cursor pointer;  z-index 150;  right 0;  top 20%;  box-shadow 0 0 5px rgba(0, 0, 0, 0.15);  color white;  background navbcolor;  #title-nav    display inline-block;    vertical-align middle;    width: 30px;    height: 100%;    font-size: 16px;    text-align: center;    padding: 10px 0;  #content-nav    display inline-block;    vertical-align middle;    white-space:nowrap;    border-left: 1px dashed #ccc;    box-sizing border-box;    padding 15px;    line-height 18px;    font-size 10px;    li      list-style-type none;      width 100%;      a        display block;        box-sizing border-box;        color #FFFFFF;        &:hover          background rgba(100, 100, 100, 1);      .toc-child a        padding-left 20px;`### 添加 \" 返回 顶部 \" 与 上 一节 相似 ， 在 'layout/_widget/' 中 添加 totop.ejs 文件 ：`Html↑(function($, scrollSpeed, fadeSpeed) {\tvar T = $('#to-top');\t$(window).scroll(function() {\t\tvar top = $(this).scrollTop();\t\tif (top >= 300) {\t\t\tT.stop().fadeIn(fadeSpeed);\t\t} else {\t\t\tT.stop().fadeOut(fadeSpeed);\t\t}\t});\tT.click(function() {\t\t$(\"html,body\").animate({\t\t\tscrollTop: 0\t\t}, scrollSpeed);\t});})(jQuery, 500, 200);` 在 'lightum/_config.yml' 中 启用 该 挂件 ：`languagewidgets:totop` 添加 css 样式 ：`language#to-top  background navbcolor;  position fixed;  display none;  z-index 200;  right 40px;  bottom 10%;  box-shadow 0 0 5px rgba(0, 0, 0, 0.15);  font-size 14px;  color white;  padding 5px 15px;  cursor pointer;  font-size 12px;  text-align center;  &:hover    background rgba(100,100,100,1);`## 参考 Hexo  主题 修改 : 为 博客 实现 更 多功能 多 说 评论 也 玩 圆角 头像 动画 「 自定义 CSS: 无 压力 小 白 级 教程 」Hexo  优化 与 定制 ( 二 )","title":"Hexo 折腾 笔记 （ 二 ） 博客 优化 与 定制 ","oriTitle":"Hexo折腾笔记（二）博客优化与定制"},{"uri":"/posts/hexo-speedup-instantclick","tags":["html","instantclick"],"content":" 首先 ，Gitcafe 的 国内 速度 已经 够快 了 ， 加 不 加速 其实 没 多 大 区别 , 只不过 是 闲 的 蛋 疼 而已 。Gitcafe 无故 page 不 更新 ， 所以 又 换回 了 github。Hexo 加速 Hexo 加速 可以 有 以下 几个 方面 ： 使用 BootCDN 并 将 图片 等 资源 储存 至 七 牛 云 。 可以 使用 此 项目 click here。 使用 hexo optimize 压缩 优化 HTML、CSS、JS、Image 资源 。 使用 InstantClick。InstantClick 是 一款 类似 于 Turbolinks 的 js 库 ， 利用 pjax（pushState and Ajax) 技术 对 网站 进行 优化 ， 能够 极大 的 提高 访问速度 。 解决 InstantClick 的 兼容问题 InstantClick 效果 明显 ， 但是 副作用 也 大 。 加入 它 之后 ， 原来 相处 无碍 的 Fancybox、 百度 分享 、 百度 统计 、 mathJax、 多 说 评论 都 挂 了 。 下面 是 我 的 解决 方法 ：###FancyboxFancybox 的 修复 首先 要 避 面 页面 切换 时 jquery.fancybox.min.js 文件 的 重复 加载 。 可以 将 该 js 文件 的 引用 放入 head 中 或者 加入 data-no-instant 属性 。 然后 ， 因为 instantclick 在 预 加载 时 默认 只 替换 body 元素 ， 所以 在 绑定 fancybox 的 时候 需要 设置 parent 属性 为 body：`Javascript(function($){    $('.fancybox').fancybox({parent:'body'});})(jQuery);` 这样 就 应该 可以 了 。### 多 说 评论 （ 以及 最新 评论 、 热 评 文章 等 ） 首先 ， 多 说 的 公共 JS 是 不能 放在 加入 data-no-instant 属性 的 。 因为 不是 网站 所有 页面 都 包含 评论 部分 的 。 因此 ， 我们 需要 将 其 裹入 一层 判断 中 来 阻止 其 多次 加载 ， 提高 网页 的 访问速度 ：`Htmlif(typeof duoshuoQuery === 'undefined'){    var duoshuoQuery = {short_name:\" 你 的 域名 \"};    (function() {        var ds = document.createElement('script');        ds.type = 'text/javascript';ds.async = true;        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';        ds.charset = 'UTF-8';        (document.getElementsByTagName('head')[0]         || document.getElementsByTagName('body')[0]).appendChild(ds);    })();}` 然后 ， 我们 需要 在 页面 预 加载 的 change 事件 里 对 其 进行 重载 ：`HtmlInstantClick.on('change', function(isInitialLoad) {  if (isInitialLoad === false) {  \tif($(\".ds-thread\").length && typeof DUOSHUO !== 'undefined'){ //support  多 说 评论 框   \t\tDUOSHUO.EmbedThread($('.ds-thread')[0]);  \t}  }});InstantClick.init();` 可以 用 同样 的 方式 解决 多 说 的 热门 文章 、 最新 评论 等 插件 的 问题 。DUOSHUO 全部 的 重载 函数 有 ：\"EmbedThread\", \"RecentComments\", \"RecentVisitors\", \"TopUsers\", \"TopThreads\", \"LoginWidget\", \"ThreadCount\"### 百度 统计 、google 统计 、MathJax 这 三个 可以 参考 这 篇文章 ：click here。 同样 是 在 change 事件 里 对 他们 进行 重新 加载 。`JavascriptInstantClick.on('change', function(isInitialLoad) {  if (isInitialLoad === false) {    if (typeof MathJax !== 'undefined') // support MathJax      MathJax.Hub.Queue([\"Typeset\",MathJax.Hub]);    if (typeof prettyPrint !== 'undefined') // support google code prettify      prettyPrint();    if (typeof _hmt !== 'undefined')  // support  百度 统计       hmt.push(['trackPageview', location.pathname + location.search]);    if (typeof ga !== 'undefined')  // support google analytics        ga('send', 'pageview', location.pathname + location.search);  }});`### 百度 分享 百度 分享 可以 用 jiathis 代替 ， 其实 国内 的 分享 工具 都 差不多 。## 关于 data-no-instant 属性 data-no-instant 属性 是 用来 避免 instantclick 在 页面 切换 时 对 该 元素 重复 加载 。 可以 用 在 script、style 标签 中 ， 也 能 放在 a 标签 中 ， 表示 该 链接 将 使用 正常 方式 打开 而 不用 instantclick 加速 。data-no-intant 无法 阻止 对 div 等 元素 的 重新 加载 ， 因此 无法 实现 像 网易 云 音乐 那样 在 切换 页面 的 时候 无间断 的 播放 音乐 等 功能 。 不过 曾 有人 contribute 过 类似 的 功能 ， 但是 作者 没有 接受 ：click here。 至此 全部 问题 解决 了 ， 其他 的 问题 可以 参考 下面 几个 链接 ： 整合  InstantClick  與  AddThisHexo  静态 博客 加速 fancybox 文档 InstantClick 文档 ","title":"Hexo 折腾 笔记 （ 一 ） 博客 加速 以及 instantclick 的 兼容 ","oriTitle":"Hexo折腾笔记（一）博客加速以及instantclick的兼容"},{"uri":"/posts/hugo-guidance","tags":["hugo","blog generator"],"content":"Hugo 是 spf13 大神 写 的 一个 静态 博客 生成器 ， 拥有 仅次于 Hexo 的 用户量 。 相比 于 Hexo，Hugo 使用 Go 编写 ， 生成 速度 快 了 很多 。 除此之外 ，Hugo 的 设计 更加 合理 ， 文档 也 比较 详尽 ， 比较 适合 我 这种 喜欢 从零开始 折腾 的 技术 宅 。 本 博客 就是 在 hugo 上 搭建 的 ， 使用 了 自己 编写 的 主题 ： canoe 。 迁徙 博文 因为 我 以前 使用 的 hexo， 已经 拥有 相当 一部分 博文 了 ， 所以 我 需要 将 原来 hexo 格式 的 博文 转换 到 hugo 中 。 其中 主要 的 差异 在于 front matter，hexo 使用 YAML 格式 ， 这 也 是 支持 最为 广泛 的 格式 。hugo 则 默认 是 toml， 但是 同时 可以 支持 yaml 和 json 格式 。 个人感觉 toml 格式 并 没有 多 大 的 方便 ， 倒 是 YAML 格式 支持 的 最为 广泛 ， 所以 我 还是 在 hugo 中 指定 了 使用 YAML 格式 的 front matter:metaDataFormat = \"yaml\" 但是 仅仅 这样 ， 还是 不能 直接 copy & paste， 因为 hexo 的 front matter 中 date 没有 包含 时 区 信息 而 hugo 则 需要 指定 。 直接 一篇 一篇 的 改 太 过 繁琐 ， 因此 我 写 了 一个 小 工具 来 做 这件 事 ，PS： 需要 先 安装 依赖  mkdirp、moment-timezone 和 gray-matter 。const fs = require(\"fs\");const { promisify } = require(\"util\");const moment = require(\"moment-timezone\");const matter = require(\"gray-matter\");const mkdirp = require(\"mkdirp-promise\");const timezone = \"Asia/Shanghai\";const src = \"hexo\";const target = \"hugo\";const readdir = promisify(fs.readdir);const readFile = promisify(fs.readFile);const writeFile = promisify(fs.writeFile);const log = console.log.bind(console);const indent = \"   \";function read(name) {  const path = ${src}/${name};  const opts = { encoding: \"utf8\" };  return readFile(path, opts).then(text => ({ name, text }));}function write(file) {  const path = ${target}/${file.name};  return mkdirp(target).then(_ => writeFile(path, file.text));}function check(file) {  file.text = file.text.trim();  if (!/^-{3}\\s*\\n/.test(file.text)) {    file.text = ---\\n${file.text};  }  if (!matter.test(file.text)) {    log(\"Ops,something wrong in file:\", file.name);    return false;  }  return true;}function convert(file) {  log(\"Starting to convert file\", file.name);  const { data, content } = matter(file.text);  // title  if (!data.title)    data.title = file.name      .replace(/\\.md$/, \"\")      .replace(/-/g, \" \")      .replace(/\\b[a-z]/g, m => m.toUpperCase());  log(indent, \"[title]\", data.title);  // date  data.date = moment    .tz(data.date ? new Date(data.date) : new Date(), timezone)    .format();  log(indent, \"[date]\", data.date);  // categories  if (data.categories) {    if (!Array.isArray(data.categories)) {      data.categories = [data.categories];    }    log(indent, \"[categories]\", data.categories);  }  //tags  if (data.tags) {    if (!Array.isArray(data.tags)) data.tags = [data.tags];    log(indent, \"[tags]\", data.tags);  }  file.text = matter.stringify(content, data);  log(\"Done\\n\");  return file;}function main() {  readdir(src)    .then(names => names.filter(name => /\\.md$/.test(name)))    .then(names => Promise.all(names.map(read)))    .then(files => files.filter(check))    .then(files => files.map(convert))    .then(files => Promise.all(files.map(write)))    .then(files => log(Converted ${files.length} files))    .catch(console.error);}main(); 主题 hugo 的 主题 大部分 都 是 非常 简陋 的 ， 看得出来 都 是 一群 后 端 程序员  😂， 看 了 一圈 没有 我 喜欢 的 ， 加上 自己 对 博客 主题 设计 有 一些 自己 的 想法 ， 于是 就 自己 动手 写 了 当前 这个 主题 。 取名 叫 canoe 吧 ， 有 特殊 的 纪念 意义 。 模版 类型 hugo 把 一个 博客 的 模版 归 总成 了 四大 类 ： index ,single,list,terms 分别 代表 首页 模版 、 详情 （ 文章 ） 页 模版 、 列表 页 模版 和 分类 页 模版 （categories、tags）。 而且 hugo 还 能 为 页面 定义 不同 的 类型 (type)， 不同 的 类型 可以 编写 不同 的 模版 ， 也 可以 fallback 到 默认 的 模版 ( 如 对于 类型 是 archive 的 文章 ， 首先 采用 的 是 archive\\signle.html  如果 前者 找 不到 则 会 采用 默认 的 文章 模版 _default\\single.html)。 文章 分类 文章 分类 在 hugo 中 是 一个 比较 抽象 的 概念 ， 统称 为 taxonomies， 是 一个 key-array 的 结构 ， 包括 categories 和 tags。 我们 可以 实现 terms.html 来 展示 某 一类 taxonomy 所 包含 的 文章 列表 。 前端开发 hugo 默认 只 提供 了 一个 高性能 的 livereload 服务器 。 但是 开发 主题 需要 用到 很多 前端 相关 的 流程 ， 包括 热 替换 、 前端 资源 预处理 和 后处理 等 等等 ， 所以 我 还是 引入 了 gulp 。 使用 了 一套 我 最 熟悉 的 技术 组合 ： 使用 typescript 和 rollup 来 编写 脚本 使用 sass  和 postcss 来 编写 样式 使用 browserSync 来 进行 热 替换 与 hugo 相关 的 gulp 任务 ：gulp.task(\"hugo\", cb => {  const prodArgs = [\"-d\", ./${devDir}];  const devArgs = [\"-d\", ./${devDir}, \"-w\", \"-b\", \"/.\"];  const hugo = cp.spawn(\"hugo\", env === \"dev\" ? devArgs : prodArgs);  hugo.stdout.on(\"data\", data => util.log(data.toString()));  hugo.stderr.on(\"data\", data => util.log(\"error: \", data.toString()));  hugo.on(\"exit\", code => {    util.log(\"hugo process exited with code\", code);    env !== \"dev\" && cb();  });  // env == dev is in watch mode  env === \"dev\" && cb();}); 延迟 加载 Valinewindow[\"VALINECONFIG\"] = {  el: '#comment',  notify: false,  verify: false,  appId: '{{ .valine.id }}',  appKey: '{{ .valine.key }}',  placeholder: '{{ .valine.placeholder }}',  path: window.location.pathname,  avatar: '{{ .valine.avatar }}'}function loadValine() {  const config = window[\"VALINECONFIG\"];  if (!config) return;  const urls = [${baseURL}/js/av-min.js, ${baseURL}/js/Valine.min.js];  const asyncloader = url =>    new Promise((resolve, reject) => {      const script = document.createElement(\"script\");      script.src = url;      script.addEventListener(\"load\", _ => resolve(), false);      script.addEventListener(\"error\", _ => reject(), false);      document.body.appendChild(script);    });  Promise.all(urls.map(asyncloader))    .then(() => new window\"Valine\")    .catch(e => U.log(\"load Valine Failed,\", e));} 搜索 hugo 在 官方 文档   提到 了 几种 实现 站点 搜索 的 方式 。 抛开 第三方 搜索 工具 不论 只 剩下 lunr 了 。 但是 lunr 需要 一个 索引 文件 ，hugo 没有 像 hexo 那样 的 hexo-generate-json-content 插件 （ 其实 它 压根 就 没有 插件 系统 ） 所以 到 最后 还是 用 Node 来 干 这件 事情 吧 ， 而且 刚好 我 已经 搭 好 了 一个 可用 的 gulp workflow 了 。 需要 注意 的 是 lunr 默认 不 支持 中文搜索 。 这 是 一个 非常 蛋 疼 问题 ， 网上 的 解决 方法 通常 是 这样 的 ：const trimmer = function(token) {  return token.update(str => {    if (/[\\u4E00-\\u9FA5\\uF900-\\uFA2D]/.test(str)) return str;    return str.replace(/^\\W+/, \"\").replace(/\\W+$/, \"\");  });};const lunr_zh = function() {  this.pipeline.reset();  this.pipeline.add(trimmer, lunr.stopWordFilter, lunr.stemmer);};lunr.Pipeline.registerFunction(trimmer, \"trimmer-zh\");//...const index = lunr(function() {  this.use(lunr_zh);  //...}); 这里 通过 注册 一个 自定义 的 trimmer  方法 来 避免 中文 字符 被 忽略 ， 分词 算法 应该 写 到 stemmer 函数 中 ， 但是 中文 分词 算法 并 不是 那么 几行 代码 就 能 搞定 的 ， 如果 全部 放到 线 上 的话 ， 会 极大 的 拖 慢 浏览器 的 加载 速度 。 因此 我们 只能 直接 沿用 原有 的 分词 算法 lunr.stemmer  在 本地 就 把 中文 分词 分 好 用 空格 分开 ， 这样 线 上 就 可 略 过分 词 这 一个 步骤 了 。 我 写 了 一个 工具 来 做 这个 ， 使用 了 nodejieba 库 ， 分词 速度 挺快 的 。 主要 逻辑 是 ：const matter = require(\"gray-matter\");const removeMd = require(\"remove-markdown\");const nodejieba = require(\"nodejieba\");// ...function parse(filename, option) {  const filepath = path.join(option.dir, filename);  const { name } = path.parse(filepath);  let { data:meta, content } = matter.read(filepath);  return {    uri:      path.join(option.contextPath, urlize(name)),    tags:     meta.tags || [],    content:  ChineseCut(removeMd(content)),    title:    ChineseCut(meta.title),    oriTitle: meta.title  };}function ChineseCut(str) {  return (    str &&    str      .replace(/\\n/gm, \"\")      .replace(        /[\\u4E00-\\u9FA5\\uF900-\\uFA2D]+/g,        match =>  ${nodejieba.cut(match).join(\" \")}       )  );} 主要 是 利用 gray-matter 这个 库 对 文档 内容 进行 解析 ， 然后 把 得到 的 content 和 title 字 段 使用 ChineseCut 方法 进行 分词 ， 将 分词 后 的 数组 重新 使用 空格 拼接 成 字符串 返回 ， 最后 得到 一个 文章 描述 对象 ， 包含 着 uri、tags、content、title 和 oriTitle  这 几个 字 段 。 动画 动画 绝大 情况 可以 使用 css3 transition 解决 ， 但是 还是 有 一些 css 无能为力 的 情况 。 比如说 章节 滚动 等 。 因此 我 用 requestAnimate 写 了 一个 简单 的 纯 动画 方法 ：class Animate {  private id = 0;  private active = {};  constructor() {}  private uniqKey() {    return ++this.id;  }  exec(    transform: Function,    duration: number,    easingFn: Function = linear,    cb?: Function  ) {    const key = this.uniqKey();    this.active[key] = true;    const start = performance.now();    const render = (now = performance.now()) => {      const delta = now - start;      if (!this.active[key] || delta >= duration) {        transform(1);        delete this.active[key];        cb && cb();        return;      }      transform(easingFn(delta / duration));      requestAnimationFrame(render);    };    requestAnimationFrame(render);  }  cancel(key: number) {    if (this.active[key] === true) {      this.active[key] = false;    }  }}//examplelet id = null;const animate = new Animate();// ... other animationconst el = document.querySelector('modal');const easeOutCubic = t => --t * t * t + 1;const transition = p => (el.style.opacity = ${p}),if(id) animate.cancel(id);id = animate.exec(transition, 200, easeOutCubic); 更 多 的 动画 函数 可以 参考 ： 部署 Github Pageshugo 官方 教程 是 通过 添加 一个 orphan 的 gh-pages 分支 ， 然后 使用 git worktree 特性 来 将 master 分支 里面 的 public 目录 定位 到 gh-pages 中 的 。 整个 过程 比较复杂 ， 部署 的 过程 中 需要 切换 工作 目录 。 所以 官方 也 提供 了 一个 shell 脚本 来 自动 干 这 事 。 我 这边 直接 使用 了 github 的 docs 文件夹 特性 。 在 config.toml 中 添加 一行 publishDir: docs 将 站点 文件 生成 至 docs 文件夹 下 ， 然后 直接 在 master 分支 中 开启 github page 就 好 了 。github 会 自动 部署 docs 文件夹 里面 的 静态 文件 。 绑定 域名 和 HTTPSGithub 绑定 域名 就 不 说 了 ， 主要 添加 两条 A 记录 ， 然后 在 Github 上 设置 一下 即可 。 但是 Github 绑定 域名 之后 无法 再 使用 https 了 （coding.net 说 起来 这点 还 挺 良心 的 ）， 目前 免费 的 解决方案 只能 使用 cloudflare 这种 cdn 了 。Netlify 使用 Github Pages 的 方式 主要 不足 是 每次 提交 站点 源码 之前 需要 自己 手动 在 本地 先 build 一下 ， 另外 使用 master/docs 的 方式 的话 还 会 污染 每次 的 提交 信息 。Netlify 是 一个 不错 的 选择 ， 连接 了 Github 之后 可以 像 TravisCL 那样 ， 持续 集成 部署 了 。 另一方面 ，Netlify 不仅 能够 绑定 域名 ， 提供 https 访问 ， 还 能 支持 HTTP/2 协议 ， 完全免费 ， 国内 速度 也 不错 。 官方网站 Forestry 这个 挺 强大 的 ， 像是 把 静态 博客 变成 了 一个 动态 博客 。 但是 环境 不能自己 配置 ， 不 太 适合 我 。 官方网站 ","title":"Hugo 使用 笔记 ","oriTitle":"Hugo使用笔记"},{"uri":"/posts/intro-of-fft","tags":["数论","只言片语"],"content":" 比如说 你 的 老板 命令 你 干活 ， 你 却 到 楼下 打 台球 去 了 ， 后来 被 老板 发现 ， 他 非常 气愤 ， 扇 了 你 一巴掌 （ 注意 ， 这 就是 输入 信号 ， 脉冲 ）， 于是 你 的 脸上 会 渐渐 地 （ 贱 贱 地 ） 鼓起来 一个包 ， 你 的 脸 就是 一个 系统 ， 而 鼓起来 的 包 就是 你 的 脸 对 巴掌 的 响应 ， 好 ， 这样 就 和 信号系统 建立 起来 意义 对应 的 联系 。 下面 还 需要 一些 假设 来 保证 论证 的 严谨 ： 假定 你 的 脸 是 线性 时 不变 系统 ， 也就是说 ， 无论 什么 时候 老板 打 你 一巴掌 ， 打 在 你 脸 的 同一 位置 （ 这 似乎 要求 你 的 脸 足够 光滑 ， 如果 你 说 你 长 了 很多 青春痘 ， 甚至 整个 脸皮 处处 连续 处处 不可 导 ， 那 难度 太 大 了 ， 我 就 无话可说 了 哈哈 ）， 你 的 脸上 总是 会 在 相同 的 时间 间隔 内 鼓起来 一个 相同 高度 的 包 来 ， 并且 假定 以 鼓起来 的 包 的 大小 作为 系统 输出 。 好 了 ， 那么 ， 下面 可以 进入 核心内容 —— 卷积 了 ！ 如果 你 每天 都 到 地 下去 打 台球 ， 那么 老板 每天 都 要 扇 你 一巴掌 ， 不过 当 老板 打 你 一巴掌 后 ， 你 5 分钟 就 消肿 了 ， 所以 时间 长 了 ， 你 甚至 就 适应 这种 生活 了 …… 如果 有 一天 ， 老板 忍无可忍 ， 以 0.5 秒 的 间隔 开始 不间断 的 扇 你 的 过程 ， 这样 问题 就 来 了 ， 第一次 扇 你 鼓起来 的 包 还 没 消肿 ， 第二个 巴掌 就 来 了 ， 你 脸上 的 包 就 可能 鼓起来 两倍 高 ， 老板 不断 扇 你 ， 脉冲 不断 作用 在 你 脸上 ， 效果 不断 叠加 了 ， 这样 这些 效果 就 可以 求和 了 ， 结果 就是 你 脸上 的 包 的 高度 随 时间 变化 的 一个 函数 了 （ 注意 理解 ）； 如果 老板 再 狠 一点 ， 频率 越来越 高 ， 以至于 你 都 辨别 不 清 时间 间隔 了 ， 那么 ， 求和 就 变成 积分 了 。 可以 这样 理解 ， 在 这个 过程 中 的 某 一 固定 的 时刻 ， 你 的 脸上 的 包 的 鼓起 程度 和 什么 有关 呢 ？ 和 之前 每次 打 你 都 有关 ！ 但是 各 次 的 贡献 是 不 一样 的 ， 越 早 打 的 巴掌 ， 贡献 越 小 ， 所以 这就是说 ， 某 一 时刻 的 输出 是 之前 很 多次 输入 乘以 各自 的 衰减系数 之后 的 叠加 而 形成 某 一点 的 输出 ， 然后 再 把 不同 时刻 的 输出 点 放在 一起 ， 形成 一个 函数 ， 这 就是 卷积 ， 卷积 之后 的 函数 就是 你 脸上 的 包 的 大小 随 时间 变化 的 函数 。 本来 你 的 包 几分钟 就 可以 消肿 ， 可是 如果 连续 打 ， 几个 小时 也 消 不了 肿 了 ， 这 难道 不是 一种 平滑 过程 么 ？ 反映 到 剑桥大学 的 公式 上 ，f(a) 就是 第 a 个 巴掌 ，g(x-a) 就是 第 a 个 巴掌 在 x 时刻 的 作用 程度 ， 乘起来 再 叠加 就 ok 了 ， 大家 说 是不是 这个 道理 呢 ？ 我 想 这个 例子 已经 非常 形象 了 ， 你 对 卷积 有 了 更加 具体 深刻 的 了解 了 吗 ？ 转 自 GSDzone 论坛 ","title":"（ 转 ） 关于 卷积 的 一个 血腥 的 讲解 ， 看 完 给 跪 了 ","oriTitle":"（转）关于卷积的一个血腥的讲解，看完给跪了"},{"uri":"/posts/kde-to-mac","tags":["DE/WM"],"content":" 惯例 ， 先 上 图 ： 首先 ，KDE 的 全局 菜单 可以 参考 我 以前 的 文章 《KDE4 的 配置 参考 》。 然后 ，Plasma 的 主题 是 AG-plasma，aurorae 主题 是 Yoxydaze-light。 这些 可以 去 kde-look 里 找 。 底部 的 dock 是 plank， 主题 是 ArHU， 在 deviantART 中 找到 的 。 另外 ，plank 上 的 图标 是 受 gtk 主题 控制 的 ， 所以 装 numix-circle 是 最好 不过 的 。 我 的 apps 文件 可以 在 这里 下载 ：click here~/.config/plank/dock1/settings 文件 ：#This file auto-generated by Plank.#2014-12-06T09:47:52+0000[PlankDockPreferences]#Whether to show only windows of the current workspace.CurrentWorkspaceOnly=false#The size of dock icons (in pixels).IconSize=42#If 0, the dock won't hide. If 1, the dock intelligently hides. If 2, the dock auto-hides. If 3, the dock dodges active maximized windows.HideMode=0#Time (in ms) to wait before unhiding the dock.UnhideDelay=0#The monitor number for the dock. Use -1 to keep on the primary monitor.Monitor=-1#List of *.dockitem files on this dock. DO NOT MODIFYDockItems=plank.dockitem;;google-chrome.dockitem;;dolphin.dockitem;;juk.dockitem;;eclipse.dockitem;;chrome-pjkebmlmkppdjcdcilfcjdkifljollfd-Default.dockitem;;kate.dockitem;;gwenview.dockitem;;wps-office-wps.dockitem;;konsole.dockitem;;sublimetext3.dockitem;;love-wallpaper.dockitem;;ksysguard.dockitem;;virtualbox.dockitem#The position for the dock on the monitor. If 0, left. If 1, right. If 2, top. If 3, bottom.Position=3#The dock's position offset from center (in percent).Offset=0#The name of the dock's theme to use.Theme=ArHU#The alignment for the dock on the monitor's edge. If 0, panel-mode. If 1, left-aligned. If 2, right-aligned. If 3, centered.Alignment=3#The alignment of the items in this dock if panel-mode is used. If 1, left-aligned. If 2, right-aligned. If 3, centered.ItemsAlignment=3#Whether to prevent drag'n'drop actions and lock items on the dock.LockItems=false#Whether to use pressure-based revealing of the dock if the support is available.PressureReveal=false#Whether to show only pinned applications. Useful for running more then one dock.PinnedOnly=true#Whether to automatically pin an application if it seems useful to do.AutoPinning=true~/.local/share/plank/themes/ArHU/ 中 的 dock.theme 和 hover.theme 文件 分别 是 ：#This file auto-generated by Plank.#2014-12-06T06:22:37+0000[PlankDrawingTheme]#The roundness of the top corners.TopRoundness=6#The roundness of the bottom corners.BottomRoundness=0#The thickness (in pixels) of lines drawn.LineWidth=0#The color (RGBA) of the outer stroke.OuterStrokeColor=0;;0;;0;;0#The starting color (RGBA) of the fill gradient.FillStartColor=255;;255;;255;;150#The ending color (RGBA) of the fill gradient.FillEndColor=255;;255;;255;;150#The color (RGBA) of the inner stroke.InnerStrokeColor=255;;255;;255;;255[PlankDrawingDockTheme]#The padding on the left/right dock edges, in tenths of a percent of IconSize.HorizPadding=0#The padding on the top dock edge, in tenths of a percent of IconSize.TopPadding=1#The padding on the bottom dock edge, in tenths of a percent of IconSize.BottomPadding=1#The padding between items on the dock, in tenths of a percent of IconSize.ItemPadding=4#The size of item indicators, in tenths of a percent of IconSize.IndicatorSize=0#The size of the icon-shadow behind every item, in tenths of a percent of IconSize.IconShadowSize=0#The height (in percent of IconSize) to bounce an icon when the application sets urgent.UrgentBounceHeight=0.10000000000000001#The height (in percent of IconSize) to bounce an icon when launching an application.LaunchBounceHeight=0.10000000000000001#The opacity value (0 to 1) to fade the dock to when hiding it.FadeOpacity=0#The amount of time (in ms) for click animations.ClickTime=150#The amount of time (in ms) to bounce an urgent icon.UrgentBounceTime=300#The amount of time (in ms) to bounce an icon when launching an application.LaunchBounceTime=300#The amount of time (in ms) for active window indicator animations.ActiveTime=150#The amount of time (in ms) to slide icons into/out of the dock.SlideTime=150#The time (in ms) to fade the dock in/out on a hide (if FadeOpacity is &lt; 1).FadeTime=100#The time (in ms) to slide the dock in/out on a hide (if FadeOpacity is 1).HideTime=100#The size of the urgent glow (shown when dock is hidden), in tenths of a percent of IconSize.GlowSize=30#The total time (in ms) to show the hidden-dock urgent glow.GlowTime=10000#The time (in ms) of each pulse of the hidden-dock urgent glow.GlowPulseTime=2000#The hue-shift (-180 to 180) of the urgent indicator color.UrgentHueShift=150#The time (in ms) to move an item to its new position.ItemMoveTime=150#This theme written by Perian. thexperian.deviantart.com[PlankDrawingTheme]TopRoundness=3LineWidth=0OuterStrokeColor=0;;0;;0;;0FillStartColor=0;;0;;0;;150FillEndColor=0;;0;;0;;150InnerStrokeColor=0;;0;;0;;0 以上 是 我 折腾 的 结果 ， 找 主题 也 找 了 半天 。 大家 如果 有 更好 的 主题 与 壁纸 也 拿来 分享 一下 吧 。","title":"KDE 的 Mac 向 折腾 指南 ","oriTitle":"KDE的Mac向折腾指南"},{"uri":"/posts/kde4-config","tags":["DE/WM"],"content":" 西北 工大 回来 后 , 时间 又 充裕 了 , 所以 又 开始 了 折腾 KDE。 话 说 KDE 的 渲染 阴影 等 效果 非常 接近 MacBook。 先 放 几张 图 ： 下面 说 一下 ， 我 的 配置 过程 ： 发行版 ：      我 的 发行版 是 Arch， 没有 Arch 强大 的 AUR， 很多 桌面 的 配件 很 难 装 上 。 主题 ：      我 的 plasma 主题 是 Helium 与 dynamo 主题 混合 而 成 。 标题栏 主题 是 Qtcurve， 图标 主题 是 dynamo 与 flattr 混合 而 成 ， 鼠标 主题 是 Breeze。 应用程序 主题 是 Qtcurve， 配色 是 Breeze。 这些 都 可以 到 这里 下载 。 先 安装 qtcurve 再 将 下载 下来 的 文件 解压 并 覆盖 ～/.kde4/share/ 即可 。 注意 ，Qtcurve 的 配置 方案 是 Breeze， 并且 在 窗口 管理器 中 设置 边框 大小 是 无 侧 边框 。 全局 菜单 ：      全局 菜单 可以 先 加 archlinuxcn 源 ， 然后 依次 用 yaourt 安装 appmenu-qt,appmenu-qt5,appmenu-gtk,kdeplasma-applets-menubar。 完成 之后 在 面板 上 添加 刚 安装 的 部件 再 打开 “ 系统 设置 &gt; 应用程序 外观 &gt; 风格 ” 然后 选择 微调 标签 ， 修改 “ 菜单栏 风格 ” 为 “ 仅 导出 ” 就 能 有 全局 菜单 了 。 最大化 隐藏 菜单栏 ：      最大化 隐藏 菜单栏 可以 直接 在 qtCurve 中 配置 ， 依然 在 “ 窗口 管理器 ” 中 ， 勾 选 “ 最大化 窗口 无 边框 ” 复选框 即可 。 最大化 上 面板 显示 窗口 控制 按钮 ：（ 最后 一张 图 鼠标 所指 的 地方 ）      在 AUR 中 安装 kdeplasma-applets-kwin-button-improved， 然后 在 面板 上 重复 三次 添加 这个 部件 ， 分别 设置 为 最小化 （iconify）， 最大化 / 回复 （maximize/restore） 和 关闭 （close） 就行了 。","title":"KDE4 的 配置 参考 ","oriTitle":"KDE4的配置参考"},{"uri":"/posts/man-man-de","tags":["只言片语"],"content":" 几年 以前 ， 我 曾经 嘲笑 过 某 科技界 大佬 。 当时 他 说 ： 也许 90 后 、95 后 会 慢慢 不 知道 谷 歌 是 什么 网站 。　　 那 一年 ， 这 对于 我 来说 简直 就是 世界 上 最好 笑 的 笑话 。 谷 歌 ， 全世界 最 卓越 的 互联网 公司 ， 活 在 互联网 的 一代 中国 人 ， 会 不 知道 他们 的 网站 ？　　 今天 ， 我 收回 这 句 嘲笑 。 因为 这件 不 可能 的 事 ， 它 慢慢 变成 了 现实 。　　 没有 人 再 关注 什么 谷 歌 不 谷 歌 。 对 他们 来说 ， 百度 也 蛮 好 用 的 ， 反正 他们 几乎 没用过 谷 歌 。 没有 谷 歌 又 怎样 ？ 大家 还是 开心 的 刷 微 博 ， 看 微 信 ， 听歌 ， 看 娱乐节目 。 对于 从来 就 不 知道 谷 歌 的 人 来说 ， 少 了 谷 歌 又 有 什么 影响 ？　　 多年 前 ， 我们 也 是 可以 登陆 Facebook 的 。 其实 这个 网站 和 校内 一样 ， 也 挺 蠢 的 。 可 在 上面 你 能 看到 老外 们 的 生活 ， 可以 轻易 的 跟 一万公里 以外 的 人 互相 拜访 ， 可以 看到 很多 根本 不会 开 到 校内 上 的 主页 。 你 用 汉语 回复 ， 下面 给 你 聊起来 的 可能 是 香港 仔 ， 可能 是 台湾人 。 你 用 英语 回复 ， 说不定 有 比 你 英语 用 的 更 蹩脚 的 寂寞 的 北欧 人 来 跟 你 搭讪 。 你 感觉 地球 真的 变成 了 地球村 ， 你 还 没 拉门 走 出去 ， 别人 就 推 门 走 了 进来 。　　 然后 ， 它 就 没有 了 。 起初 ， 它 的 失踪 激起 了 很大 的 声音 ， 后来 ， 声音 就 消失 了 。　　 多年 前 ， 我们 也 是 可以 登陆 Twitter 的 。 其实 这个 网站 和 微 博 一样 ， 也 不过 是 些 信息流 ， 刷 上 一整天 ， 也 不见得 有 什么 用处 。 但 至少 ， 你 可以 以 最快 速度 获取 你 想 知道 的 任何 新 事 ， 你 会 真正 了解 什么 事情 在 全世界 是 流行 的 ， 而 不是 经过 各种 截图 、 翻译 、 转发 ， 甚至 曲解 、 断章取义 、 黑白 颠倒 的 东西 。 你 知道 的 是 真相 ， 赤裸裸 的 ， 也许 有点 太短 的 真相 。 但 至少 中间 不会 有 无数 人 的 加工 与 再 加工 ， 偏激 、 片面 ， 就 在 这个 过程 中 产生 了 ， 不管 后来者 有意 还是 无意 。　　 然后 ， 它 就 没有 了 。 首先 是 它 的 本体 没有 了 ， 然后 它 的 模仿者 也 没有 了 ， 模仿者 的 模仿者 也 没有 了 。 只 剩 一个 模仿者 的 模仿者 的 模仿者 ， 现在 你 每天 能 在 上面 看到 无数 广告 。　　 多年 前 ， 我们 也 是 可以 登陆 YouTube 的 。 对于 有 的 人 来说 ， 这个 网站 就是 个 大型 优 酷 ， 当年 有人 信誓旦旦 的 说 ， 没有 YouTube， 我们 中国 人 会 很快 让 优 酷 超过 YouTube。 可 这么 多年 过去 了 ， 视频 还是 那么 卡 ， 内容 还是 那么 垃圾 ， 原创 还是 那么 容易 被 盗窃 ， 视频 丰富 度 还是 那么 的 可怜 。 在 YouTube 上 ， 你 能 看到 全世界 最 棒 的 手艺人 ， 最 逗乐 的 笑话 ， 最 天马行空 的 创意 ， 最 激荡 人心 的 音乐 ， 最 美好 的 完美 瞬间 ， 可 在 优 酷 上 ， 你 想 看 一分钟 视频 ， 请 先 看 半分钟 广告 。　　 哦 ， 对 了 。Instagram， 有些 人 可能 感觉 它 和 QQ 空间 也 差不多 。 可 我 在 上面 关注 了 六百多个 摄影师 ， 它们 都 是 顶 好 顶 好 的 影像 记录 者 ， 每天 看 他们 的 作品 ， 我 感觉 到 很 幸福 ， 那种 即使 没有 到 那里 去 ， 也 身临其境 的 幸福 。 我 还 在 上面 认识 了 一个 日本 的 爱 自 拍 的 帅小伙 ， 一个 爱 喝酒 的 韩国 大叔 ， 一个 十年 前 到 过 中国 今天 会 在 每张 我 发 的 紫禁城 照片 下 点 赞 的 美国 大爷 ， 一个 美丽 无比 的 俄罗斯 妹子 ， 我 和 他们 基本上 都 难以 交流 ， 语言 是 很大 的 障碍 ， 但 几个 简单 的 单词 ， 心意 也 就 到 了 ， 这种 感觉 ， 有时候 比 多年 老友 相聚 还 兴奋 。 因为 这 是 人类 不同 族群 自由 交流 互相 沟通 的 过程 ， 这种 过程 很 神奇 ， 真的 很 神奇 。　　 可 现在 ， 它 没有 了 ， 它 之所以 没有 就 因为 在 某个 特定 的 时间 你 在 搜索 特定 的 词汇 时 ， 会 搜 出来 特定 的 照片 。 虽然 这么 搜 的 人 并不多 ， 虽然 看到 的 人 也 不会 大惊小怪 ， 也 不会 觉得 天黑 了 ， 天亮 了 ， 天 要 塌 了 ， 天 要 变 了 。 可 它 就是 没 了 ，Instagram， 就 这么 没 了 。 谷 歌 也 是 这么 没 的 ，Twitter 也 是 这么 没 的 ，Facebook 也 是 这么 没 的 。 不 知道 是 什么 人 ， 在 什么 场合 ， 说 了 什么 话 ， 下 了 什么 决定 。 就要 有 超过 十亿 人 像 陷于 哥 谭 市 的 孤岛 里 一样 ， 看着 一座 又 一座 桥梁 被 炸掉 ， 又 被 炸掉 ， 又 被 炸掉 ， 然后 ， 就 什么 都 没 了 。　　 我 时常 觉得 悲哀 ， 真的 好 悲哀 ， 一个 我 根本 不 认识 也 不 知道 是 谁 的 人 ， 也许 是 一个 群体 ， 在 不断 抢走 我 身边 的 东西 ， 而 我 却 无能为力 。 我 抱怨 一声 ， 他 听 不到 ， 任何人 都 听 不到 。 我 怒吼 一句 ， 身边 的 大多数 人 却 像 看 疯子 一样 的 看着 我 。 我 哀嚎 一声 ， 这 声音 被 阻碍 在 黑黑的 幕墙 以 里 。 我 发出 尖锐 的 嘶吼 ， 这 声音 传 不了 多 远 ， 就 和 我 那 被 抢走 的 东西 一样 ， 消失 了 ， 不见 了 ， 就 像 从来 没 存在 过 一样 。　　 对于 本来 就 没 存在 过 的 东西 ， 有 谁 又 会 觉得 在意 呢 ？ 那些 本来 拥有 又 被 掠夺 的 人 的 哀愁 ， 后来 的 人 又 怎么 懂 呢 ？ 我 曾经 是 拥有 一切 的 ， 我 曾经 是 拥有 世界 的 ， 我 站 在 这 片 土地 上 ， 呼吸 的 是 自由 的 空气 ， 饮 下 的 是 自由 的 琼浆玉液 。 就 在 长 的 无法 计数 的 时间 里 ， 我 自由 生命 的 一部分 又 一部分 就 这么 被 杀死 了 ， 突然 就 杀死 了 。 可 我 还 始终 觉得 ， 它们 还 奄奄一息 的 活着 ， 就 像 它们 是 慢慢 的 死去 的 一样 。　　 可 它们 终归是 死 了 ， 而且 随着 它们 的 死 ， 愈来愈多 的 事情 慢慢 的 发生 了 ， 很 慢 很 慢 ， 几乎 不 被 人 察觉 ， 可 还是 发生 了 。　　 没有 谷 歌 ， 我 可以 用 百度 呀 。 可 某些 结果 被 越 挪 越 后 ， 越 挪 越 后 ， 最后 就 不见 了 。 就 像 本来 就 不该 搜 出 这个 结果 一样 。　　 没有 Facebook， 我 可以 用 校内 呀 。 可 你 想 发 只有 在 Facebook 上 能 发 的 文章 ， 很快 在 校内 上 就 失踪 了 。 接着 ， 校内 变成 了 人人 ， 话题 变成 了 人人 都 关心 的 话题 。 大家 都 在 抢 着 看 星座 、 明星 、 八卦 、 娱乐 。 没有 人 会 关心 什么 消失 了 ， 反正 它们 本来 也 没 多少 存在 感 。　　 没有 YouTube， 我 可以 用 优 酷 呀 。 可 你 却 经常 只能 在 优 酷 上 看到 抄袭 别人 的 作品 ， 而且 还 不 署名 ， 而且 还 洋洋得意 ， 而且 还 自我陶醉 ， 就 好像 那个 idea 本来 属于 他 自己 一样 。 你 看 了 还要 惊呼 ， 他 是 如此 的 有 创意 ！ 好 一个 抄袭 的 创意 ， 可 你 却 不 知道 ， 因为 你 不 知道 这个 世界 上 有 个 网站 叫 YouTube。　　 没有 Twitter， 我 还 可以 用 微 博 呀 。 可 你 想 知道 最近 发生 了 什么 ， 你 搜 的 越 勤快 ， 越 能 看到 越 明显 的 “ 根据 相关 法律法规 ， 相关 搜索 结果 不予 显示 ”。 时间 长 了 ， 你 想 ， 反正 知道 了 也 没什么 用 ， 不如 不 看 了 。　　 慢慢 的 ， 一扇 又 一扇 的 门 关上 了 。 今天 你 打开 世界 上 最大 的 博客 网站 ， 发现 它 没 了 。 明天 你 一 看 ， 世界 上 最好 的 设计师 分享 网站 没 了 ， 一 开始 是 刷新 的 很 慢 很 慢 ， 后来 它 就 没 了 。 过 两天 再 一 看 ， 平常 每天 都 会 读 两篇 文章 的 媒体 网站 没 了 ， 那里 的 文章 缤纷多彩 ， 最后 都 变成 了 该页 无法 显示 几个 字 。 再 过 几个 月 ， 大学 的 网站 不让 上 了 ， 摄影师 的 网站 不让 上 了 ， 就 连 百度 日本 这种 自家 网站 ， 也 没 了 。　　 接着 ， 漫画 看 不了 了 ， 接着 ， 动画 看 不成 了 。 接着 ， 美 剧 英 剧 失踪 了 。 下载 美 剧 英 剧 的 网站 又 又 又 失踪 了 。 尊重 正版 ， 保护 权益 ， 行 吧 ， 然后 字幕 网站 也 没 了 。　　 游戏 没 了 ， 你 习惯性 登陆 的 游戏 网站 ， 发现 下载 栏 正在 整治 中 。 论坛 关 了 ， 天天 都 在 看 的 论坛 ， 突然 接到 相关 部门 的 电话 ， 因为 “ 报备 问题 ” 不让 办 了 。 个人 网站 ， 私人 博客 ， 对不起 ， 说 没 就 没有 ， 你 在 上面 存 了 多少 多年 辛勤耕耘 的 东西 都 没用 。　　 你 关注 的 人 ， 有 一天 你 登陆 微 博 ， 发现 他 怎么 好久 都 没 说话 了 ， 然后 你 搜索 了 一下 ， 发现 他 的 账号 不 存在 了 ， 而且 你 搜 他 的 名字 ， 他 的 名字 未予 显示 。　　 一盏 一盏 的 灯 ， 灭 了 。 四面八方 的 光源 ， 消失 了 。 我们 生活 的 五光十色 的 世界 ， 变成 了 一片 黑色 。　　 天黑 了 ， 那么 睡觉 吧 ， 但愿 长 醉 不 复 醒 。　　 最后 ， 我们 变成 了 一群 做梦 的 人 ， 这个 梦 的 名字 ， 叫 根据 相关 法律法规 ， 相关 搜索 结果 不予 显示 梦 。　　 作者 ： 小海 ， 来源 ： 豆瓣 网 ， 原文 已 被 和谐 ","title":"( 转 ) 慢慢 的 ， 就 没有 了 ， 就 像 从未 存在 过 ","oriTitle":"(转)慢慢的，就没有了，就像从未存在过"},{"uri":"/posts/netease-music-api","tags":["网易云音乐","API","Encryption"],"content":" 新 API 采用 了 略微 修改 过 的 AES 和 RSA 加密 ， 主要 用 在 登陆 接口 上 ， 对 新 API 进行 简单 的 分析 。Url 估计 会 抓 包 的 人 都 知道 ，Url 中 的 api 便 成 了 weapi。 比如 手机 登录 ： 原来 是 ：http://music.163.com/api/login/cellphone/ 现在 是 ：http://music.163.com/weapi/login/cellphone/ 加密算法 核心 过程 如下 ： aesRsaEncrypt = function (text, pubKey, modulus, nonce) {  const secKey = createSecretKey(16);  //  随机 生成 16 位 加密 密钥   return {\tparams:  aesEncrypt(aesEncrypt(text, nonce), secKey),\tencSecKey: rsaEncrypt(secKey, pubKey, modulus)  }}{\tText : \"JSON.stringify({phone:xxx,password:\"md5 hashed Data\",rememberLogin:\"true\"})\" // 需要 加密 的 post body\tpubKey : \"010001\"\tnonce : \"0CoJUm6Qyw8W8jud\"\tmodulus : \"00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7\"} 一些 细节 AES 加密 的 具体 算法 为 :AES-128-CBC， 输出 格式 为 base64。AES 加密 时 需要 指定 iv：0102030405060708RSA 加密 输出 为 Hex 格式 ， 公 钥 是 {N:modulus,e:pubKey} 我 的 Javascript 实现 ：CryptoRSA 算法 的 JS 实现 方法 参考 ：","title":" 网易 云 音乐 新 API 简述 ","oriTitle":"网易云音乐新API简述"},{"uri":"/posts/neutron-code","tags":["openstack","neutron"],"content":" 消息 总线 Openstack 各 项目 之间 通过 RESTful API 进行 通信 ； 而 项目 内部 不同 服务 进程 则 需要 通过 消息 总线 通信 。 关于 消息 总线 的 实现 ， 包含 在 Openstack.oslo.messaging 库 中 。RPC 远程 过程 调用 ， 一个 服务 进程 可以 调用 其他 远程 服务 进程 的 方法 ， 有 两种 方式 ：call  远程 方法 会 被 同步 执行 ， 调用者 会 阻塞 直到 取得 返回 结果 。cast  远程 方法 会 被 异步 执行 ， 调用者 需要 通过 其他 方式 查询 这次 远程 调用 的 结果 。 事件 通知 (Event Notification) 服务 可以 把 事件 通知 发到 消息 总线 上 ， 该 消息 总线 上 所有 对 此类 事件 感兴趣 的 服务 进程 ， 都 可以 获得 次 事件 通知 并 进行 处理 。 处理结果 不会 返回 事件 发送者 。AMQPAMQP 是 一个 异步 消息传递 所 使用 的 开放 的 应用层 协议 规范 。 包括 导向 、 队列 、 路由 、 可靠性 和 安全性 。 不同 的 AMQP 实现 可以 进行 相互 操作 。 所有 消息 都 有 一个 routing key, 所有 Queue 都 有 一个 binding key。 生产者 将 消息 发送给 Exchange, 然后 Exchange 根据 这 两个 key 把 消息 送到 相匹配 的 Queue 中 。 不同 类型 的 Exchange 有 不同 的 匹配 算法 。| 类型 | 说明 ||:---|:---||Direct|binding key 和 routing key 必须 完全 一样 ， 不 支持 通配符 ||Topic| 同 Direct 类型 ， 但是 支持 通配符 ，\"*\" 匹配 单字 ，“#” 匹配 零个 或 多个 单字 ， 单字 之间 由 “.” 来 分割 ||Fanout| 忽略 binding key 和 routing key， 广播式 路由 |WSGIWSGI  是 一个 连接 服务端 和 应用 端的 接口 。WSGI 把 Web 组件 分为 三 部分 ：WSGI ServerWSGI MiddlewareWSGI ApplicationAn Application must return an iterable object.def application(environ,start_response):   start_response('200 Ok',[('Content-Type','text/plain')])   yield 'Hello World\\n'environ: 一个 dict， 包括 CGI 中 定义 的 环境变量 以及 7 个 WSGI 所 定义 的 环境变量 ：wsgi.version,wsgi_input...start_response:  回调 函数 ， 要 返回 一个 write(data) 对象 ， 用作 兼容 现有 的 特殊 框架 ， 一般 返回 NonePaste.DeployPaste Deploy 通过 api-paste.ini 配置 Paste 配置文件 分为 多个 section， 每个 section 以 type:name 的 格式 命名 。（ 书上 P99）WebOb 对 WSGI 的 封装 ， 包含 ：webob.Request  对 WSGI 的 environ 的 封装 webob.Response  对 WSGI 响应 的 封装 webob.exc  对 HTTP 错误代码 的 封装 Webob 提供 了 webob.dec.wsgify 的 decorator， 可以 快速 开发 application 继承 自 webob.Requestclass MyRequest(webob.Request):    @property    def is_local(self):        return self.remote_addr == '127.0.0.1'@wsgify(RequestClass=MyRequest)def myfunc(req):    if req.is_local:        return Response('hi!')    else:        raise webob.exc.HTTPForbiddenEventletOpenstack 的 协 程 模块 协 程 与 线程 类似 ， 拥有 独立 的 栈 和 局部变量 ， 但是 无法 同时 执行 ，(Compare To: Javascript callback)GreenThreadimport eventletdef my_func(param):do something in coroutine    return paramgt = eventlet.spawn(my_func,param)result = gt.wait()eventlet.spawn 只是 创建 一个 协 程 并 不 立即 执行 ， 直到 主线 程 运行 到 gt.wait() 时 才 开始 进入 调度 序列 。Monkey Path 实现 协 程 需要 使用 Patch 的 方式 对 Python 的 网络 相关 的 标准 库 进行 改写 ， 这个 patch 就 叫 monkey_patch。Monkey Patch 是 大部分 使用 Eventlet 函数库 之前 需要 进行 的 初始化 工作 ceilometer/cmd/init.pyimport eventletpatch socket,select,thread 三个 模块 eventlet.monkey_patch(socket=True,select=True,thread=True)OsloOpenstack  通用 库 Cliff 构建 命令行 程序 DEMO:oslo.config 解析 命令行 和 配置文件 中 的 配置 选项 （ 书上 P111）from oslo.config import cfgconf(sys.argv[1:],project=xyz) #  初始化 ， 使得 oslo.config 能够 正常 解析 配置文件 和 命令行 选项 rabbit_group = cfg.OptGroup(name='rabbit',                            title='RabbitMQ options')rabbithostopt = cfg.StrOpt('host',                             default='localhost',                             help='IP/hostname to listen on.'),rabbitportopt = cfg.PortOpt('port',                              default=5672,                              help='Port number to listen on.')def registerrabbitopts(conf):    conf.registergroup(rabbitgroup)options can be registered under a group in either of these ways:    conf.registeropt(rabbithostopt, group=rabbitgroup)    conf.registeropt(rabbitport_opt, group='rabbit') 如果 没有 指定 group， 则 选项 默认 放在 [DEFAULT] 组 下 glance-api.conf:  [DEFAULT]  bind_port = 9292...  [rabbit]  host = localhost  port = 5672  use_ssl = False  userid = guest  password = guest  virtual_host = / 从 命令行 中 设置 conf， 需要 使用 使用 ‘-’ 连接 groupname 和 optionname--rabbit-host localhost --rabbit-port 9999oslo.dbSQLAlchemy 数据库 模型 的 抽象 oslo.i18n 是 对 Python gettext 的 封装 ， 主要 用于 字符串 翻译 和 国际化 oslo.messagingOpenstack 各 项目 使用 RPC 和 事件 通知 的 统一 的 接口 。 其中 包括 下面 4 个 对象 。Transport 传输层 ， 主要 实现 RPC 底层 的 通信 ， 支持 rabbit、qpid、zmq 三种 协议 。 可以 通过 URL 来 指定 不同 的 transport 的 实现 。transport://user:pass@host1:port[,hostN:portN]/virtual_hostTarget 封装 了 指定 某 一 消息 最终 目的地 的 所有 信息 Server 即 服务端 ， 创建 一个 Server 对象 需要 指定 Transport、Target、endpoints( 包含 多组 可 被 远程 调用 的 方法 ， 比如 某 一 资源 包含 CUID 四个 操作 ）RPC Client 即 客户端 ， 一个 RPC Client 可以 调用 RPC Server 上 的 方法 。NotifierNotifier 是 一个 用来 发送 通知 消息 的 对象 。 格式 如下 ：{    messageid:sixtext_type(uuid.uuid4()), # 消息 id 号     publisher_id:'computer.host1',# 发送者 id    timestamp:timeutils.utcnow(),# 时间 戳     priority:'WARN', #  通知 优先级     eventtype:'compute.createinstance',# 通知 类型     payload:{'instance_id':12,...} # 通知 内容 }Notifier Listener 消息 监听 者 ， 跟 Server 类似 ， 可以 暴露 多个 endpoint， 每个 endpoint 中 也 可以 包含 多种 方法 ， 但是 它们 只是 对应 者 不同 的 消息 优先级 。（P118）","title":"neutron 源码 分析 ","oriTitle":"neutron源码分析"},{"uri":"/posts/online-exam-of-netease-game","tags":["招聘","网易","LCS","暴力"],"content":" 今天 做 了 一下 网易 互 娱 测 开 的 校 招 笔试 ， 感觉 题目 挺 简单 的 ， 比 隔壁 不 招 人 的 阿里 笔试 正常 不少 ， 可惜 我 多年 不 写 代码 正确率 和 手 速 明显 跟不上 了 , ToT.... 勇士 屠龙 第一 题 ， 真 简单 ， 直接 lower_bound 暴力 吧 。#include#include#include#include#includeusing namespace std;int n, m;vectora, b;int main() {\tint x;\twhile (cin >> n >> m) {\t\ta.clear();\t\tb.clear();\t\tfor (int i = 0; i > x;\t\t\ta.push_back(x);\t\t}\t\tfor (int i = 0; i > x;\t\t\tb.push_back(x);\t\t}\t\tint sum = 0;\t\tsort(b.begin(),b.end());\t\tfor (int i = 0; i   首先 排除 掉 va，vb 为 0 的 情况 ， 不然 会 爆 掉 。>>  然后 ， 如果 是 在 A 端点 相遇 ， 那么 b 走 到 A 端点 所 要 走 的 路程 是 1s 、3s、5s... 一直 到 他 能 走 的 最大 路程 tvb， a 则 是 2s、4s、6s... 一直 到 tva>>  然后 ， 他俩 所有 走 所有 路程 所 花费 的 时间 全部 算 出来 ， 相等 的 有 多少 个 就 有 多少 次 相遇 。 如果 怕 浮点数 相等 有 误差 的话 ， 可以 将 所有 的 时间 乘以 va*vb 这样 算 出来 都 是 整数 了 。 用 一个 map 判 一下 重 即可 。#include#include#include#includeusing namespace std;int s, va, vb, t;int calc(int va,int vb) {\tint sum = 0;\tmap tmp;\tfor (int i = 1;; i++) {\t\tint len = 2 * i * s;\t\tif ( len > t * vb) break;\t\ttmp[ len * va] = true;\t}\tfor (int i = 0;; i++) {\t\tint len = (2 * i + 1) * s;\t\tif (len> t * va)break;\t\tif (tmp.find( len * vb)!=tmp.end()) sum++;\t}\treturn sum;}int main() {\twhile (cin >> s >> va >> vb >> t) {\t\tint sum = 0;\t\tif (va == 0) {\t\t\tcout#include#include#include#include#includeusing namespace std;int n, m;string str1, str2;int main() {\twhile (cin >> n >> m >> str1 >> str2) {\t\tvector> f = vector>(n + 1, vector(m + 1));\t\tfor (int i = 0; i#include#include#include#includeusing namespace std;string str;string out(string str) {\tint len = str.length();\tint start = 0;\twhile (start = 0; i--) {\t\tif (!isdigit(str[i]))break;\t\tx = x + mul * (str[i] - '0');\t\tmul *= 10;\t\tcount++;\t}\t//strip the trailing digit\tret = ret.substr(0, ret.length() - count);\t// add the compress content\twhile (x--) ret += mid;\tret += out(str.substr(end + 1));\treturn ret;}int main() {\twhile (cin >> str) {\t\tcout << out(str) << endl;\t}}/*2{efg}3{cd}ef*/","title":" 网易 互 娱 2018 年 校 招 笔试 解题 报告 ","oriTitle":"网易互娱2018年校招笔试解题报告"},{"uri":"/posts/poj1330-nearest-common-ancestors","tags":["LCA","图论","tarjan","倍增"],"content":"Time Limit: 1000MS Memory Limit: 10000KTotal Submissions: 17734 Accepted: 9405##DescriptionA rooted tree is a well-known data structure in computer science and engineering. An example is shown below:In the figure, each node is labeled with an integer from {1, 2,...,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16\\. Node 10 is also an ancestor of node 16\\. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16\\. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7\\. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7\\. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4\\. Node 4 is nearer to nodes 16 and 7 than node 8 is.For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4\\. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y.Write a program that finds the nearest common ancestor of two distinct nodes in a tree.##InputThe input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case starts with a line containing an integer N , the number of nodes in a tree, 2&lt;=N&lt;=10,000\\. The nodes are labeled with integers 1, 2,..., N. Each of the next N -1 lines contains a pair of integers that represent an edge --the first integer is the parent node of the second integer. Note that a tree with N nodes has exactly N - 1 edges. The last line of each test case contains two distinct integers whose nearest common ancestor is to be computed.##OutputPrint exactly one line for each test case. The line should contain the integer that is the nearest common ancestor.##Sample Input2161 148 510 165 94 68 44 101 136 1510 116 710 216 38 116 1216 752 33 43 11 53 5##Sample Output43##SourceTaejon 2002tarjan+ 并 查 集 求 LCA 模板 。 将 u 的 子 儿子 v 递归 合并 到 u， 若 y 在 x 的 子 树上 ， 则 根据 并 查 集 的 性质 ， 公共 祖先 即 为 x（father[y]）。 若 y 和 x 不再 同一 子 树上 。 则 根据 dfs 回溯 的 性质 ， 则 搜 完 y 之后 一定 是 回溯到 x,y 的 最近 公共 祖先 才能 搜 到 x 的 ， 而 此时 由 并 查 集 的 性质 ， 回溯 的 节点 刚好 就是 father[y]。`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define MP make_pair#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SI(x) set&lt;x&gt;::iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf=~0u&gt;&gt;1;const LL lnf=~0ull&gt;&gt;1;#define N 10005#define M 10005int n, m;//UnionSetint p[N];void initUset() {    for (int i = 0; i &lt;= n; i++)        p[i] = i;}int uFind(int x) {    return x == p[x] ? p[x] : p[x] = uFind(p[x]);}void uMerge(int x, int y) { //y 合并 到 x    int fx = uFind(x);    int fy = uFind(y);    if (fx != fy)        p[fy]=fx;}//Edge Graphint head[N], pos;struct Edge {    int v, nxt;} e[M];void initEdge() {    memset(head, -1, sizeof(head));    pos = 0;}void add(int u, int v) {    e[pos].v = v;    e[pos].nxt = head[u];    head[u] = pos++;}int findRoot(){// 有向图 选择 入 度 为 0 的 点 ， 无 向 图 不同 节点 做 根 ，LCA 结果 将 不同 。    for (int i = 1; i &lt; n; i++)        if (indeg[i] == 0) return i;    return assert(false),-1;}//LCAint size, root;int vis[N];int ans[5];int indeg[N];vector&lt;pr&lt;int, int&gt; &gt; que[N];int dfs(int u) {    int solved=0;    for (int i = head[u]; ~i; i = e[i].nxt) {        int v = e[i].v;        solved+=dfs(v);        if(solved==size)return solved;        uMerge(u, v);    }    vis[u] = 1;    for (int i = 0; i &lt; (int) que[u].size(); i++) {        int v = queu.F;        if (vis[v]) {            ansque[u.S] = uFind(v);            solved++;        }    }    return solved;}void tarjan() {    clrA(vis,0);    dfs(findRoot());}int main() {    int T;    scanf(\"%d\", &amp;T);    while (T--) {        scanf(\"%d\", &amp;n);        initEdge();        int u, v;        clrA(indeg,0);        for (int i = 1; i &lt; n; i++) {            scanf(\"%d%d\", &amp;u, &amp;v);            add(u, v);            indeg[v]++;        }        initUset();        size = 1;// 查询 的 次数         for(int i=1;i&lt;=n;i++)que[i].clear();        for (int i = 1; i &lt;= size; i++) {            scanf(\"%d%d\", &amp;u, &amp;v);            que[u].push_back(MP(v, i));            que[v].push_back(MP(u, i));        }        tarjan();        for (int i = 1; i &lt;= size; i++) {            printf(\"%d\\n\", ans[i]);        }    }}`LCA 还 可以 用 倍增 来 求 ：（ 思想 很 普通 ， 只是 以 2 进制 的 步长 向上 走 ：dpi 表示 节点 i 向上 走 2^j 步 到达 的 节点 。）`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&lt;x&gt;::iterator#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SRI(x) set&lt;x&gt;::reverse_iterator#define VRI(x) vector&lt;x&gt;::reverse_iterator#define MRI(x,y) map&lt;x,y&gt;::reverse_iterator#define F first#define S second#define qlr(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;#define N 10005#define M N-1int n;int head[N], pos;struct edge {    int v, nxt;} e[M];void add(int u, int v) {    e[pos].v = v;    e[pos].nxt = head[u];    head[u] = pos++;}void initEdge() {    clr(head, -1);    pos = 0;}int deep[N];vector&lt;int&gt; dp[N];int size;int findRoot() {    for (int i = 1; i &lt;= n; i++) {        if (dp[i].empty()) return i;    }    return -1;}void getDeep(int u = findRoot()) {    for (int i = head[u]; ~i; i = e[i].nxt) {        int v = e[i].v;        deep[v] = deep[u] + 1;        getDeep(v);    }    size = max(size, deep[u] + 1);// 记录 最大 深度 }void initLCA() {    clr(deep, 0);    size = 0;    getDeep();    for (int len = 1,t=2;t&lt;=size; len++,t&lt;&lt;=1) {// 跳出 条件 ：(t=2^len)&lt;=size        for (int i = 1; i &lt;= n; i++) {            if ((int)dpi].size() &gt;= len &amp;&amp; (int)dp[dp[i].size() &gt;= len) {                dpi].push_back(dp[dp[i][len-1]);            }        }    }}int getLCA(int u, int v) {    if (deep[u] &lt; deep[v]) swap(u, v);    int d = deep[u] - deep[v];    for (int i = 0; d; i++, d &gt;&gt;= 1) {        u = d &amp; 1 ? dpu : u;    }// 以 差值 二进制 形式 将 u 往上走 差值     if (u == v) return u;    for (int i = min(dp[u].size(),dp[v].size())-1; i &gt;= 0; i--) {        if (dpu != dpv) {            u = dpu;            v = dpv;            i=(int)min(dp[u].size(),dp[v].size());// 注意 每次 都 要 更新 i！！        }    }    u = dpu;    return u;}int main() {    int T;    cin &gt;&gt; T;    while (T--) {        scanf(\"%d\", &amp;n);        int u, v;        initEdge();        for (int i = 1; i &lt;= n; i++)            dp[i].clear();        for (int i = 1; i &lt; n; i++) {            scanf(\"%d%d\", &amp;u, &amp;v);            add(u, v);            dp[v].push_back(u);        }        initLCA();        scanf(\"%d%d\", &amp;u, &amp;v);        printf(\"%d\\n\", getLCA(u, v));    }}`LCA 还 可以 转化 为 RMQ 问题 （ 个人 更 喜欢 此 方法 ， 在线 ， 且 效率高 ）`C++//============================================================================// Name        : test3.cpp// Author      :// Version     :// Copyright   : Your copyright notice// Description : Hello World in C++, Ansi-style//============================================================================#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&lt;x&gt;::iterator#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SRI(x) set&lt;x&gt;::reverse_iterator#define VRI(x) vector&lt;x&gt;::reverse_iterator#define MRI(x,y) map&lt;x,y&gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;int n, m;#define N 10005#define M 10005int head[N], pos;struct Edge {    int v, nxt;} e[M];void initEdge() {    memset(head, -1, sizeof(head));    pos = 0;}void add(int u, int v) {    e[pos].v = v;    e[pos].nxt = head[u];    head[u] = pos++;}//RMQint dpM20;int lg2[N &lt;&lt; 1 | 1];#define getLeft(R,L) (R-(L)+1)void initRMQ(int n) { //dp0 表示 区间 i 的 值 。 预先 处理 出来 。    lg2[0] = -1;    int limit;    for (int i = 1; i &lt;= n; i++) {        lg2[i] = i &amp; (i - 1) ? lg2[i - 1] : lg2[i - 1] + 1;    }    for (int i = 1; i &lt;= lg2[n]; i++) {        limit = getLeft(n, 1 &lt;&lt; i);        for (int j = 1; j &lt;= limit; j++) {            dpMi = min(dpMi - 1, dpMi - 1)]);        }    }}int getRMQ(int x, int y) {    if (x &gt; y) swap(x, y);    int t = lg2[y - x + 1];    return min(dpMt, dpMt]);}//LCAint depth, cnt;int inde[N], H[N], E[N];//dp0 深度 序列 （dfs 编号 ），E[N] 每个 dfs 编号 对应 的 节点 ，H[N] 节点 第一次 出现 在 dfs 编号 序列 中 的 位置 int findRoot() {    for (int i = 1; i &lt;= n; i++)        if (!inde[i]) return i;    return -1;}void getEuler(int u = findRoot()) {    int dfn = dpM0 = ++cnt] = ++depth;    E[dfn] = u;    for (int i = head[u]; ~i; i = e[i].nxt) {        int v = e[i].v;        getEuler(v);        dpM0 = dfn;    }}void initLCA() {    depth = cnt = 0;    getEuler();    initRMQ(cnt);}int getLCA(int u, int v) {    if (H[u] &gt; H[v]) swap(u, v);    return E[getRMQ(H[u], H[v])];}int main() {    int T;    scanf(\"%d\", &amp;T);    while (T--) {        scanf(\"%d\", &amp;n);m=n-1;        int u, v;        initEdge();        memset(inde, 0, sizeof(inde));        for (int i = 1; i &lt;= m; i++) {            scanf(\"%d%d\", &amp;u, &amp;v);            add(u, v);            inde[v]++;        }        initLCA();        scanf(\"%d%d\", &amp;u, &amp;v);        printf(\"%d\\n\", getLCA(u, v));    }}`&nbsp;","title":"POJ1330 Nearest Common Ancestors","oriTitle":"POJ1330 Nearest Common Ancestors"},{"uri":"/posts/poj1989-distance-queries","tags":["LCA","RMQ","图论","tarjan"],"content":"##DescriptionFarmer John's cows refused to run in his marathon since he chose a path much too long for their leisurely lifestyle. He therefore wants to find a path of a more reasonable length. The input to this problem consists of the same input as in \"Navigation Nightmare\",followed by a line containing a single integer K, followed by K \"distance queries\". Each distance query is a line of input containing two integers, giving the numbers of two farms between which FJ is interested in computing distance (measured in the length of the roads along the path between the two farms). Please answer FJ's distance queries as quickly as possible!##InputLines 1..1+M: Same format as \"Navigation Nightmare\"Line 2+M: A single integer, K. 1 &lt;= K &lt;= 10,000Lines 3+M..2+M+K: Each line corresponds to a distance query and contains the indices of two farms.##OutputLines 1..K: For each distance query, output on a single line an integer giving the appropriate distance.##Sample Input7 61 6 13 E6 3 9 E3 5 7 S4 1 3 N2 4 20 W4 7 2 S31 61 42 6##Sample Output13336##HintFarms 2 and 6 are 20+3+13=36 apart.##SourceUSACO 2004 February 无 向 树 求 节点 距离 ：dist(u,v)=dist(root,u)+dist(root,v)-2*dist(root,lca(u,v))tarjan+ 并 查 集 求 LCA。 注意 可能 树 不 连通 。`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define MP make_pair#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SI(x) set&lt;x&gt;::iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;#define N 40005#define M 40005int n, m;//Edge Graphint head[N], pos;struct Edge {    int v, w, nxt;} e[M &lt;&lt; 1];void initEdge() {    memset(head, -1, sizeof(head));    pos = 0;}void add(int u, int v, int w) {    e[pos].v = v;    e[pos].w = w;    e[pos].nxt = head[u];    head[u] = pos++;}//UnionSetint p[N];void initUset() {    for (int i = 0; i &lt;= n; i++)        p[i] = i;}int uFind(int x) {    return x == p[x] ? p[x] : p[x] = uFind(p[x]);}void uMerge(int x, int y) { //y 合并 到 x    int fx = uFind(x);    int fy = uFind(y);    if (fx != fy) p[fy] = fx;}//tarjan-LCAint size,bcnt;int lca[10005];int vis[N];int dis[N];int ans[10005];vector&lt;pr&lt;int, int&gt; &gt; query[N];int findRoot() {    for (int i = 1; i &lt;= n; i++) {        if (!vis[i]) return i;    }    return assert(false),-1;}int dfs(int u, int fa) {    int solved = 0;    for (int i = head[u]; ~i; i = e[i].nxt) {        int v = e[i].v;        if (v == fa) continue;        dis[v] = dis[u] + e[i].w;        solved += dfs(v, u);        if (solved == size) return solved;        uMerge(u, v);    }    vis[u] = bcnt;    for (int i = 0; i &lt; (int) query[u].size(); i++) {        int v = queryu.F;        if (vis[v]==bcnt) {            solved++;            lcaquery[u.S] = uFind(v);            ansquery[u.S] = disu] + dis[v] - 2 * dis[lca[query[u.S]];        }    }    return solved;}void tarjan() {    clrA(vis, 0);    clrA(dis, 0);    int tot = 0;    bcnt=0;    do {        bcnt++;// 从 1 开始         tot += dfs(findRoot(), -1);    } while (tot &lt; size);// 图 可能 不 连通 }int main() {    while (~scanf(\"%d%d\", &amp;n, &amp;m)) {        int u, v, w;        char c;        initEdge();        for (int i = 1; i &lt;= m; i++) {            scanf(\"%d%d%d %c\", &amp;u, &amp;v, &amp;w, &amp;c);            add(u, v, w);            add(v, u, w);        }        initUset();        scanf(\"%d\", &amp;size);        for (int i = 1; i &lt;= n; i++)            query[i].clear();        for (int i = 1; i &lt;= size; i++) {            scanf(\"%d%d\", &amp;u, &amp;v);            query[u].push_back(MP(v, i));            query[v].push_back(MP(u, i));        }        tarjan();        for (int i = 1; i &lt;= size; i++) {            printf(\"%d\\n\", ans[i]);        }    }}` 另外 ， 还 可以 转化 为 RMQ 问题 求解 ：`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&lt;x&gt;::iterator#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SRI(x) set&lt;x&gt;::reverse_iterator#define VRI(x) vector&lt;x&gt;::reverse_iterator#define MRI(x,y) map&lt;x,y&gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;#define N 40005#define M 40005int n, m;//Edge Graphint head[N], pos;struct Edge {    int v, w, nxt;} e[M &lt;&lt; 1];void initEdge() {    memset(head, -1, sizeof(head));    pos = 0;}void add(int u, int v, int w) {    e[pos].v = v;    e[pos].w = w;    e[pos].nxt = head[u];    head[u] = pos++;}//RMQint dpM20;//dpMi   从 j 开始 的 ， 连续 2^i 个 数字 的 最 值 ,j 从 1 开始 int lg2[N&lt;&lt;1|1];// 等价 于  (int)lg2(1.0*m)/lg2(2.0)  若 空间 不足 可以 这样 写 #define getLeft(R,L) (R-(L)+1) // 输入 右 端点 和 长度 ， 返回 左 端点 void initRMQ(int n) {    lg2[0]=-1;int limit;    for(int i=1;i&lt;=n;i++) {        lg2[i]=(i&amp;(i-1))?lg2[i-1]:lg2[i-1]+1;    }    for(int i=1;i&lt;=lg2[n];i++){        limit=getLeft(n,1&lt;&lt;i);        for(int j=1;j&lt;=limit;j++){            dpMi=min(dpMi-1,dpMi-1]);        }    }}int getRMQ(int a,int b) {    int t=lg2[b-a+1];    int s1=a;    int s2=getLeft(b,1&lt;&lt;t);    //return max(Maxt,Maxt);    return min(dpMt,dpMt);}#undef getLeft//LCAint dist[N];int H[N];// 节点 第一次 出现 的 位置 int E[N&lt;&lt;1|1];// 欧拉 序列 2n+1 个 int cnt,depth;int findRoot(){    for(int i=1;i&lt;=n;i++)return i;    return -1;}void getEuler(int u=findRoot(),int fa=-1){    int tmp=dpM0=++cnt]=++depth;    E[tmp]=u;    for(int i=head[u];~i;i=e[i].nxt){        int v=e[i].v;        if(v==fa)continue;        dist[v]=dist[u]+e[i].w;        getEuler(v,u);        dpM0=tmp;    }}void initLCA(){    memset(dist,0,sizeof(dist));    cnt=depth=0;    getEuler();    initRMQ(cnt);}int getLCA(int u,int v){    if(H[u]&gt;H[v])swap(u,v);    return E[getRMQ(H[u],H[v])];}int main() {    while (~scanf(\"%d%d\", &amp;n, &amp;m)) {        int u, v, w;        char c;        initEdge();        for (int i = 1; i &lt;= m; i++) {            scanf(\"%d%d%d %c\", &amp;u, &amp;v, &amp;w, &amp;c);            add(u, v, w);            add(v, u, w);        }        initLCA();        scanf(\"%d\",&amp;m);        while(m--){            scanf(\"%d%d\",&amp;u,&amp;v);            printf(\"%d\\n\",dist[u]+dist[v]-2*dist[getLCA(u,v)]);        }    }}`","title":"POJ1989 Distance Queries","oriTitle":"POJ1989 Distance Queries"},{"uri":"/posts/polymer-2-1-custom-elements","tags":["Polymer"],"content":"https://www.polymer-project.org/2.0/docs/devguide/custom-elements>Custom element names. By specification, the custom element's name must start with a lower-case ASCII letter and must contain a dash (-). There's also a short list of prohibited element names that match existing names. For details, see the Custom elements core concepts section in the HTML specification. 自定义 元素 的 命名 规则 ：  按照 规范 ， 自定义 元素 的 命名 中 必须 以 一个 小写字母 开始 ， 必须 包含 一个 连接符 （-）>Custom properties can only be defined in rule-sets that match the html selector or a Polymer custom element. This is a limitation of the Polymer implementation of custom properties.Polymer 实现 方式 的 局限 ：  只有 html 元素 或者 Polymer 自定义 元素 才能 使用 自定义 CSS 属性 。( 个人感觉 虽然 shadowDOM 原生 支持 CSS 隔离 ， 但是 一部分 元素 能 用 cssnext 一部分 元素 不能 用 ， 割裂 感 太 严重 了 。)>Polymer does not currently support extending built-in elements. The custom elements spec provides a mechanism for extending built-in elements, such as ` and  . The spec calls these elements customized built-in elements. Customized built-in elements provide many advantages (for example, being able to take advantage of built-in accessibility features of UI elements like  and `). However, not all browser makers have agreed to support customized built-in elements, so Polymer does not support them at this time. 因为 浏览器 厂商 的 争议 ，Polymer 不 支持 扩展 内 建 元素 。 在 生产 环境 下 main document 不要 定义 自定义 元素 。 基于 实验 目的 可以 使用 HTMLImports.whenReady(callback) 方法 等待 所有 html import  加载 完毕 。 组件 生命周期 标准 的 几个 生命周期 回调 ：| Reaction                 | Description                              || ------------------------ | ---------------------------------------- || constructor              | Called when the element is upgraded (that is, when an element is created, or when a previously-created element becomes defined). || connectedCallback        | Called when the element is added to a document. || disconnectedCallback     | Called when the element is removed from a document. || attributeChangedCallback | Called when any of the element's attributes are changed, appended, removed, or replaced, |>For each reaction, the first line of your implementation must be a call to the superclass constructor or reaction. 开始 写 自己 的 回调 事件 之前 都 必须 先 调用 super 上面 的 回调 。Super.connectedCallback();>The constructor can't examine the element's attributes or children, and the constructor can't add attributes or children.Constructor 函数 中 不能 对 DOM 进行 任何 操作 。>In general, work should be deferred to connectedCallback as much as possible—especially work involving fetching resources or rendering. However, note that connectedCallback can be called more than once, so any initialization work that is truly one-time will need a guard to prevent it from running twice.>In general, the constructor should be used to set up initial state and default values, and to set up event listeners and possibly a shadow root.Constructor 里面 只 应该 做 一些 初始化 状态 、 值 、 绑定 事件 ， 建立 shadowroot 之类 的 工作 。 其他 工作 应该 推迟 到 connectedCallback 里面 做 ， 但是 需要 注意 的 是 connectedCallback 可能 会 调用 多次 。>The custom elements specification doesn't provide a one-time initialization callback. Polymer provides a readycallback, invoked the first time the element is added to the DOM.Polymer 提供 了 一个 规范 里面 没有 的 回调 ： Ready，  只 在 元素 第一次 加入 DOM 时候 触发 。ready() {  super.ready();  // When possible, use afterNextRender to defer non-critical  // work until after first paint.  Polymer.RenderStatus.afterNextRender(this, function() {    ...  });}>Elements have a custom element state that takes one of the following values:>>1. uncustomized: The element does not have a valid custom element name. It is either a built-in element (`, ) or an unknown element that cannot become a custom element (`)>2. undefined: The element has a valid custom element name (such as \"my-element\"), but has not been defined.>3. custom: The element has a valid custom element name and has been defined and upgraded.>4. failed: An attempt to upgrade the element failed (for example, because the class was invalid). 元素 内部 拥有 四个 状态 ， 我们 不能 直接 获得 ， 但是 可以 使用 :defined 伪 类 来 选择 \"uncustomized\" 和 \"custom\" 的 元素 。 自定义 元素 >Hybrid elements: should continue to use the Polymer DOM APIs, but may require some changes.>Legacy elements: can use the Polymer DOM APIs or the native DOM APIs.>Class-based elements: should use native DOM APIs. 总共 有 三种 自定义 元素 ：Hybird element：  主要 是 为了 兼容 Polymer 1.x; 但  Gesture Events 只 支持 Hybird elements。 详见 下文 。Legacy element： 处于 两者之间 （ 没有 看出 有 什么 用处 ）Class-based element：Polymer 2.0  最 常用 的 自定义 元素 方式 。Class-based elements// define the element's class elementclass MyElement extends Polymer.Element {  // 'is' getter, return the tag name which is lowercased. required.  static get is(){    return 'my-element';  }  // Define the properties.  static get properties() {}  // Element class can define custom element reactions  constructor() { super(); }  connectedCallback() {    super.connectedCallback();    console.log('my-element created!');  }  ready() {    super.ready();    this.textContent = 'I\\'m a custom element!';  }}// Associate the new class with an element namecustomElements.define(MyElement.is, MyElement);// create an instance with createElement:var el1 = document.createElement('my-element');// ... or with the constructor:var el2 = new MyElement();Legacy elements// register an elementMyElement = Polymer({is: 'my-element',// See below for lifecycle callbackscreated: function() { this.textContent = 'My element!'; }});// create an instance with createElement:var el1 = document.createElement('my-element');// ... or with the constructor:var el2 = new MyElement();Legacy 元素 的 生命周期 有着 不同 的 名字 ：| Legacy lifecycle cb | Class-based lifecycle cb    || ------------------- | --------------------------- || Created           | constructor               || Ready             | ready                     || Attached          | connectedCallback         || Detached          | disconnectedCallback      || attributeChanged  | attributedChangedCallback |Hybird elements 这种 方式 主要 是 为了 兼容 Polymer 1.x。 可以 使用 Class-based 方式 改写 。 详见 Gesture Events。 自定义 属性 （properties) 自定义 属性 主要 在 properties getter 中 定义 。 可以 直接 传 一个 字符串 。 也 可以 传给 他们 一个 Object。Object 需要 包含 下面 几个 属性 ：type  数据类型 >Type: constructor>Attribute type, used for deserializing from an attribute. Polymer supports deserializing the following types: Boolean, Date, Number, String, Array and Object. You can add support for other types by overriding the element's  _deserializeValue method.>Unlike 0.5, the property's type is explicit, specified using the type's constructor. Seeattribute deserialization for more information.>When reflecting a property to an attribute or binding a property to an attribute, the property value is serialized to the attribute.>By default, values are serialized according to value's current type, regardless of the property's type value:>String No serialization required.>Date or Number Serialized using toString.>Boolean Results in a non-valued attribute to be either set (true) or removed (false).>Array or Object Serialized using  JSON.stringify.Array 和 Object 需要 写成 JSON 的 形式 ，Date 需要 写成 任何 符合 Date 解析 形式 的 String。 可以 重写 属性 序列化 函数 ： _serializeValue method._serializeValue(value) {  if (value instanceof MyCustomType) {    return value.toString();  }  return super._serializeValue(value);}value  默认值 >Type: boolean, number, string or function.>Default value for the property. If value is a function, the function is invoked and the return value is used as the default value of the property. If the default value should be an array or object unique to the instance, create the array or object inside a function. See Configuring default property values for more information 跟 Vue 一样 ， 如果 一个 属性 的 默认值 是 以 Array 或者 Object, 那么 所有 该 元素 的 实例 的 默认值 都 共享 一个 变量 。 如果 要 使 每个 元素 拥有 一份 完全 独立 的 拷贝 的话 ， 需要 在 这个 值 外 面包 一个 函数 。class XCustom extends Polymer.Element {static get properties() {    return {      mode: {        type: String,        value: 'auto'      },      data: {        type: Object,        notify: true,        value: function() { return {}; }      }    }}reflectToAttribute>Type: boolean>Set to true to cause the corresponding attribute to be set on the host node when the property value changes. If the property value is Boolean, the attribute is created as a standard HTML boolean attribute (set if true, not set if false). For other property types, the attribute value is a string representation of the property value. Equivalent to reflect in Polymer 0.5. See Reflecting properties to attributes for more information 值 的 变化 是否 同步 更新 DOM 上面 的 attr>For a Boolean property to be configurable from markup, it must default to false. If it defaults to true, you cannot set it to false from markup, since the presence of the attribute, with or without a value, equates to true. This is the standard behavior for attributes in the web platform.>If this behavior doesn't fit your use case, you can use a string-valued or number-valued attribute instead.Boolean 类型 的 属性 只能 把 默认值 设 为 false， 因为 标准 的 HTML 属性 行为 （ 存在 为 true， 不 存在 为 false）, 如果 必须 把 默认值 设 为 true， 可以 用 String 或者 Number 类型 属性 代替 。readOnly>Type: boolean>If true, the property can't be set directly by assignment or data binding.notify>Type: boolean>If true, the property is available for two-way data binding. In addition, an event, property-name-changed is fired whenever the property changesDOM 上面 的 属性 变化 是否 调用 回调 （ 反向 绑定 ） 属性 this.firstName 的 变化 会 触发 first-name-changed 事件 。 这些 事件 被 用 在 了 双向 绑定 系统 ， 在 外部 代码 里面 我们 可以 直接 使用 addEventListener。 有点像 Java 里面 的 约定 大于 配置 的 思想 ， 这样 能 使 代码 变得 简单 易懂 computed>Type: string>The value is interpreted as a method name and argument list. The method is invoked to calculate the value whenever any of the argument values changes. Computed properties are always read-only. See Computed properties for more information 传入 一个 包含 方法 名 和 参数 列表 的 字符串 ， 参数 必须 readOnly， 将 该 方法 调用 参数 运行 的 结果 作为 该项 的 值 observer>Type: string>The value is interpreted as a method name to be invoked when the property value changes. Note that unlike in 0.5, property change handlers must be registered>explicitly. The propertyNameChanged method will not be invoked automatically. See Property change callbacks (observers) for more information 传入 一个 方法 名称 ， 当值 发生变化 时 自动 执行 该 方法 其他 隐 式 声明 属性 : if you add it to a data binding or add it as a dependency of an observer, computed property, or computed binding.Priavte 和 Protected 属性 ： 分别 用 _prop 和 prop 表示 。","title":"Polymer 2.0  文档 笔记 (1) Custom Elements","oriTitle":"Polymer 2.0 文档笔记(1) Custom Elements"},{"uri":"/posts/polymer-2-2-shadowdom","tags":["Polymer"],"content":"ShadowDOM APIvar div = document.createElement('div');var shadowRoot = div.attachShadow({mode: 'open'});shadowRoot.innerHTML = 'Hello Shadow DOM';ShadowDOM Composition 主要 概念 ：LightDOM:  元素 的 实际 子孙 节点 ， 浏览器 不会 对 LightDOM 做 任何 的 修改 和 移动 。 但是 渲染 的 时候 会 渲染 到 相对 于 的 slot 节点 之下 ， 如果 找 不到 对应 的 slot 节点 ， 则 不会 渲染 。ShadowDOM:  不 解释 。。。Slot:  slot 标签 是 LightDOM 插入 到 ShadowDOM 中 的 标记 。 可以 设置 name 属性 来 匹配 对应 的 LightDOM。Slot 标签 不会 渲染 ， 但是 还是 会 存在 （ 即 能够 参与 事件 传递 ）。 另外 如果 一个 LightDOM 找 不到 匹配 的 slot 插入 点 ， 则 改 LightDOM 也 不会 被 渲染 。Flatterned Tree: LightDOM 通过 ShadowDOM 里面 的 slot 标记 合并 在 一起 （flattern） 的 抽象 的 DOM 树 （devTools 中 不 可见 ）， 是 最后 浏览器 实际 用来 渲染 的 DOM 树 。 需要 注意 的 是 ：>Slots can only be selected explicitly, by slot name. It's impossible to select content implicitly, based on a tag name or an arbitrary selector like :not(.header).slot 只能 用 slot name 来 区分 、 选中 。 不能 用 其他 任意 的 css 选择器 。 各个 slot 之间 的 区域 是 互斥 的 ， 而且   只能 选择 top-level 元素  ( 包括 后面 的 ::slotted(selector) 选择器 )。Fallback content 实际上 就是 可以 在 模版 的 slot 里面 写 东西 ， 作为 一个 默认值 Mulit-level distribution 多级 slot 嵌套 。flatterning 的 时候 规则 是从 外向 里 ，  因此 父 节点 的 slot 下面 的 lightDOM 会 渲染 在 子 节点 的 LightDOM 之下 。Slot APIs && Observe added and removed childrenHTMLElement.assignedSlotHTMLSlotElement.assignedNodesHTMLSlotElement.slotchange(event)Polymer.FlattenedNodesObserverPolymer.FlattenedNodesObserver.getFlattenedNodes(node)new Polymer.FlattenedNodesObserver(this.$.slot,(info)=>{}) 详情 参考 Shadow DOM polyfills 因为 shadowDOM 不是 每个 浏览器 都 支持 ， 所以 使用 了 webcomponents.js 中 的 shadyDOM 和 shadyCSS 两个 polyfills。How the polyfills work>The polyfills use a combination of techniques to emulate shadow DOM:>Shady DOM: Maintains the logical divisions of shadow tree and descendant tree internally, so children added to the light DOM or shadow DOM render correctly. Patches DOM APIs on affected elements in order to emulate the native shadow DOM APIs.>Shady CSS: Provides style encapsulation by adding classes to shadow DOM children and rewriting style rules so that they apply to the correct scope.ShadyDOMShadyDOM 主要 原理 是 patch 原生 DOM API 来 提供 跟 native shadowDOM 一致 的 接口 。 在 内存 中 维护 了 一个 保存 LightDOM 的 children 树 和 一个 保存 ShadowDOM 的 ShadowRoot 树 。 但是 实际上 元素 下面 就是 一颗 渲染 好 的 flatterned 树 。 因为 这个 是 就是 实际上 的 用来 渲染 的 树 ， 所以 不 存在 slot， 因此 shadyDOM polyfills 方案 里面 的 slot 元素 不 参与 事件 传递 。ShadyCSSShadyCSS 主要 提供 了 原生 ShadowDOM 规则 的 支持 和 两个 cssnext 特性 ：CSS custom properties  和  custom property mixins.Scoped CSS 特性 的 实现 原理 跟 Vue 相似 ： 对 元素 的 ShadowDOM 添加 class， 并 重写 CSS 的 匹配 规则 。ShadowDOM stylingShadowDOM 样式 三 大 原则 ： 外层 的 样式 不会 对 内层 样式 进行 匹配 。 内层 样式 不会 影响 外层 样式 。 可 继承 的 css 属性 （ 例如 ：color） 等 ， 内层 可以 照样 继承 自 外层 。 两个 特殊 伪 类 ： 选择 ShadowDOM 的 根 节点 节点 :host/:host(selector)#shadow-root    /* custom elements default to display: inline */    :host {      display: block;    }    /* set a special background when the host element       has the .warning class */    :host(.warning) {      background-color: red;    } 选择 分布式 节点 ——::slotted()  slotted() 选择器 右边 不能 写 任何 其他 选择器 。  slotted(selector)  里面 的 selector 只能 是 简单 选择器 ， 并且 只能 选择 顶级 元素 。  slotted(*)  选择 默认 的 LightDOM( 不 包含 有 name 值 的 slot)  slotted(slot=tkw)  选择 name 为 tkw 的 LightDOM      ::slotted(img){        border-radius: 103%;      }    // define the element's class element    class XFoo extends Polymer.Element {      // 'is' getter, return the tag name which is lowercased. required.      static get is(){        return 'x-foo';      }      // Define the properties.      static get properties() {}      // Element class can define custom element reactions      constructor() { super(); }      connectedCallback() {        super.connectedCallback();        console.log('x-foo created!');      }    }    window.customElements.define(XFoo.is, XFoo);    A logoShare styles between elementscustom-style 兼容性 写法 ， 使用 ` 标签 包围 main document 里面 的 全局 ` 能 避免 在 不 支持 shadowDOM v1 规范 的 浏览器 中 全局 css 规则 继续 在 shadowDOM 中 生效 。 注意 是 避免 CSS 规则 生效 ， 而 不是 避免 CSS 样式 的 继承 custom-style 元素 不 包含 在 Polymer 中 ， 需要 引入 ：CSS custom properties 主要 是 提供 一个 支持 两个 CSS Next 语法 的 扩展 版本 ：custom properties & var() 可以 通过 ——customvar 形式 定义 变量 ， 然后 通过 var(--customvar,[defaultvar]) 取值 。 通过 这个 特性 我们 可以 暴露出 一些 可 配置 的 变量 ， 然后 供 组件 外部 的 父 元素 进行 自定义 。 与 cssnext 规范 不同 的 是 ，cssnext 的 变量 定义 必须 写 在 :root{} 中 ， 而 Polymer 则 是 不能 在 LightDOM 中 使用 。p {  color: var(--paper-red-500);}paper-checkbox {  --paper-checkbox-checked-color: var(--paper-red-500);}custom properties set & @applyPolymer 默认 不 支持 自定义 属性 集合 ， 需要 手动 引入 ： 相当于 cssnext 对应 的 语法 ， 但是 同样 可以 在 任何 css Rule 下 使用 。      /* Apply custom theme to toolbars */      :host {        --my-toolbar-theme: {          background-color: green;          border-radius: 4px;          border: 1px solid gray;        };        --my-toolbar-title-theme: {          color: green;        };      }      /* Make only toolbars with the .warning class red and bold */      .warning {        --my-toolbar-title-theme: {          color: red;          font-weight: bold;        };      }    class MyElement extends Polymer.Element {      static get is() {        return \"my-element\";      }    }    customElements.define(MyElement.is, MyElement);      :host {        padding: 4px;        background-color: gray;        /* apply a mixin */        @apply --my-toolbar-theme;      }      .title {        @apply --my-toolbar-title-theme;      }    {{title}}  ...CSS Custom Property APIupdateStyles 动态 更改 css 自定义 属性 的 值 。      :host {        --my-toolbar-color: red;      }    My awesome app    Change theme    class XCustom extends Polymer.Element {      static get is() {        return \"x-custom\";      }      static get changeTheme() {        return function() {        this.updateStyles({          '--my-toolbar-color': 'blue',        });      }    }    customElements.define(XCustom.is, XCustom); 注意 当 外层 元素 或者 被 继承 元素 里面 已经 定义 了 一个 变量 ， 那么 当前 再 定义 这个 变量 是 无效 的 ， 需要 手动 调用 该 方法 。 这个 行为 类似 于 LessgetComputedStyle(ShadyCSS.getComputedStyle) 获得 当前 自定义 属性 的 值 ( 需要 区分 原生 和 Polyfill)if (ShadyCSS) {  style = ShadyCSS.getComputedStyleValue('--something');} else {  style = getComputedStyle(this, '--something');}DOM Templating>By default, adding a DOM template to an element causes Polymer to create a shadow root for the element and clone the template into the shadow tree.DOMTemplate 是 通过 clone 操作 添加 到 shadow tree 里面 去 的 。  有 三种 方式 定义 一个 DOM Template：template 标签 直接 将 模板 写 在 `` 标签 里面 ,  是 最 直接 的 方式 、 最 常见 的 方式 。I am x-foo!    class XFoo extends Polymer.Element {      static get is() { return  'x-foo' }    }    customElements.define(XFoo.is, XFoo);String template 字符串 模板 class MyElement extends Polymer.Element {static get template() {    return `:host { color: blue; }       String template       I've got a string template!`  }}customElements.define('my-element', MyElement);Retrieve or generate your own template element 通过 继承 或 手动 实现 template getter 获得 模板 . 注意 ： 不要 对 父 类 的 template 直接 修改 ， 应该 先 拷贝 一份 出来 。 如果 需要 做 一些 耗 资源 的 操作 ， 应该 对 你 修改 的 template 进行 缓存 ， 以免 重复 调用 。(function() {  let memoizedTemplate;class MyExtension extends MySuperClass {    static get template() {      if (!memoizedTemplate) {        // create a clone of superclass template (true = \"deep\" clone)        memoizedTemplate = MySuperClass.template.cloneNode(true);        // add a node to the template.        let div = document.createElement('div');        div.textContent = 'Hello from an extended template.'        memoizedTemplate.content.appendChild(div);      }      return memoizedTemplate;    }  }})();URLs in template 默认 对于 所有 从 其他 文件 里面 引入 的 组件 里面 元素 所 包含 的 链接 Polymer 是 不 做 处理 的 ， 所有 的 相对路径 的 资源 最后 都 是 相对 于 主 文档 （main document） 的 路径 。 但是 我们 可以 使用 下面 两个 特殊 的 标记 importPath>A static getter on the element class that defaults to the element HTML import document URL and is overridable. It may be useful to override importPath when an element's template is not retrieved from a  or the element is not defined using an HTML import. 一个 静态 getter 函数 ， 默认 指向 该 元素 被 HTML import 时候 的 URL， 也 可以 被 重写 。rootPath>An instance property set to the value of Polymer.rootPath which is globally settable and defaults to the main document URL. It may be useful to set Polymer.rootPath to provide a stable application mount path when using client side routing. 一个 实例 化 的 属性 ， 值 被 设置 为 Polymer.rootPath。 代表 着 主 文档 (main document) 的 URL。>Relative URLs in styles are automatically re-written to be relative to the importPath property. Any URLs outside of a `` element should be bound using importPath or rootPath where appropriate. 所有 style 标签 里面 的 URL 全部 被 重写 为 相对 于 importPath 的 路径 。 除此之外 ， 都 需要 自己 手动 添加 合适 的 前缀 ：View profileStatic node map>Polymer builds a static map of node IDs when the element initializes its DOM template, to provide convenient access to frequently used nodes without the need to query for them manually. Any node specified in the element's template with an id is stored on the this.$ hash by id. The this.$ hash is created when the shadow DOM is initialized. In the ready callback, you must call super.ready() before accessing this.$. 这个 主要 是 Polymer 提供 的 一个 可以 快速访问 DOM 节点 的 方式 。 可以 通过 this.$[id] 来 获取 拥有 对应 id 的 元素 / 自定义 元素 。 相当于 document.getElementById 的 升级版 类似 于 react 中 的 this.refsthis.$ 接口 只能 在 ready 回调 函数 的 super.ready() 之后 被 调用 。 动态创建 的 节点 （dom-repeat\\ dom-if） 并 不 包含 在 this.$ 集合 里 ， 但是 还是 可以 用 标准 的 querySelector 方法 获取 。    Hello World from !    class MyElement extends Polymer.Element {      static get is() { return  'x-custom' }      ready() {        super.ready();        this.$.name.textContent = this.tagName;      }    }","title":"Polymer 2.0  文档 笔记 (2) ShadowDOM","oriTitle":"Polymer 2.0 文档笔记(2) ShadowDOM"},{"uri":"/posts/polymer-2-3-events","tags":["Polymer"],"content":"Normal Events>Polymer elements can use the standard DOM APIs for creating, dispatching, and listening for events.Polymer also provides annotated event listeners, which allow you to specify event listeners declaratively as part of the element's DOM template.Add annotated event listeners 这个 其实 就是 在 标签 上 使用 on-event 属性 。    Kick Me    class XCustom extends Polymer.Element {static get is() {return 'x-custom'}handleClick() {console.log('Ow!');}}customElements.define(XCustom.is, XCustom); 需要 注意 的 有 ： 如果 添加 了 手势 事件 则 应当 使用 on-tap 事件 代替 on-click 事件 ， 提供 更好 的 移动 浏览器 支持 。 因为 html 属性 的 限制 ， 所有 的 事件 名称 都 将 转化 为 小写字母 。(To avoid confusion, always use lowercase event names. )Add and remove listeners imperatively 直接 使用 原生 的 addEventListener 和 removeEventListenerFire custom events 直接 使用 原生 的 CustomEvent 和 dispatchEventEvent Retargeting 为了 保持 ShadowDOM 的 隐蔽性 。 元素 内部 ShadowDOM 触发 的 一些 事件 在 网上 传播 时会 将 target 重定向 到 当前 元素 。event.composedPath() :  包含 事件 传递 过程 中 所 经过 的 nodes 路径 列表 。 自定义 的 事件 默认 无法 穿透 ShadowDOM 边界 。 可以 如下 设置 ：var event = new CustomEvent('my-event', {bubbles: true, composed: true});Gesture Events 手势 事件 的 支持 是 基于 Legacy Element 的 ， 如果 使用 Polymer2 的 class 风格 定义 需要 使用 mixin:Polymer.GestureEventListeners    class TestEvent extends Polymer.GestureEventListeners(Polymer.Element) {      ... 注册 事件 也 有 两种 方式 ： 支持 on-event 形式 的 声明 方式 显示 定义 的 方式 ：Polymer.Gestures.addListener(this, 'tap', e => this.tapHandler(e));  包含 以下 几种 手势 事件 ， 包含 在 e.detail 中 。down—finger/button went down  x—clientX coordinate for event  y—clientY coordinate for event  sourceEvent—the original DOM event that caused the down actionup—finger/button went up  x—clientX coordinate for event  y—clientY coordinate for event  sourceEvent—the original DOM event that caused the up actiontap—down & up occurred  x—clientX coordinate for event  y—clientY coordinate for event  sourceEvent—the original DOM event that caused the tap actiontrack—moving while finger/button is down  state—a string indicating the tracking state:    start—fired when tracking is first detected (finger/button down and moved past a pre-set distance threshold)    track—fired while tracking    end—fired when tracking ends  x—clientX coordinate for event  y—clientY coordinate for event  dx—change in pixels horizontally since the first track event  dy—change in pixels vertically since the first track event  ddx—change in pixels horizontally since last track event  ddy—change in pixels vertically since last track event  hover()-a function that may be called to determine the element currently being hovered","title":"Polymer 2.0  文档 笔记 (3) Events","oriTitle":"Polymer 2.0 文档笔记(3) Events"},{"uri":"/posts/polymer-2-4-data-system","tags":["Polymer"],"content":"Polymer 提供 观察 函数 、 计算 属性 、 数据 绑定 三 大 模型 功能 ：>- Observers Callbacks invoked when data changes.>- Computed properties Virtual properties computed based on other properties, and recomputed when the input data changes.>- Data bindings Annotations that update the properties, attributes, or text content of a DOM node when data changes.    [[name.first]] [[name.last]]    class NameCard extends Polymer.Element {      static get is() { return \"name-card\"; }      constructor() {        super();        this.name = {first: 'Kai', last: 'Li'};      }    }    customElements.define(NameCard.is, NameCard);Observable Change>The data system is based on paths, not objects, where a path represents a property or subproperty relative to the host element.Polymer 的 数据系统 是 基于 数据 的   路径   之上 的 。 并 不是 实际 的 对象 。 可 观察 到 的 变化 指 的 是 Polymer 里面 存在 一个 相关 的 路径 指向 这个 数据 的 变化 。 因此 ， 直接 改变 一个 object、array 等 引用 对象 不会 被 观察 到 。this.address.street = 'Elm Street' 改变 address.street 并 不能 被 address 上 的 观察器 捕捉到 变化 Mutating objects and arrays observably 使用 Polymer 提供 的 方法 ：//  改变 objectthis.set('address.street','Half Moon Street')//  改变 arraythis.set('users.3',{name:'Hawking'})this.push('users',{name: 'Maturin'})this.pop('users')this.unshift('users',{name: 'Martin'})this.shift('users')this.splice('users',3,1,{name:'Hawking'})//  批量 更新 this.setProperties({item:'Orange', count:12},true) //setReadOnly:true  代表 需要 设置 ready-only 的 属性 // 延迟 统一 更新 this.notifyPath('address.street')this.notifySplices('users') //only array//  获得 路径 代表 的 属性 值 var value = this.get('address.street') // 获得 users[2] 的 值 var item = this.get(['users',2])>Polymer performs dirty checking for objects and arrays using object equality. It doesn't produce any property effects if the value at the specified path hasn't changed.notifyPath 方式 需要 提供 具体 属性 的 路径 ， 而 不 应该 是 Object 或 Array， 因为 Polymer 直接 使用 数据 引用 地址 进行 比较 。 如果 一定 需要 观察 它们 ，Polymer 提供 了 三种 解决方案 ： 使用 Immutable 之类 的 库 ， 或者 每次 改变 Object 和 Array 里面 的 值 的 时候 都 先 克隆 出 一个 副本 ， 在 克隆 的 副本 上 修改 然后 把 路径 指向 克隆 副本 。 使用 mixin Polymer.MutableData 可以 禁止 Polymer 的 对 object 和 array 的 脏 检查 (dirty check) 使用 mixin Polymer.OptionalMutableData 可以 在 标签 上 添加 一个 bool 属性 mutable， 代表 是否 对 object 或 array 开启 脏 检测 Data Paths>A data path is a series of path segments. In most cases, each path segment is a property name. The data APIs accept two kinds of paths:>- A string, with path segments separated by dots.>- An array of strings, where each array element is either a path segment or a dotted path. 数据 路径 可以 是 一个 路径 字符串 ， 也 可以 是 一个 包含 路径 字符串 的 数组 ， 比如 下面 三行 全部 代表 同一个 路径 ：\"one.two.three\"[\"one\", \"two\", \"three\"][\"one.two\", \"three\"]> Polymer doesn't automatically know that these properties refer to the same object.` makes a change to the object, no property effects are invoked on `> For data changes to flow from one element to another, the elements must be connected with a data binding.Polymer 是 以 路径 来 监听 数据 变化 的 。 所以 ， 就算 两个 路径 实际上 都 指向 同一个 对象 ， 他俩 也 不会 联动 。 需要 对 这 两个 路径 进行 链接 操作 。Linking paths with data bindings>data binding is the only way to link paths on different elements    …  … 链接 两个 路径 之后 的 示意图 ：>The ` element has a property primaryAddress` that refers to a JavaScript object.>The ` element has a property address` that refers to the same object.>The data binding connects the path \"primaryAddress\" on ` to the path \"address\" on `Data binding scope>Paths are relative to the current data binding scope.>The topmost scope for any element is the element's properties. Certain data binding helper elements (like template repeaters) introduce new, nested scopes.>For observers and computed properties, the scope is always the element's properties. 上面 所说 的 路径 都 是 相对 于 当前 数据 绑定 (data-binding scope) 定 的 。 最 外层 的 域 就是 当前 元素 的 本身 (this)， 但 一些 数据 绑定 辅助 元素 ( 比如 : template repeaters) 可以 创建 新 的 子域 。 观察 函数 (observers) 和 计算 属性 computed properties 的 域 永远都是 当前 元素 本身 (this)Special paths 通 配 路径 (Wildcard paths)- 可以 使用 通配符 ` 来 表示 当前 路径 下 的 所有 子 路径 的 任何 变化 。 比如 users 指向 一个 数组 ,users.` 代表 该 数组 的 所有 变化 splices-  可以 用 在 数组 路径 后面 ， 代表 数组 任何 添加 、 删除 的 变化 数组 路径 后面 接下 标 代表 数组 里面 对应 的 项 ， 比如 users.12 注意 ： 通配符 只能 用 在 observers、computed properties 里面 的 路径 中 ， 不能 用 在 数据 绑定 里 观察 splices 路径 时 ， 事件 参数 中 只 提供 当前 数组 发生变化 的 元素 组成 的 子 数组 ， 所以 在 一般 情况 下 通配符 路径 比 splices 路径 要 实用 Two paths referencing the same object 如果 两条 路径 都 指向 同一个 对象 , 如下 图 , 需要 使用 linkPaths 方法 将 它们 关联 起来 。 注意 ： 两条 路径 必须 在 同一个 data scope 下 如果 需要 接触 两条 路径 的 关联 ， 使用 unlinkPaths,  该 函数 只 接受 linkPaths 调用 时 的 第一条 路径 Data flow>Polymer implements the mediator pattern, where a host element manages data flow between itself and its local DOM nodes.>When two elements are connected with a data binding, data changes can flow downward, from host to target, upward, from target to host, or both ways.>When two elements in the local DOM are bound to the same property data appears to flow from one element to the other, but this flow is mediated by the host. A change made by one element propagates up to the host, then the host propagates the change down to the second element.Polymer 的 数据流 是 一个 中间人 模型 。 任何 存在 数据 绑定 的 两个 元素 直接 的 数据流 都 不是 表面 上 的 直接 传递 的 ， 而是 先 向上 传递 (upward) 到 host 元素 再 向下 传递 (downward) 到 目标 元素 。> Data flow is synchronous. When your code makes an observable change, all of the data flow and property effects from that change occur before the next line of your JavaScript is executed, unless an element explicitly defers action (for example, by calling an asynchronous method).Polymer 的 数据 传递 是 同步 的 ， 除非 调用 一个 外部 异步 函数 How data flow is controlled 数据流 的 方向 主要 由 两个 地方 控制 ： 数据 绑定 方式 和 属性 配置 项 。 数据 绑定 主要 有 两种 方式 ：Automatic ： 双向 绑定 ， 包括 向上 (upward,target to host) 和 向下 (downward.host to target), 使用  \\{\\{ \\}\\}One-way : 单向 绑定 ， 仅 向下 (downward.host to target)， 使用 [[ ]]     属性 配置 项 具体 有 两项 ：notify  允许 数据 向上 (upward,target to host) 传递 ， 默认 为 falsereadOnly  禁止 数据 向下 (downward.host to target) 传递 到 当前 组件 ， 默认 false 属性 配置 实例 ：properties: {  // default prop, read/write, non-notifying.  basicProp: {  },  // read/write, notifying  notifyingProp: {    notify: true  },  // read-only, notifying  fancyProp: {    readOnly: true,    notify: true  }} 注意 ： 当 使用 单向 绑定 的 时候 ，notify 配置 项 无效 。 当 单向 绑定 且 readOnly:true 时 ， 将 没有 任何 数据流 >**Property configuration only affects the property itself, notsubproperties**. In particular, binding a property that's an object or array creates shared databetween the host and target element. There's no way to prevent either element from mutating a sharedobject or array. 属性 配置 不能 继承 Data flow examples 参考 :Data flow examplesUpward and downward data flow>Since the host element manages data flow, it can directly interact with the target element. The hostpropagates data downward by setting the target element’s properties or invoking its methods.host 元素 可以 直接 通过 设置 target 元素 属性 或 调用 回调 函数 等 方法 将 数据 向下 传递 给 target 元素 >Polymer elements use events to propagate data upward. The target element fires a non-bubbling eventwhen an observable change occurs. 当 数据 是 双向 绑定 的 时候 ，target 元素 通过 触发 一个 non-bubbling 的 change 事件 来 将 数据 传递 给 监听 这个 事件 的 host 元素 ，host 元素 监听 到 事件 后 对 数据 变化 做出 响应 改变 数据 绑定 模型 （ 可能 影响 相邻 元素 ） 并 触发 另外 一个 change 事件 向上 传播 。 当 数据 是 单向 绑定 的 时候 ，host 元素 不会 监听 target 元素 的 change 事件 ， 因此 数据 无法 向上 传递 。Data flow for objects and arrays>For object and array properties, data flow is a little more complicated. An object or array can bereferenced by multiple elements, and there's no way to prevent one element from mutating a sharedarray or changing a subproperty of an object.As a result, Polymer treats the contents of arrays and objects as always being available for two-way binding. That is:>*   Data updates always flow downwards, even if the target property is marked read-only.>*   Change events for upward data flow are always fired, even if the target property is not marked    as notifying.>>Since one-way binding annotations don't create an event listener, they prevent these changenotifications from being propagated to the host element. 对于 objects 和 arrays 绑定 的 数据流 非常复杂 ， 不得已 Polymer 将 忽略 关于 它们 所有 的 readyOnly 和 notify 配置 项 ， 并 将 它们 hardcode 为 true， 单项 绑定 和 双向 绑定 不 受 影响 。Change notification events 当 一个 元素 某 路径 比如 property 发生变化 ， 则 会 响应 的 触发 一个 property-changed 的 通知 事件 。 事件 内容 根据 路径 类型 相关 ： 属性 变化 ：  新 值 将 储存 detail.value 中子 属性 变化 ： 子 属性 的 路径 将 会 储存 在 detail.path 中 ， 新 值 将 会 储存 在 detail.value 中 。 数组 变化 ： 变化 路径 将 会 储存 在 detail.path 中 ( 比如 ： myArray.splices)， 新 值 将 会 被 储存 在 detail.value 中 。>Don't stop propagation on change notification events. To avoid creating and discarding>event objects, Polymer uses cached event objects for change notifications. Calling stopPropagation>on a change notification event prevents all future events for that property. Change notification>events don't bubble, so there should be no reason to stop propagation. 注意 ：  不要 在 通知 事件 里面 使用 stopPropagationCustom change notification events 一些 Native 元素 比如 `` 并 不 存在 变化 通知 事件 ， 因此 也 不能 将 数据 向上 传递 。 可以 通过 下面 的 方式 手动 自定义 一个 变化 通知 事件 ：>In this example, the firstName property is bound to the input's value property. Whenever theinput element fires its change event, Polymer updates the firstName property to match the inputvalue, and invokes any associated property effects. The contents of the event aren't important.>This technique is especially useful for native input elements, but can be used to provide two-waybinding for any non-Polymer component that exposes a property and fires an event when the propertychanges.Property effects 当 属性 变化 的 时候 ， 下面 的 任务 会 依次 执行 ： 重写 计算 受到 影响 的 属性 的 值  -  此 步 将 会 更新 计算 属性 (computed properties) 更新 数据 绑定 更新 host 元素 上面 的 html 属性 执行 观察 事件 observers 触发 变化 通知 事件 ","title":"Polymer 2.0  文档 笔记 (4) Data System","oriTitle":"Polymer 2.0 文档笔记(4) Data System"},{"uri":"/posts/polymer-2-5-observers-and-computed-properties","tags":["Polymer"],"content":" 有 两种 监听器 ： 简单 监听器 ， 只能 监听 单一 的 property 复杂 监听器 ： 可以 监听 一 到 多个 property 每个 监听器 都 有 一个 或 多个   依赖  ， 当 依赖 发生 可 监听 的 变化 是 ， 监听 方法 就 会 被 调用 。>Computed properties are virtual properties based on one or more pieces of the element's data. Acomputed property is generated by a computing function—essentially, a complex observer that returnsa value. 计算 属性 顾名思义 ， 是 由 一个 返回 某个 值 的 计算 函数 算 出来 的 属性 。Observers and element initialization 只有 当 元素 初始值 加载 完毕 并且 至少 有 一个 依赖 的 属性 被 定义 (undefined => somevalue)， 监听器 才 会 被 调用 。Observers are synchronous 监听器 的 执行 也 是 同步 的 如果 监听器 调用 比较 频繁 ， 影响 效率 ， 可以 使用 Polymer.Async 库 来 将 它 放到 异步 任务 队列 里面 去 。Polymer 不 保证 异步 执行 的 监听器 所 传 的 参数 是否是 最新 的 Simple observers 简单 监听器 需要 在 properties 中 需要 监听 的 property 里面 注册 。 监听 函数 里面 不能 依赖 其他 任何 property> Simple observers are fired the first time the property becomes defined (!= undefined), and onevery change thereafter, even if the property becomes undefined. 简单 监听器 第一次 触发 在 property 被 定义 后 (undefined => somevalue)， 在此之后 ， 任何 property 变化 ( 包括 重新 变 回 undefined) 都 会 被 调用 。>Simple observers only fire when the property itself changes. They don't fire on subpropertychanges, or array mutation. 简单 监听器 只 会 响应 当前 property 的 可 观察 变化 (observable changes)>You specify an observer method by name. The host element must have a method with that name. 简单 监听器 的 定义 和 实现 ( 函数 本身 ) 必须 一一对应 , 简单 监听器 的 实现 可以 在 当前 class 里面 也 可以 继承 自 superclass 也 可以 添加 自 mixin。>The observer method receives the new and old values of the property as arguments. 简单 监听器 接受 两个 参数 ： oldValue,newValueObserve a propertyclass XCustom extends Polymer.Element {  static get is() {return 'x-custom'; }  static get properties() {    return {      active: {        type: Boolean,        // Observer method identified by name        observer: '_activeChanged'      }    }  }  // Observer method defined as a class method  _activeChanged(newValue, oldValue) {    this.toggleClass('highlight', newValue);  }}Complex observers 复杂 监听器 需要 在 this.observers 数组 里面 注册 ， 复杂 监听器 可以 监听 多条 路径 （ 依赖 ）static get observers() {  return [    // Observer method name, followed by a list of dependencies, in parenthesis    'userListChanged(users.*, filter)'  ]} 注册 函数 里面 的 参数 有 如下 几种 ： 一个 简单 的 属性 路径  (firstName). 一个 简单 的 子 属性 路径  (address.street). 一个 数组 的 变化 结果 路径  (users.splices). 一个 包含 通配符 的 路径  (users.*). 函数 被 调用 时 所 得到 的 参数 依据 监听 的 路径 种类 不同 而 不同 ： 简单 的 属性 或 子 属性 ， 传 参 为 新 值 数组 变化 路径 ， 传 参 为 描述 变化 详情 的   变化 记录   对象 通配符 路径 ， 传 参 为   变化 记录   对象 以及 变化 的 详细 路径 >Note that any of the arguments can be undefined when the observer is called. 监听 函数 中 每次 调用 ， 任何 一个 参数 都 有 可能 是 undefined 复杂 监听器 的 参数 只有 新 值 没有 旧 值 Observe changes to multiple propertiesclass XCustom extends Polymer.Element {  static get is() {return 'x-custom'; }  static get properties() {    return {        preload: Boolean,        src: String,        size: String    }  }  // Each item of observers array is a method name followed by  // a comma-separated list of one or more dependencies.  static get observers() {    return [        'updateImage(preload, src, size)'    ]  }  // Each method referenced in observers must be defined in  // element prototype. The arguments to the method are new value  // of each dependency, and may be undefined.  updateImage(preload, src, size) {    // ... do work using dependent values  }}Observe array mutations 数组 变化 路径 的 参数 change record 是 一个 对象 ， 包含 一个 indexSplices 数组 ， 数组 中 的 每一项 表示 一处 变更 记录 ， 包含 下面 信息 ：index.  变更 其实 的 地方 removed.  被 删除 的 数据 addedCount.  插入 的 数据 长度 object:  一个 指向 新 数据 的 数组 （ 不是 拷贝 ）  //A reference to the array in question.  这 句 话 不 懂 什么 意思 type:  一个 值 为 'splice' 的 字符串 注意 ： change record 也许 会 为 undefinedclass XCustom extends Polymer.Element {  static get is() {return 'x-custom'; }  static get properties() {    return {      users: {        type: Array,        value: function() {          return [];        }      }    }  }  // Observe changes to the users array  static get observers() {    return [      'usersAddedOrRemoved(users.splices)'    ]  }  // For an array mutation dependency, the corresponding argument is a change record  usersAddedOrRemoved(changeRecord) {    if (changeRecord) {      changeRecord.indexSplices.forEach(function(s) {        s.removed.forEach(function(user) {          console.log(user.name + ' was removed');        });        for (var i=0; i    class XCustom extends Polymer.Element {      static get is() { return 'x-custom'; }      static get properties() {        return {          user: {            type: Object,            value: function() {              return {'name':{}};            }          }        }      }      static get observers() {        return [            'userNameChanged(user.name.*)'        ]      }      userNameChanged(changeRecord) {        console.log('path: ' + changeRecord.path);        console.log('value: ' + changeRecord.value);      }    }    customElements.define(XCustom.is, XCustom);Identify all dependencies>Observers shouldn't rely on any properties, sub-properties, or paths otherthan those listed as dependencies of the observer. This creates \"hidden\" dependencies 监听器 不能 依赖 任何 其他 未 被 注册 过 的 路径 ， 否则 ： 不能 保证 该 路径 是否 已经 初始化 完成 当 该 路径 的 属性 发生变化 时 ， 无法 触发 当前 监听器 For example:static get properties() {  return {    firstName: {      type: String,      observer: 'nameChanged'    },    lastName: {      type: String    }  }}// WARNING: ANTI-PATTERN! DO NOT USEnameChanged(newFirstName, oldFirstName) {  // Not invoked when this.lastName changes  var fullName = newFirstName + ' ' + this.lastName;  // ...}>Note that Polymer doesn't guarantee that properties areinitialized in any particular order.Polymer 不能 保证 属性 之间 的 初始化 顺序 。Computed properties>Computed properties are virtual properties computed on the basis of one or more paths. The computingfunction for a computed property follows the same rules as a complex observer, except that itreturns a value, which is used as the value of the computed property. 计算 属性 定义 跟 复杂 监听器 类似 ， 但是 计算 属性 的 计算 函数 需要 返回 一个 值 。Define a computed property 计算 属性 需要 在 properties 里面 的 property 配置 对象 中 使用 computed 键 注册 ， 注册 语法 跟 复杂 监听器 一致 。    My name is {{fullName}}    class XCustom extends Polymer.Element {      static get is() { return 'x-custom'; }      static get properties() {        return {          first: String,          last: String,          fullName: {            type: String,            // when first or last changes computeFullName is called once            // and the value it returns is stored as fullName            computed: 'computeFullName(first, last)'          }        }      }      computeFullName(first, last) {        return first + ' ' + last;      }    }    customElements.define(XCustom.is, XCustom); 另外 见  ： Computed BindingsDynamic observer methods>If the observer method is declared in the properties object, the method is considered dynamic:the method itself may change during runtime. A dynamic method is considered an extra dependency ofthe observer, so the observer re-runs if the method itself changes. For example: 如果 一个 监听器 或者 计算 属性 的 方法 被 定义 在 了 properties 里面 ， 那么 我们 可以 动态 的 对 这个 方法 进行 覆盖 、 重写 。 当 方法 发生变化 的 时候 ， 新 的 简单 监听器 或 计算 属性 会 被 立即 触发 或者 被 更新 。class NameCard extends Polymer.Element {  static get is() {    return 'name-card'  }  static get properties() {    return {      // Override default format by assigning a new formatter      // function      formatter: {        type: Function      },      formattedName: {        computed: 'formatter(name.title, name.first, name.last)'      },      name: {        type: Object,        value() {         return { title: \"\", first: \"\", last: \"\" };        }      }    }  }  constructor() {    super();    this.formatter = this.defaultFormatter;  }  defaultFormatter(title, first, last) {    return ${title} ${first} ${last}  }}customElements.define('name-card', NameCard);nameCard.name = { title: 'Admiral', first: 'Grace', last: 'Hopper'}console.log(nameCard.formattedName); // Admiral Grace HoppernameCard.formatter = function(title, first, last) {  return ${last}, ${first}}console.log(nameCard.formattedName); // Hopper, Grace 计算 属性 formattedName 的 方法 formatter 发生变化 的 时候 , 尽管 依赖 name 没有 变化 ， 但是 该 属性 还是 触发 更新 了 。 因为 动态 监听器 方法 出于 properties 里面 ， 因此 会 被 看作 一个 依赖 ， 一旦 这个 方法 被 定义 ， 监听器 就 在 初始化 的 时候 触发 ， 尽管 其他 依赖 都 没有 被 定义 。Add observers and computed properties dynamically>In some cases, you may want to add an observer or computed property dynamically. A set of instancemethods allow you to add a simple observer, complex observer, or computed property to the currentelement instance. 使用 js API 来 动态 添加 计算 属性 或 监听器 _createPropertyObserver_createMethodObserver_createComputedPropertyAdd a simple observer dynamicallythis._observedPropertyChanged = (newVal) => { console.log('observedProperty changed to ' + newVal); };this.createPropertyObserver('observedProperty', 'observedPropertyChanged', true); 第三个 参数 代表 这个 方法 (_observedPropertyChanged) 是否 应该 被 看作 一个 依赖 Add a complex observer dynamicallythis.createMethodObserver('observeSeveralProperties(prop1,prop2,prop3)', true); 第三个 参数 代表 这个 方法 (_observeSeveralProperties) 是否 应该 被 看作 一个 依赖 Add a computed property dynamicallythis.createComputedProperty('newProperty', 'computeNewProperty(prop1,prop2)', true); 第三个 参数 代表 这个 方法 (_computeNewProperty) 是否 应该 被 看作 一个 依赖 ","title":"Polymer 2.0  文档 笔记 (5) Observers && Computed Properites","oriTitle":"Polymer 2.0 文档笔记(5) Observers && Computed Properites"},{"uri":"/posts/polymer-2-6-data-binding","tags":["Polymer"],"content":"A data binding connects data from a custom element (the host element) to a property or attribute of an element in its local DOM (the childor target element). The host element data can be a property or sub-property represented by a data path, or data generated based on one or more paths. 数据 绑定 能够 将 host 元素 和 target 元素 的 property 或者 attribute 相互 链接 床单 。 这里 数据 指 的 是 路径 (Paths)Anatomy of a data binding 数据 绑定 有 两种 绑定 方式 ：= 绑定 property,$= 绑定 attribute(href,style,...)annotation 代表 数据 绑定 标记 : [[ ]] 或者 \\{\\{ \\}\\}compound-binding: 包含 标记 的 字符串 : \"my name is {{ name }}\"Bind to a target property 将 target 元素 的 name 属性 绑定 到 当前 元素 的 my-Name 属性 。 注意 驼峰 式 和 dash 式 命名 的 转换规则 (property name to attribute name mapping)Bind to text content 相当于 绑定 到 target 元素 的 textContent 属性 上     [[name]]    class UserView extends Polymer.Element {      static get is() {return 'user-view'}      static get properties() {        return {          name: String        }      }    }    customElements.define(UserView.is, UserView);>Binding to text content is always one-way, host-to-target. 注意 ， 文字 节点 的 绑定 永远都是 单向 的 (host to target)Bind to a target attributeattribute 绑定 相当于 element.setAttribute(attr,value)property 绑定 相当于 element.property = 'value' 因此 ， 一些 attribute 同样 可以 使用 property 形式 绑定 ：  .setAttribute('selected', this.value); -->  .selected = this.value; --> 需要 注意 的 是 ： attribute 形式 的 数据 绑定 只能 是 单向 的 ([[ ]])Native properties that don't support property binding>There are a handful of common native element properties that Polymer can't data-bind to directly,because the binding causes issues on one or more browsers. 一些 原生 的 property 无法 使用 = 绑定 数据 ， 需要 使用 attribute 形式 的 $= 才能 成功 绑定 。| Attribute | Property | Notes ||----|----|----|| class | classList, className | Maps to two properties with different formats. || style | style | By specification, style is considered a read-only reference to a CSSStyleDeclaration object. || href | href | || for | htmlFor | || data-* |  dataset | Custom data attributes (attribute names starting with data-) are stored on the dataset property. || value | value | Only for ``. |>data binding to the value property doesn't work on IE for numeric input types. Forthis specific case, you can use one-way attribute binding to set the value of a numeric input. Oruse another element such as iron-input or paper-input that handles two-way binding correctly.Logical not operator 可以 在 data-binding 表达式 前面 添加 ! 号 取反 注意 ： 逻辑 非 只能 用 在 单项 绑定 中 使用 只能 有 一个 ! 不能 !!Computed bindingscomputed binding 类似 于 computed property。[[_formatName(first, last, title)]]>An element can have multiple computed bindings in its template that refer to the same computingfunction. 一个 元素 里面 可以 有 多个 使用 同样 的 computing function 的 computed bindingcomputed binding 并 不 完全 等同于 computed property， 差异 有 下面 几点 ：computed binding 的 依赖 路径 是 相对 于 元素 当前 的 data scope 的 computed binding 的 参数 不仅 可以 有 computed property 那样 的 路径 参数 ， 也 可以 是 单纯 的 字符串 或者 数字 等 computed binding 可以 没有 参数 ， 这种 情况 下 ， 函数 只 会 被 调用 一次 computed binding 函数 要 等 所有 的 参数 中 的 依赖 全部 初始化 (!=undefined) 之后 才 会 执行     My name is [[_formatName(first, last)]]    class XCustom extends Polymer.Element {      static get is() {return 'x-custom'}      static get properties() {        return {          first: String,          last: String        }      }      _formatName(first, last) {        return ${last}, ${first}      }    }    customElements.define(XCustom.is, XCustom);>Commas in literal strings: Any comma occurring in a string literal must be escaped using abackslash (\\). 如果 参数 是 字符串 ， 那么 字符串 里面 所有 的 逗号 都 要 被 转义     {{translate('Hello\\, nice to meet you', first, last)}}>Computed bindings are one-way. A computed binding is always one-way, host-to-target.computed binding 只能 在 单向 绑定 中 使用 Compound bindings 可以 在 字符串 里面 或者 textContent 里面 使用 绑定 标记 Name: [[lastname]], [[firstname]] 注意 ：undefined 会 输出 成 空 字符串 Compound binding 永远 是 单向 绑定 ， 虽然 你 也 可以 使用 \\{\\{ \\}\\} 记号 。Binding to array items>To keep annotation parsing simple, **Polymer doesn't provide a way to bind directly to an arrayitem**. 为了 解析 简单 ，Polymer 无法 直接 绑定 一个 数组 里面 的 元素 {{array[0]}}{{array.0}} 有 下面 几种 方法 可以 解决 ：dom-repeat 里面 已经 为 每个 数组 里面 的 元素 创建 了 一个 子 scope， 因此 可以 直接 bindingarray-selector  同 上 ， 可以 直接 绑定 一个 元素 或者 被 选择 的 元素 集合 使用 computed binding 来 间接 绑定 ， 见 下面 例子     [[arrayItem(myArray.*, 0, 'name')]]    [[arrayItem(myArray.*, 1, 'name')]]    class XCustom extends Polymer.Element {      static get is() {return 'x-custom'}      static get properties() {        return {          myArray: {            type: Array,            value: [{ name: 'Bob' }, { name: 'Doug' }]          }        }      }      // first argument is the change record for the array change,      // change.base is the array specified in the binding      arrayItem(change, index, path) {        // this.get(path, root) returns a value for a path        // relative to a root object.        return this.get(path, change.base[index]);      },      ready() {        super.ready();        // mutate the array        this.unshift('myArray', { name: 'Susan' });        // change a subproperty        this.set('myArray.1.name', 'Rupert');      }    }    customElements.define(XCustom.is, XCustom);Two-way binding to a non-Polymer element 为了 达到 非 Polymer 元素 上面 的 双向 绑定 ， 可以 使用 下面 的 标记 ：target-prop=\"{{hostProp::target-change-event}}\".value -->.checked -->.currentTime --> 基于 约定 大于 配置 的 原理 ， 如果 target-prop 的 变化 通知 函数 是 target-prop-changed 则 该 定义 可以 省略 。","title":"Polymer 2.0  文档 笔记 (6) Data Binding","oriTitle":"Polymer 2.0 文档笔记(6) Data Binding"},{"uri":"/posts/polymer-2-7-helper-element","tags":["Polymer"],"content":"Polymer 提供 一系列 的 自定义 元素 来 简化 一些 共有 的 数据 绑定 逻辑 ：dom-repeat  遍历 显示 数组 array-selector  数组 选择器 dom-if  条件 显示 dom-bind  自动 绑定 >2.0 tip. The data binding helper elements are bundled in to the backward-compatible,polymer.html import. If you aren't using the legacy import, you'll need to import thehelper elements you're using. 为了 向前 兼容 ，polymer.html 引入 了 所有 的 helper 元素 ， 而 2.0 的 polymer.Element 则 要 按照 需要 一个个 手动 引入 。Template repeater (dom-repeat)dom-repeat 需要 绑定 一个 数组 ， 遍历 显示 里面 元素 ， 并 为 每个 数组 元素 创建 一个 新 的 data scope， 包括 下面 两个 属性 ：item  数组 元素 index  元素 下 标有 两种 用法 : 在 Polymer element template 内部 ， 可以 直接 使用 简写         ...     在 Polymer element template 外部 ， 使用 `` 标签             ...         在 这种 情况 下 ， 还 需要 手动 使用 js 给 `` 标签 设置 数据 ：            var repeater = document.querySelector('dom-repeat');        repeater.items = someArray;     Employee list:[[index]]        First name: [[item.first]]        Last name: [[item.last]]    class XCustom extends Polymer.Element {      static get is() { return 'x-custom'; }      static get properties() {        return {          employees: {            type: Array,            value() {              return [                {first: 'Bob', last: 'Smith'},                {first: 'Sally', last: 'Johnson'},              ];            }          }        }      }    }    customElements.define(XCustom.is, XCustom); 需要 使用 可 被 监听 的 手段 去 更改 dom-repeat 绑定 的 数组 // Use Polymer array mutation methods:this.push('employees', {first: 'Diana', last: 'Villiers'});// Use Polymer set method:this.set('employees.2.last', 'Maturin');// Use native methods followed by notifyPaththis.employees.push({first: 'Barret', last: 'Bonden'});this.notifyPath('employees');Handling events in dom-repeat templates {#handling-events}>When handling events generated by a dom-repeat template instance, youfrequently want to map the element firing the event to the model data thatgenerated that item.>When you add a declarative event handler inside the `` template,the repeater adds a model property to each event sent to the listener. The modelobject contains the scope data used to generate the template instance, so the itemdata is model.item: 当 你 帮 定义 一个 事件 到 dom-repeat 的 内部 元素 之后 ， 事件 参数 e 会 有 一个 model 项 ， 代表 着 当前 元素 的 data scope.          {{item.name}}          {{item.ordered}}          Order    class XCustom extends Polymer.Element {      static get is() { return 'x-custom'; }      static get properties() {        return {          menuItems: {            type: Array,            value() {              return [                {name: 'Pizza', ordered: 0},                {name: 'Pasta', ordered: 0},                {name: 'Toast', ordered: 0}              ];            }          }        }      }      order(e) {        e.model.set('item.ordered', e.model.item.ordered+1);      }    }    customElements.define(XCustom.is, XCustom);>The model is an instance of TemplateInstance, which provides the Polymerdata APIs: get, set, setProperties, notifyPath and the array manipulation methods.You can use these to manipulate the model, using paths relative to template instance.model 也 是 一个 TemplateInstance 的 子类 ， 提供 了 get,set,setProperties,notifyPath 等 data API 只有 在 dom-repeat 里面 绑定 过 的 属性 才 会 赋 给 model， 如 下面 例子 ， 将 productId 绑定 到 不 可见 的 自定义 属性 上 ， 以便 将 productId 添加 到 model 对象 中 。    [[product.name]]Handling events outside the dom-repeat template.>The model property is not added for event listeners registered imperatively (using addEventListener), or listeners added to one of the dom-repeat template's parent nodes. In these cases, you can use the dom-repeat modelForElement method to retrieve the model data that generated a given element. (There are also corresponding itemForElement and indexForElement methods.) 外部 如果 使用 标准 的 DOM APIaddEventListener 来 监听 子 元素 的 事件 时 ， 则 事件 参数 里面 没有 e.model 属性 ， 可以 使用 下面 几个 函数 手动 获得 ：dom-repeat.modelForElementdom-repeat.itemForElementdom-repeat.indexForElementFiltering and sorting lists>To filter or sort the displayed items in your list, specify a filter orsort property on the dom-repeat (or both): 可以 在 dom-repeat 上 指定 filter 或 sort 的 方法 。 默认 ，filter 和 sort 方法 只 在 两种 情况 下 被 调用 ： 数组 发生 可 被 监控 的 变化 (observable change) 两者 方法 被 动态 重现 、 改变 使用 render 方法 强制 filter 和 sort 方法 重新 执行 。（ 见 Forcing synchronous renders）>To re-run the filter or sort functions when certain sub-fields of items change, set the observe property to a space-separated list of item sub-fields that should cause the list to be re-filtered or re-sorted. 如果 filter/sort 是 依据 数组 元素 的 某 一个 子 属性 来 排序 的 ， 需要 在 dom-repeat 标签 上 设置 一个 observe 属性 ， 将 过滤 或 排序 依据 的 子 属性 按照 空格 连接起来 的 字符 设 为 它 的 值 。 比如 ， 下面 这个 例子 ， 设置 一个 叫 isEngineer 的 filter：isEngineer: function(item) {    return item.type == 'engineer' || item.manager.type == 'engineer';} 在 dom-repeat 标签 上 设置 过滤器 所 使用 过 的 元素 子 属性 type manager.type 修改 第 0 个 元素 中 的 manager.type 将 会 导致 整个 列表 重新 过滤 this.set('employees.0.manager.type', 'engineer');Dynamic sort and filter changesobserve 属性 并 不能 完全 解决 所有 需求 ， 也许 filter/sort 函数 需要 用到 其他 地方 的 变量 ， 因此 我们 可以 实现 一个 computed binding 来 动态 返回 一个 filter/sort 函数         {{employee.lastname}}, {{employee.firstname}}    class XCustom extends Polymer.Element {      static get is() { return 'x-custom'; }      static get properties() {        return {          employees: {            type: Array,            value() {              return [                { firstname: \"Jack\", lastname: \"Aubrey\" },                { firstname: \"Anne\", lastname: \"Elliot\" },                { firstname: \"Stephen\", lastname: \"Maturin\" },                { firstname: \"Emma\", lastname: \"Woodhouse\" }              ]            }          }        }      }      computeFilter(string) {        if (!string) {          // set filter to null to disable filtering          return null;        } else {          // return a filter function for the current search string          string = string.toLowerCase();          return function(employee) {            var first = employee.firstname.toLowerCase();            var last = employee.lastname.toLowerCase();            return (first.indexOf(string) != -1 ||                last.indexOf(string) != -1);          };        }      }    }    customElements.define(XCustom.is, XCustom);Filtering on array index>Because of the way Polymer tracks arrays internally, the array index isn't passed to the filter function. Looking up the array index for an item is an O(n) operation. Doing so  in a filter function could have significant performance impact. 不能 获得 数组 索引 ， 只能 通过 this.items 获得 原来 数组 ， 再 通过 indexOf 方法 获得 索引 ， 效率 低下 。 注意 ，filter/sort 方法 中 ， 不是 数组 元素 所 创建 的 子 data scopefilter: function(item) {  var index = this.items.indexOf(item);  ...}Nesting dom-repeat templates {#nesting-templates}>When nesting multiple dom-repeat templates, you may want to access datafrom a parent scope. Inside a dom-repeat, you can access any properties availableto the parent scope unless they're hidden by a property in the current scope. 比如 类 继承 一样 ， 子 scope 中 可以 取 父 scope 的 所有 没有 被 覆盖 的 属性 。>To access properties from nested dom-repeat templates, use the as attribute toassign a different name for the item property. Use the index-as attribute to assign adifferent name for the index property. 可以 使用 as 标记 来 对 默认 的 item 来 重命名 可以 使用 index-as 标记 来 对 默认 的 index 来 重命名  Employee list:    First name: {{employee.first}}    Last name: {{employee.last}}    Direct reports:      {{report_no}}.           {{report.first}} {{report.last}}Forcing synchronous renders 默认 的 dom-repeat 是 异步 执行 的 ， 但是 可以 调用 render 方法 使 之 立即 同步 渲染 。 此 方法 性能 代价 比较 大 ， 适用 于 下面 几种 情况 ： 单元测试 的 时候 保证 检查 之前 所有 的 选项 都 被 渲染 完毕 在 要 滚动 到 某 一 特定 元素 之前 保证 其 已经 渲染 完毕 当 外部 数据 变化 导致 的 sort/filter 方法 需要 重新 运行 注意 ： render 方法 只 会 更新 模型 数据 的 Observable change， 如果 要 全局 更新 见 下 一节 。Forcing the template to update 强制 刷新 列表 元素 ， 像 之前 所说 过 的 三种 解决方案 ：notifySplices， 如果 你 知道 数组 的 具体 变更 方式 克隆 数组 ， 如果 必要 ， 可以 深度 克隆 ， 性能 不 佳 使用 mutableData 标签 再 this.notifyPath(items)Improve performance for large lists 当 列表 数据量 很大 的 时候 ，dom-repeat 支持 延迟 加载 。 设置 initialCount 属性 ， 可以 启动 chunked mode，dom-repeat 首先 会 渲染 initialCount 个 元素 ， 然后 按照 一个 animation frame 一 chunk 的 形式 渲染 其他 元素 ， 这样 能够 让 UI 在 渲染 的 过程 中 处理 用户 的 输入 。 可以 查看 renderedItemCount 属性 （ 只读 ） 来 获得 当前 已 被 渲染 的 元素 总数 。>dom-repeat adjusts the number of items rendered in each chunk to try and maintain a target framerate. You can further tune rendering by setting targetFramerate.dom-repeat 尝试 去 维护 一个 targetFramerate 函数 来 调整 每 一个 渲染 的 chunk 里面 的 元素 个数 ， 具体 ：targetFramerateData bind an array selection (array-selector)>Keeping structured data in sync requires that Polymer understand the path associations of data being bound.  The array-selector element ensures path linkage when selecting specific items from an array.array-selector  可以 选择 数组 里面 的 元素 ， 并 自动 把 选择 出来 的 元素 的 路径 跟 这些 元素 的 原来 路径 进行 连接 。(linkPaths)     Employee list:        First name: {{item.first}}        Last name: {{item.last}}        Select     Selected employees:        First name: {{item.first}}        Last name: {{item.last}}    class XCustom extends Polymer.Element {      static get is() { return 'x-custom'; }      static get properties() {        return {          employees: {            type: Array,            value() {              return [                {first: 'Bob', last: 'Smith'},                {first: 'Sally', last: 'Johnson'},                // ...              ];            }          }        }      }      toggleSelection(e) {        var item = this.$.employeeList.itemForElement(e.target);        this.$.selector.select(item);      }    }    customElements.define(XCustom.is, XCustom);items 属性 接收 一个 数组 。 两个 常见 API: select(item)\\deselect(item) 对于 数组 元素 子 属性 的 任何 变化 都 会 同步 到 items 数组 中 （path 已经 link 了 ）multi 属性 可以 开关 多 选 Conditional templates (dom-if)dom-if  可以 按 条件 来 显示 其中 的 内容 。 最 开始 的 时候 dom-if 中 没有 元素 ， 当 把 if 属性 设置 为 true 时 里面 就 会 出现 template 中 的 的 元素 ， 当 if 属性 再次 变为 false 时 ， 其 内部 元素 默认 不会 被 删除 ， 而是 直接 隐藏 。 可以 设置 restamp 为 true 来 禁止 这种 隐藏 行为 。 跟 dom-if 一样 ， 有 两种 方式 来 定义 ： 在 Polymer element template 内部 ， 使用 简写 方式       ...     在 Polymer element template 外部 ， 使用 `` 标签         ...         这种 情况 需要 手动 设置 dom-if 的 属性 ：        var conditional = document.querySelector('dom-if');    conditional.if = true; 代码 实例 ：      class XCustom extends Polymer.Element {        static get is() { return 'x-custom'; }        static get properties() {          return {            user: Object          }        }      }      customElements.define(XCustom.is, XCustom);  >Conditional templates introduce some overhead, so they shouldn't be used for small UI elements that could be easily shown and hidden using CSS. 条件 模板 会 引入 一些 开销 ， 因此 不 适合 一些 可以 直接 设置 CSS 来 控制 显示 和 隐藏 的 小 元素 。 但是 条件 模板 也 适用 于 下面 几种 情况 ： 懒惰 加载 节省 大型 复杂 网站 的 内存 消耗 （restam=true 会 带来 性能 上 的 损失 ）Auto-binding templates (dom-bind）>Polymer data binding is only available in templates that are managed by Polymer. So data binding works inside an element's DOM template (or inside a dom-repeat or dom-if template), but not for elements placed in the main document.>To use Polymer bindings without defining a new custom element, use the ` element.  This template immediately stamps the contents of its child templateinto the main document. Data bindings in an auto-binding template use the ` element itself as the binding scope.Polymer 的 数据 绑定 只能 在 template 中 ， 为了 简化 流程 ， 使用 自动 绑定 (``) 能够 在 不 定义新 的 自定义 元素 的 前提 下 进行 数据 绑定 。        {{item.name}}: {{item.price}}    var autobind = document.querySelector('dom-bind');    // The dom-change event signifies when the template has stamped its DOM.    autobind.addEventListener('dom-change', function() {      console.log('template is ready.')    });    // set data property on dom-bind    autobind.data = [      { name: 'book', price: '$5.00'},      { name: 'pencil', price: '$1.00'},      { name: 'flux capacitor', price: '$8,000,000.00'}    ]; 注意 ： 自动 绑定 只能 在 Polymer element 之外 定义 ( 因此 只有 一种 定义 方式 )dom-bind 也 提供 了 一个 render 方法 来 进行 强制 同步 刷新 。dom-bind 同样 也 用 一个 mutableData 属性 来 开关 脏 检测 机制 。dom-change event>When one of the template helper elements updates the DOM tree, it fires a dom-change event. 当 任意 一个 template helper elements 更新 了 DOM 树 时 ， 它们 都 会 触发 一个 dom-change 事件 。>In most cases, you should interact with the created DOM by changing the model data, not by interacting directly with the created nodes. For those cases where you need to access the nodes directly, you can use the dom-change event. 原则上 ， 我们 不 应该 直接 与 DOM 进行 交互 ， 而 应该 修改 对应 的 模型 数据 。 如果 的确 需要 这样 做 的话 ， 可以 监听 这个 的 dom-change 事件 来 完成 。","title":"Polymer 2.0  文档 笔记 (7) Helper Element","oriTitle":"Polymer 2.0 文档笔记(7) Helper Element"},{"uri":"/posts/pygobject-tutorial-1","tags":["python","gtk"],"content":" 基础 这 章 将 会 介绍 GTK+ 比较 重要 的 几个 方面 主 循环 和 信号 就 像 大部分 GUI 库 一样 ，GTK+ 使用 了 一种 事件驱动 的 编程 模型 。 当 用户 什么 都 没 做 ，GTK+ 让 主 循环 处于 就绪 状态 并 等待 用户 的 输入 。 如果 用户 做 了 一些 动作 ， 比如 鼠标 事件 ， 主 循环 就 会 被 唤醒 ， 然后 将 这个 事件 传递 给 GTK+ 程序 。 当 部件 收到 一个 事件 ， 它们 将 会 频繁 的 发出 一个 或者 更 多 的 信号 ， 这些 信号 将 会 调用 与 之 相 绑定 的 函数 。 这样 的 函数 通常 被称作 回调 函数 。 当 回调 函数 被 调用 时 ， 你 就 可以 进行 一些 操作 了 。 比如说 ， 你 可能 要 弹 出 一个 文件 选择 对话框 当 一个 “ 打开 ” 按钮 被 点击 的 之后 。 当 回调 函数 执行 完毕 之后 ，GTK+ 将 会 返回 到 主 循环 然后 等待 用户 再 一次 输入 。 一个 典型 的 例子 ：handler_id = widget.connect('event',callback,data) 首先 ，widget 是 一个 之前 以及 创建 好 的 widget 实例 。 接着 ， 我们 来 看看 事件 ， 每个 部件 都 有 它 自己 的 事件 。 举 个 例子 ， 如果 你 有 一个 按钮 ， 那么 你 往往 希望 绑定 它 的 点击 事件 。 这样 只要 按钮 被 点击 ， 你 就 能 收到 它 所 触发 的 信号 。 然后 ， 参数 callback 代表者 需要 调用 的 回调 函数 的 名字 ， 它 包含 者 将要 运行 的 代码 ， 当 特定 的 信号 产生 之后 。 最后 ，data 参数 包含 着 任意 你 想要 传递 的 数据 ， 这个 参数 是 一个 可 选 参数 ， 如果 不 需要 可以 省略 。 该 方法 返回 一个 数值 ， 标志 着 这个 signal-callback 对 。 当 这个 函数 再也不会 ","title":"pygobject-tutorial-1","oriTitle":"pygobject-tutorial-1"},{"uri":"/posts/shadowsocks-account","tags":["shadowsocks"],"content":"G+ 圈子 很多 这样 的 网站 ， 大部分 是 由 ss-panel 这个 开源 项目 建成 。 不 知道 他们 是 乐于 分享 还是 另 有 目的 。 下面 是 列表 ：Shadow X(ss-panel 作者 )kuaishangSSpepsishadowsocksChangZssserver 另外 推荐 Linux 下 ss GUI 客户端 ：shadowsocks-qt5","title":"Shadowsocks 免费 账号 网址 集 ","oriTitle":"Shadowsocks免费账号网址集"},{"uri":"/posts/sublime-config-web","tags":["sublime text","html"],"content":" 文件 ：click here","title":" 用 Sublime Text 3 dev  做 网页 开发 的 配置 ","oriTitle":"用Sublime Text 3 dev 做网页开发的配置"},{"uri":"/posts/timus-1996-cipher-message-3-kmpfft","tags":["数论"],"content":" 题目 链接 ：click here##descriptionEmperor Palpatine has been ruling the Empire for 25 years and Darth Vader has been the head of the Empire Armed Forces. However, the Rebel movement is strong like it never used to be. One of the rebel leaders, Princess Leia from Alderaan, managed to get hold of secret blueprints of the Death Star, the imperial war station.The Princess was going to deliver the station plan to the secret base for further analysis and searching for vulnerable spots. But her ship was attacked by the space destroyer \"Devastator\" headed by Darth Vader. At the last moment Princess Leia managed to send her findings to one of the closest planet called Tatooine with her droid R2-D2\\. Quite conveniently, an old friend of her father Obi-Wan Kenobi lives on that planet.R2-D2 realizes the importance of his mission. He is going to encrypt the information so that the wrong people won’t get it.The memory of R2-D2 has many files with images. First he wanted to use a well-known encrypting algorithm. The point of the method is to replace the least significant bits of the image with the encrypted message bits. The difference is practically unnoticeable on the picture, so one won’t suspect that it contains a hidden message.But then R2-D2 decided that this method is quite well-known and the information won’t be protected enough. He decided to change the least significant bits of the image so that the secret information was a continuous sequence of the bytes of the image file. Help the droid determine if it is possible. And if it is, find the minimum number of bits to alter.InputThe first line of the input contains integers n and m (1 ≤ n, m ≤ 250 000) — the sizes of the image file and of the file with the secret information in bytes. On the second line the content of the file with an image is given and the third line contains the secret information. The files are given as a sequence of space-separated bytes. Each byte is written as a sequence of eight bits in the order from the most to the least significant bit.OutputPrint \"No\", if it is impossible to encrypt information in this image. Otherwise, print in the first line \"Yes\", and in the second line — the number of bits to alter and the number of the byte in the file with the image, starting from which the secret information will be recorded. If there are multiple possible variants, print the one where the secret information is written closer to the beginning of the image file.Samples| input | output ||--------|--------||  3 2 11110001 11110001 1111000011110000 11110000     |   Yes1 2|| input | output ||--------|--------||3 111110000 11110001 1111000011110000      |   Yes0 1|Problem Author: Denis Dublennykh (prepared by Oleg Dolgorukov) 题目 老 长 难懂 ， 其实 就是 给 你 一个 n byte 的 01A 串 ，m byte 的 01B 串 . 其中 A 串 中 每 一 byte 的 最后 一个 bit 是 可以 修改 的 ， 问 至少 修改 多少 次 A 串 能 使 B 使 A 的 子串 。 输出 修改 次数 与 最小 的 起始 匹配 位置 。 首先 将 A 串 每 byte 取 前 7 位 （ 代码 中 的 a 数组 ） 与 B 串 每 byte 取 前 7 位 （ 代码 中 的 b 数组 ） 用 KMP 匹配 ， 因为 前 7 位 不能 改 ， 所以 如果 没有 一处 匹配 就 直接 输出 No 了 。 然后 将 A 串 每 byte 取 后 1 位 （ 代码 中 的 ax 数组 ） 与 B 串 每 byte 取 后 一位 （ 代码 中 的 bx 数组 ） 求 hamming 距离 。 如何 求 ax 与 bx 的 hamming 距离 呢 ？ 可以 巧妙 的 ax 作为 卷积 中 的 f 函数 ，bx 的 逆向 数组 bx\\` 作为 卷积 中 的 g 函数 。 两者 求 卷积 。 这样 就 成 了 ：$$c[i + m - 1] = ax[i + 0] * bx\\[m - 0 - 1] + ax[i + 1] * bx\\[m - 1 - 1] + …… ax[i + j] * bx\\[m - j - 1] + …… ax[i + m - 1] * bx\\[m - (m - 1) - 1]$$ 可以 看出 ， 如果 ax , bx 中 同 为 1, 乘积 为 1, 否则 为 0, 这样 就 能 统计 出 了 有 多少 位 同 为 1 了 。 如果 将 ax,bx 数组 中 的 01 取反 ， 再 进行 上述 操作 ， 那么 救 能 统计 出 有 多少 位 同 为 0 了 。 两者 相加 就是 全部 相同 的 有 多少 ， 用 总 字符 数 m 减去 它 ， 就 能 求 出 hamming 距离 了 ！ 卷积 复杂度 为 O(nlg(n)) 而 暴力 算法 的 复杂度 为 O(n×m)， 真是太 神奇 了 ！`C++using namespace std;const int N = 250005;int n, m;const double pi = acos(-1.0);// Complex  z = a + b * istruct Complex {\tdouble x, y;\tComplex(double x = 0.0, double y = 0.0) :\t\t\tx(x), y(y) {\t}\tComplex operator +(const Complex &amp;c) const {\t\treturn Complex(x + c.x, y + c.y);\t}\tComplex operator -(const Complex &amp;c) const {\t\treturn Complex(x - c.x, y - c.y);\t}\tComplex operator *(const Complex &amp;c) const {\t\treturn Complex(x * c.x - y * c.y, x * c.y + y * c.x);\t}};int a[N], b[N], ax[N], bx[N];char buf[8];/* kmpNext[] 的 意思 :next'[i]=next[next[...[next[i]]]] ( 直到 next'[i]&lt;0 或者  x[next'[i]]!=x[i])  这样 的 预处理 可以 快 一些  */void preKMP(int x[], int m, int kmpNext[]) {\tint i, j;\tj = kmpNext[0] = -1;\ti = 0;\twhile (i &lt; m) {\t\twhile (-1 != j &amp;&amp; x[i] != x[j])\t\t\tj = kmpNext[j];\t\tif (x[++i] == x[++j]) kmpNext[i] = kmpNext[j];\t\telse kmpNext[i] = j;\t}}/*  返回 x 在 y 中 出现 的 次数 , 可以 重叠  */int next[N];vector pos;void KMP_Count(int x[], int m, int y[], int n) { //x 是 模式 串 ,y 是 主 串 \tint i, j;\tpos.clear();\tpreKMP(x, m, next);\ti = j = 0;\twhile (i &lt; n) {\t\twhile (-1 != j &amp;&amp; y[i] != x[j])\t\t\tj = next[j];\t\ti++;\t\tj++;\t\tif (j &gt;= m) {\t\t\tpos.push_back(i - m);\t\t\tj = next[j];\t\t}\t}}//len = 2 ^ kinline void change(Complex y[], int len) {\tfor (int i = 1, j = len / 2; i &lt; len - 1; i++) {\t\tif (i &lt; j) swap(y[i], y[j]);\t\tint k = len / 2;\t\twhile (j &gt;= k) {\t\t\tj -= k;\t\t\tk /= 2;\t\t}\t\tif (j &lt; k) j += k;\t}}// FFT// len = 2 ^ k// on = 1  DFT    on = -1 IDFTinline void FFT(Complex y[], int len, int on) {\tchange(y, len);\tfor (int h = 2; h &lt;= len; h &lt;&lt;= 1) {\t\tComplex wn(cos(-on * 2 * pi / h), sin(-on * 2 * pi / h));\t\tfor (int j = 0; j &lt; len; j += h) {\t\t\tComplex w(1, 0);\t\t\tfor (int k = j; k &lt; j + h / 2; k++) {\t\t\t\tComplex u = y[k];\t\t\t\tComplex t = w * y[k + h / 2];\t\t\t\ty[k] = u + t;\t\t\t\ty[k + h / 2] = u - t;\t\t\t\tw = w * wn;\t\t\t}\t\t}\t}\tif (on == -1) {\t\tfor (int i = 0; i &lt; len; i++) {\t\t\ty[i].x /= len;\t\t}\t}}//FFT 求 卷积 ,a 数组 长度 n，b 数组 长度 mint res[N];Complex x1[N &lt;&lt; 2], x2[N &lt;&lt; 2]; //FFT 开 4 倍 void Convolution(int a[], int b[]) {\tint len = max(n, m);\tint l = 1;\twhile (l &lt; len * 2)\t\tl &lt;&lt;= 1;\tfor (int i = 0; i &lt; l; i++)\t\tx1[i] = Complex(i &lt; n ? a[i] : 0, 0);\tfor (int i = 0; i &lt; l; i++)\t\tx2[i] = Complex(i &lt; m ? b[i] : 0, 0);\t//DFT\tFFT(x1, l, 1);\tFFT(x2, l, 1);\tfor (int i = 0; i &lt; l; i++)\t\tx1[i] = x1[i] * x2[i];\t//IDFT\tFFT(x1, l, -1);\t//based on m\tint base = m ;\tfor (int i = 0; i &lt;= n - base; i++) {\t\tres[i] += (int) (x1[i + base - 1].x + 0.5);\t}}int main() {\twhile (~scanf(\"%d%d\", &amp;n, &amp;m)) {\t\tfor (int i = 0; i &lt; n; i++) {\t\t\ta[i] = 0;\t\t\tscanf(\"%s\", buf);\t\t\tfor (int j = 0; j &lt; 7; j++) {\t\t\t\ta[i] = a[i] &lt;&lt; 1 | (buf[j] - '0');\t\t\t}\t\t\tax[i] = buf[7] - '0';\t\t}\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tb[i] = 0;\t\t\tscanf(\"%s\", buf);\t\t\tfor (int j = 0; j &lt; 7; j++) {\t\t\t\tb[i] = b[i] &lt;&lt; 1 | (buf[j] - '0');\t\t\t}\t\t\tbx[i] = buf[7] - '0';\t\t}\t\tKMP_Count(b, m, a, n);\t\tif (pos.size() == 0) puts(\"No\");\t\telse {\t\t\treverse(bx, bx + m);\t\t\tmemset(res, 0, sizeof(res));\t\t\tputs(\"Yes\");\t\t\tConvolution(ax, bx);\t\t\tfor (int i = 0; i &lt; n; i++)\t\t\t\tax[i] ^= 1;\t\t\tfor (int i = 0; i &lt; m; i++)\t\t\t\tbx[i] ^= 1;\t\t\tConvolution(ax, bx);\t\t\tint ans = m, idx = 0;\t\t\tfor (int i = 0; i &lt; (int) pos.size(); i++) {\t\t\t\tif (m - res[pos[i]] &lt; ans) {\t\t\t\t\tans = m - res[pos[i]];\t\t\t\t\tidx = pos[i] + 1;\t\t\t\t}\t\t\t}\t\t\tprintf(\"%d %d\\n\", ans, idx);\t\t}\t}}`","title":"Timus 1996 Cipher Message 3 KMP+FFT 求 卷积 ","oriTitle":"Timus 1996 Cipher Message 3 KMP+FFT求卷积"},{"uri":"/posts/toutiao-test","tags":["招聘","网易","LCS","暴力"],"content":" 之前 随便 投 了 一下 今日 头条 竟然 过 了 , 虽然 不是 很 想 去 , 但是 已经 给 了 我 笔试 邀约 好歹 也 就 做 一下 , 锻炼 锻炼 脑子 , 说句实话 还是 挺 喜欢 头条 的 题目 的 , 做 起来 很 有 以前 ACM 刷 题 的 感觉 , 不 像 其他 公司 总 感觉 \" 工程化 \" 比较 多 。 推 箱子 第一 题 比较简单 , 表面 上 无从下手 但是 仔细 想想 应该 能 想 出来 的 , 本质 上 跟 走 迷宫 问题 本质 上 是 一致 的 ， 只不过 在 这 题 中 状态 既 要 保存 人 的 位置 也 要 保存 箱子 的 位置 。 暴力 搜索 能够 ,AC 代码 :#include#include#include#include#includeusing namespace std;char mp55;bool used5555;int n, m;struct Point {\tint x, y;}you, st, ed;struct State {\tint x, y, xx, yy, step;\tState() { step = 0; };\tState(int x, int y, int xx, int yy,int step)  {\t\tthis->x = x;\t\tthis->y = y;\t\tthis->xx = xx;\t\tthis->yy = yy;\t\tthis->step = step;\t}\tState(Point a, Point b) {\t\tx = a.x;\t\ty = a.y;\t\txx = b.x;\t\tyy = b.y;\t\tstep = 0;\t}};int dir4 = { {1,0},{-1,0},{0,1},{0,-1} };bool valid(int x, int y) {\tif (xn ) return false;\tif (ym ) return false;\tif (mpx == '#') return false;\treturn true;}int bfs() {\tqueueQ;\tmemset(used, 0, sizeof(used));\tState start(you,st);\tQ.push(start);\tusedstart.xstart.xx = 1;\twhile (!Q.empty()) {\t\tState cur = Q.front();\t\tif (cur.xx == ed.x && cur.yy == ed.y) return cur.step;\t\tfor (int i = 0; i >n>>m) {\t\tfor (int i = 1; i > mpi;\t\t\t\tif (mpi == 'S') {\t\t\t\t\tyou.x = i;\t\t\t\t\tyou.y = j;\t\t\t\t}\t\t\t\tif (mpi == '0') {\t\t\t\t\tst.x = i;\t\t\t\t\tst.y = j;\t\t\t\t}\t\t\t\tif (mpi == 'E') {\t\t\t\t\ted.x = i;\t\t\t\t\ted.y = j;\t\t\t\t}\t\t\t}\t\t}\t\tcout#include#include#includeusing namespace std;int n, m;long long a[111111], b[111111];vectorvt;bool check(int mIndex) {\tfor (int i = 0; i > a[i];\t\t\tif (mVal == -1 || mVal >= a[i]) {\t\t\t\tif (mVal > a[i])vt.clear();\t\t\t\tmVal = a[i];\t\t\t\tvt.push_back(i);\t\t\t}\t\t}\t\tfor (int i = 0; i < (int)vt.size(); i++) {\t\t\tint mIndex = vt[i];\t\t\tif (check(mIndex))break;\t\t}\t\tfor (int i = 0; i < n; i++) {\t\t\tprintf(\"%lld%c\", b[i], i == n - 1 ? '\\n' : ' ');\t\t}\t}}/*3 16 5 1*/","title":" 今日 头条 笔试 解题 报告 (10.17)","oriTitle":"今日头条笔试解题报告(10.17)"},{"uri":"/posts/wine-font-config","tags":["linux"],"content":" 默认 Wine 的 字体 太 难看 ， 而且 有时候 还 会 显示 不 出来 。 开启 Wine 字体 的 反锯齿 及 平滑 功能 以及 将 字体 映射 成文 泉 驿 微米 黑 的 方法 是 ：1. 新建 文本文件 a.reg， 放入 如下 内容 ：`languageREGEDIT4[HKEYCURRENTUSER\\Software\\Wine\\X11 Driver]\"ClientSideAntiAliasWithCore\"=\"Y\"\"ClientSideAntiAliasWithRender\"=\"Y\"\"ClientSideWithRender\"=\"Y\"[HKEYCURRENTUSER\\Control Panel\\Desktop]\"FontSmoothing\"=\"2\"\"FontSmoothingType\"=dword:00000002\"FontSmoothingGamma\"=dword:00000578\"FontSmoothingOrientation\"=dword:00000001[HKEYLOCALMACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes]\"Arial Baltic,186\"=\"WenQuanYi Micro Hei\"\"Arial CE,238\"=\"WenQuanYi Micro Hei\"\"Arial CYR,204\"=\"WenQuanYi Micro Hei\"\"Arial Greek,161\"=\"WenQuanYi Micro Hei\"\"Arial TUR,162\"=\"WenQuanYi Micro Hei\"\"Courier New Baltic,186\"=\"WenQuanYi Micro Hei\"\"Courier New CE,238\"=\"WenQuanYi Micro Hei\"\"Courier New CYR,204\"=\"WenQuanYi Micro Hei\"\"Courier New Greek,161\"=\"WenQuanYi Micro Hei\"\"Courier New TUR,162\"=\"WenQuanYi Micro Hei\"\"Helv\"=\"WenQuanYi Micro Hei\"\"Helvetica\"=\"WenQuanYi Micro Hei\"\"MS Shell Dlg\"=\"WenQuanYi Micro Hei\"\"MS Shell Dlg 2\"=\"WenQuanYi Micro Hei\"\"Tahoma\"=\"WenQuanYi Micro Hei\"\"Times\"=\"WenQuanYi Micro Hei\"\"Times New Roman Baltic,186\"=\"WenQuanYi Micro Hei\"\"Times New Roman CE,238\"=\"WenQuanYi Micro Hei\"\"Times New Roman CYR,204\"=\"WenQuanYi Micro Hei\"\"Times New Roman Greek,161\"=\"WenQuanYi Micro Hei\"\"Times New Roman TUR,162\"=\"WenQuanYi Micro Hei\"\"Tms Rmn\"=\"WenQuanYi Micro Hei\"\"Simsun\"=\"WenQuanYi Micro Hei\"`2. 如果 是 普通 的 wine 直接 终端 输入 wine regedit 打开 注册表 编辑器 。 然后 点击 “ 注册表 —&gt; 导入 注册表 文件 \" 导入 该 文件 。3. 如果 是 longene 等 封装 好 的 wine（ 比如 tm2013） 可以 使用 tm2013 -reg 命令 打开 注册表 。","title":" 优化 Wine 程序 的 字体 显示 ","oriTitle":"优化Wine程序的字体显示"},{"uri":"/posts/xfce4-config","tags":["xfce4","DE/WM"],"content":"1. 字体 ：infinally  渲染 2. 英文 字体 ：courier prime3. 窗口 最大化 隐藏 标题栏 ：xfwm4-titleless-dev4. 窗口 最大化 标题栏 隐藏 后 ， 在 任务栏 上 显示 控制 按钮 的 插件 ：xfce4-windowck-plugin","title":" 我 的 xfce4 配置 ","oriTitle":"我的xfce4配置"},{"uri":"/posts/zjnu2073-geasscode","tags":["LCA","图论","tarjan"],"content":"##DescriptionGeassCode 凭借 自己 在 topcoder 上 的 超凡 表现 ， 赢得 了 国王 的 喜爱 ， 国王 赏赐 他 一座 城池 。 这 座 城池 里 有 n 个   村子 ，m 条 路 连接 这些 村子 。 坐 上城 主 的 GeassCode 决定 要 修路 ， 他 打算 用 最少 的 代价 把 所以 的 村子 连在一起 。 据 探子 回报 ， 有些 村子 之间 虽然 原来 没有 路   径 ， 但是 可以 强行 的 去 建 一条 路 。GeassCode 想 知道 ， 如果 强行 在 某 两个 村子 之间 建 一条 路 ， 最后 的 总 花费 是 多少 ？##Input 输入 一行 三个 整数 n，m， 表示 有 n 个 村子 ，m 条 可 建 路径 。2..m+1 行 ， 每行 3 个 整数 a,b,c（a≠b）， 表示 可以 在 a 和 b 村庄 建 一条 花费 为 c 的 路径 。 第 m+2 行 一个 整数 q， 表示 有 多少 个 询问 。 接下来 q 个 询问 ， 每行 3 个 整数 a,b,c（a≠b）， 表示 如果 可以 另外 在 a 和 b 村庄 建 一条 花费 为 c 的 路径 ， 最终 需要 多少 花费 ？##Output 对于 每个 询问 输出 ， 输出 最少 的 花费 。##Sample Input4 5 1 2 4 2 3 3 1 4 6 2 4 3 1 3 2 3 3 4 3 1 3 1 1 4 2##Sample Output8 7 7##Hintn 的 范围 [2,50000],m 的 范围 [2,100000],q 的 范围 [1,50000]。 输入 的 m 条 边 保证 可以 把 所有 村庄 连在一起 。 输入 的 边 权 范围 [1,106]##Source 张 超 解法 是 如果 可以 在 (u,v) 上 再 加 条 边 ， 则 将 最小 生成 树上 的 (u,v) 节点 最 短 路径 中 的 最大 边 权 与 要 加上 这 条 边 的 替换 。 如果 新 的 花费 比 旧 的 花费 少 ， 则 取 新 的 花费 。 否则 什么 也 不 换 ， 取 旧 的 花费 。 如何 求 树上 两点 之间 的 最 短 路径 中 的 最大 边 权 呢 ？ 可以 按照 这 篇文章 所述 建 一个 类似 于 哈夫曼 树 ， 将 点 作为 叶子 ， 边 的 权 值 作为 祖先 构造 一个 N+N 的 树 ：click here 这样 写 的 很 容易 错 ， 尤其 要 区分 两颗 树 的 规模 ， 我 在 这 上面 错 了 很 久 。`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&lt;x&gt;::iterator#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SRI(x) set&lt;x&gt;::reverse_iterator#define VRI(x) vector&lt;x&gt;::reverse_iterator#define MRI(x,y) map&lt;x,y&gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;#define N 50005#define M 100005int n, m ;struct Graph {    int u, v, w;    bool mark;    bool operator&lt;(Graph othr) const {        return w &lt; othr.w;    }} g[M];//UnionSetint p[N + N];void initUset(int n) {    for (int i = 0; i &lt;= n; i++)        p[i] = i;}int uFind(int x) {    return x == p[x] ? p[x] : p[x] = uFind(p[x]);}void uMerge(int x, int y) { //y 合并 到 x    int fx = uFind(x);    int fy = uFind(y);    if (fx != fy) p[fy] = fx;}//Edge Graphint head[N + N], pos;struct Edge {    int v, nxt;} e[N + N];void initEdge() {    memset(head, -1, sizeof(head));    pos = 0;}void add(int u, int v) {    e[pos].v = v;    e[pos].nxt = head[u];    head[u] = pos++;}int size;vector&lt;pr&lt;int, int&gt; &gt; query[N];int qw[N];bool vis[N];int lca[N];int val[N + N];int dfs(int u) {    int solved = 0;    for (int i = head[u]; ~i; i = e[i].nxt) {        int v = e[i].v;        solved += dfs(v);        if (size == solved) return solved;        uMerge(u, v);    }    if(~val[u])return solved;    vis[u] = 1;    for (int i = 0; i &lt; (int) query[u].size(); i++) {        int v = queryu.F;        if (vis[v]) {            solved++;            lcaquery[u.S] = uFind(v);        }    }    return solved;}void tarjan() {    initUset(n);    clrA(vis, 0);    dfs(n);}void rebuild() {    clrA(val, -1);    initUset(n + n);    initEdge();    for (int i = 1; i &lt;= m; i++) {        if (g[i].mark == false) continue;        val[++n] = g[i].w;        int fu = uFind(g[i].u);        int fv = uFind(g[i].v);        p[fu] = n;        p[fv] = n;        add(n, fu);        add(n, fv);    }}int main() {    while (~scanf(\"%d%d\", &amp;n, &amp;m)) {        for (int i = 1; i &lt;= m; i++) {            scanf(\"%d%d%d\", &amp;g[i].u, &amp;g[i].v, &amp;g[i].w);            g[i].mark = false;        }        sort(g + 1, g + 1 + m);        initUset(n);        LL sum = 0;        for (int i = 1; i &lt;= m; i++) {            int fx = uFind(g[i].u);            int fy = uFind(g[i].v);            if (fx != fy) {                sum += g[i].w;                g[i].mark = true;                p[fy] = fx;            }        }        for (int i = 1; i &lt;= n; i++)            query[i].clear();        scanf(\"%d\", &amp;size);        int u, v, w;        for (int i = 1; i &lt;= size; i++) {            scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w);            qw[i] = w;            query[u].push_back(MP(v, i));            query[v].push_back(MP(u, i));        }        rebuild();        tarjan();        for (int i = 1; i &lt;= size; i++) {            LL ans = sum - val[lca[i]] + qw[i];            printf(LLS\"\\n\", min(ans, sum));        }    }}` 其实 ， 可以 直接 在 dfs 的 回溯 过程中将 子 节点 的 max 求 出来 。 这样 简单 多 了 。 感叹 一句 ： 并 查 集 真 神奇 ！`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair&lt;int,int&gt;#define MP make_pair#define SI(x) set&lt;x &gt;::iterator#define VI(x) vector&lt;x &gt;::iterator#define MI(x,y) map&lt;x,y &gt;::iterator#define SRI(x) set&lt;x &gt;::reverse_iterator#define VRI(x) vector&lt;x &gt;::reverse_iterator#define MRI(x,y) map&lt;x,y &gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty())x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;#define N 50005#define M 100005int n, m;struct Graph {    int u, v, w;    bool operator&lt;(Graph othr) const {        return w &lt; othr.w;    }} g[M];struct Pair {    int x, y;    Pair(int x, int y) :            x(x), y(y) {    }    ;};//Edge Graphint head[N], pos;struct Edge {    int v, w, nxt;} e[N &lt;&lt; 1];void initEdge() {    memset(head, -1, sizeof(head));    pos = 0;}void add(int u, int v, int w) {    e[pos].v = v;    e[pos].w = w;    e[pos].nxt = head[u];    head[u] = pos++;}//UnionSetint p[N];int pmax[N];void initUset() {    for (int i = 0; i &lt;= n; i++)        p[i] = i;}int uFind(int x) {    if (x != p[x]) {        int t = p[x];        p[x] = uFind(p[x]);        pmax[x] = max(pmax[x], pmax[t]);        return p[x];    }    return x;}void uMerge(int x, int y) { //y 合并 到 x    int fx = uFind(x);    int fy = uFind(y);    if (fx != fy) {        p[fy] = fx;        pmax[fy] = max(pmax[fy], pmax[fx]);    }}int size;vector&lt;Pair&gt; query[N];vector&lt;Pair&gt; mark[N];int qw[N];bool vis[N];int lca[N];void dfs(int u, int fa) {    if (size == 0) return;    for (int i = head[u]; ~i; i = e[i].nxt) {        int v = e[i].v;        if (v == fa) continue;        dfs(v, u);        pmax[v] = max(pmax[v], e[i].w);        uMerge(u, v);    }    vis[u] = 1;    for (int i = 0; i &lt; (int) query[u].size(); i++) {        int v = queryu.x;        if (vis[v]) {            mark[uFind(v)].push_back(Pair(u, i));        }    }    if (!mark[u].empty()) {        for (VI(Pair)it=mark[u].begin();it!=mark[u].end();++it) {            int uu = it-&gt;x;            int vv = queryit-&gt;x.x;            int ss = queryit-&gt;x.y;            uFind(uu);            uFind(vv);            lca[ss] = max(pmax[uu], pmax[vv]);            size--;        }        mark[u].clear();    }}int findRoot() {    for (int i = 1; i &lt;= n; i++) {        if (!vis[i]) return i;    }    return assert(false), -1;}void tarjan() {    initUset();    clrA(vis, 0);    clrA(pmax, 0);    size = m;    dfs(findRoot(), -1);}int main() {    while (~scanf(\"%d%d\", &amp;n, &amp;m)) {        for (int i = 1; i &lt;= m; i++) {            scanf(\"%d%d%d\", &amp;g[i].u, &amp;g[i].v, &amp;g[i].w);        }        sort(g + 1, g + 1 + m);        initUset();        initEdge();        LL sum = 0;        for (int i = 1; i &lt;= m; i++) {            int fx = uFind(g[i].u);            int fy = uFind(g[i].v);            if (fx != fy) {                sum += g[i].w;                add(g[i].u, g[i].v, g[i].w);                add(g[i].v, g[i].u, g[i].w);                p[fy] = fx;            }        }        for (int i = 1; i &lt;= n; i++) {            query[i].clear();            mark[i].clear();        }        scanf(\"%d\", &amp;m);        int u, v, w;        for (int i = 1; i &lt;= m; i++) {            scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w);            qw[i] = w;            query[u].push_back(Pair(v, i));            query[v].push_back(Pair(u, i));        }        tarjan();        for (int i = 1; i &lt;= m; i++) {            LL tmp = sum - lca[i] + qw[i];            printf(LLS\"\\n\", min(tmp, sum));        }    }}`","title":" 内 网 2073  城 主 GeassCode","oriTitle":"内网2073 城主GeassCode"},{"uri":"/posts/zjnu2082","tags":["组合"],"content":"##Description 乐乐 开始 学习 英文字母 了 ， 小 C 为 他 准备 了 很多 字母 牌 ， 每张 牌 有 一个 英文字母 。 有 天 乐乐 把 所有 的 牌 排成 一行 ， 这些 字母 竟然 形成 了 一个 回文 串 。 小 C 想 知道 ， 乐乐 在 排 字母 的 时候 ， 有 多少 种 情况 ， 最后 的 字母 形成 回文 串 。##Input 输入 一行 ， 表示 乐乐 有 哪些 字母 ， 均 大写 。##Output 输出 有 多少 种 情况 ， 排列 的 字母 是 一个 回文 串 。##Sample InputAAAAB AABB CD##Sample Output1 2 0##Hint100% 的 数据 ， 字母 的 个数 不 超过 1000。A(m,m)/(A(cnt1,cnt1)*A(cnt2,cnt2).......) 主要 是 排列组合 数 的 计算 技巧 。 将 n! 分解 质因数 ， 然后 上面 的 因子 减去 下面 相同 的 因子 ， 这样 就 不会 因为 计算 阶乘 而 爆 数组 了 。n! 中 质因数 m 的 个数 ：n/m+n/m^2+n/m^3+n/m^4.........`C++#include \"iostream\"#include \"cstdio\"#include \"cstring\"#include \"string\"#include \"vector\"using namespace std;#define sz(x) (int)x.size()#define DSIZE 10000#define clr(x,y) memset(x,y,sizeof(x));class BigInteger {private:    int a[1001];    bool sign; //true-p , false-n    int len;public:    BigInteger() {        len = 1;        sign = true;        clr(a, 0);        a[0] = 1;    }    void operator *=(int);    friend ostream &amp;operator&lt;&lt;(ostream &amp;, const BigInteger &amp;);};void BigInteger::operator*=(int x) {    if (x &lt; 0) x = -x, sign ^= 1;    for (int i = 0; i &lt; len; i++) {        a[i] *= x;    }    for (int i = 0; i &lt; len; i++) {        if (a[i] &gt;= DSIZE) {            a[i + 1] += a[i] / DSIZE;            a[i] %= DSIZE;        }    }    if (a[len]) len++;}ostream &amp;operator&lt;&lt;(ostream &amp;out, const BigInteger &amp;x) {    if (!x.sign &amp;&amp; x.len) putchar('-');    printf(\"%d\", x.a[x.len - 1]);    for (int i = x.len - 2; i &gt;= 0; i--) {        printf(\"%04d\", x.a[i]);    }    return out;}int n, m;int cnt[30];int prime[1001], tot;bool ok[1001];int faclist[1001];void getprime(int n) {    clr(ok, 0);    tot = 0;    for (int i = 2; i &lt;= n; i++) {        if (!ok[i]) prime[tot++] = i;        for (int j = 0; j &lt; tot; j++) {            int now = i * prime[j];            if (now &gt; n) break;            ok[now] = 1;            if (i % prime[j] == 0) break;        }    }}void getfact(int x) {    int s = x &lt; 0 ? -x : x;    for (int i = 0; prime[i] &lt;= s; i++) {        for (int j = prime[i]; j &lt;= s; j *= prime[i]) {            faclist[i] += x / j;        }    }}char str[1001];int main() {    getprime(1000);    while (~scanf(\"%s\",str)) {        n = strlen(str);        clr(cnt, 0);        for (int i = 0; i &lt; n; i++) {            cnt[str[i] - 'A']++;        }        int f = 0;        m = 0;        for (int i = 0; i &lt; 26 &amp;&amp; f &lt; 2; i++) {            if (cnt[i] &amp; 1) f++;            m += cnt[i] &gt;&gt;= 1;        }        if (f &gt; 1) {            printf(\"0\\n\");            continue;        }        clr(faclist, 0);        getfact(m);        for (int i = 0; i &lt; 26; i++)            getfact(-cnt[i]);        BigInteger res;        for (int i = 0; prime[i] &lt;= m; i++) {            for (int j = 0; j &lt; faclist[i]; j++) {                res *= prime[i];            }        }        cout &lt;&lt; res &lt;&lt; endl;    }}`language`","title":" 内 网 2082  字母 ","oriTitle":"内网2082 字母"},{"uri":"/posts/zjnu2085","tags":["暴力"],"content":"##Description  在 观看 完 战马 检阅 之后 ， 来自 大 草原 的 两 兄弟 决心 成为 超级 “ 马 农 ”， 专门 饲养 战马 。 兄弟 两 回到 草原 ， 将 可以 养 马 的 区域 ， 分为 N*N 的 单位 面积 的 正方形 ， 并 实地 进行 考察 ， 归纳 出 了 每个 单位 面积 可以 养 马 所 获得 的 收益 。 接下来 就要 开始 规划 他们 各自 的 马场 了 。 首先 ， 两 人 的 马场 都 必须 是 矩形 区域 。 同时 ， 为了 方便 两 人 互相 照应 ， 也 为了 防止 马匹 互相 走散 ， 规定 两个 马场 的 矩形 区域 相邻 ， 且 只有 一个 交点 。 最后 ， 互不 认输 的 两 人 希望 两个 马场 的 收益 相当 ， 这样 才 不会 影响 他们 兄弟 的 感情 。 现在 ， 兄弟 两 找到 你 这位 设计师 ， 希望 你 给 他们 设计 马场 ， 问 共有 多少 种 设计方案 。##Input 第一行 一个 整数 N， 表示 整个 草原 的 大小 为 N*N。 接下来 N 行 ， 每行 N 个 整数 A(i,j)， 表示 第 i 行 第 j 列 的 单位 草地 的 收成 。（ 注意 ： 收益 可能 是 负数 ， 养 马 也 不是 包 赚 的 ， 马匹 也 可能 出现 生病 死亡 等 意外 。）1&lt;=N&lt;=50-1000&lt;A(i,j)&lt;1000##Output  输出 符合 两 人 要求 的 草原 分配 方案 数 。##Sample Input3 1 2 3 4 5 6 7 8 9##Sample Output2##Hint##Source2014 宁波 初中  T2 宁波 镇海 中学 的 罗 方 炜 给 我们 组 的 一场 比赛 。 此 题 主要 靠 技巧 。 枚举 中心点 ， 然后 用 数组 hash。 注意 数组 清空 复杂度 很大 ， 每次 清空 必定 超时 。 应该 用 一个 栈 来 记录 更改 的 地方 ， 直接 赋 0.`C++#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cassert&gt;#include&lt;utility&gt;#include&lt;numeric&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pr pair#define PR pair&lt;int,int&gt;#define MP make_pair#define SI(x) set&lt;x&gt;::iterator#define VI(x) vector&lt;x&gt;::iterator#define MI(x,y) map&lt;x,y&gt;::iterator#define SRI(x) set&lt;x&gt;::reverse_iterator#define VRI(x) vector&lt;x&gt;::reverse_iterator#define MRI(x,y) map&lt;x,y&gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LLMAX I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LLMAX I64_MAX#endifconst int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;/start/#define N 55#define M 2500000int fN,aN;int h[M&lt;&lt;1|1];int st[N*N],top;int n,m;int main(int argc, char **argv) {    while(~scanf(\"%d\",&amp;n)){        for (int i = 1; i &lt;= n; ++i) {            for (int j = 1; j &lt;= n; ++j) {                scanf(\"%d\",&amp;ai);                fi=fi-1+fi-fi-1+ai;            }        }        int res=top=0;        for (int x = 1; x &lt;= n; ++x) {            for (int y = 1; y &lt;= n; ++y) {                for (int i = 1; i &lt;= x; ++i) {                    for (int j = 1; j &lt;= y; ++j) {                        sttop++]=f[x-fx-fi-1+fi-1+M;                        h[st[top-1]]++;                    }                }                for (int i = x+1; i &lt;= n; ++i) {                    for (int j = y+1; j &lt;= n; ++j) {                        res+=hf[i-fi-fx+fx+M];                    }                }                while(top){                    h[st[--top]]=0;                }                for (int i = x; i &lt;= n; ++i) {                    for (int j = 1; j &lt;= y; ++j) {                        sttop++]=f[i-fx-1-fi+fx-1+M;                        h[st[top-1]]++;                    }                }                for (int i = 1; i &lt; x; ++i) {                    for (int j = y+1; j &lt;= n; ++j) {                        res+=hf[x-1-fx-1-fi-1+fi-1+M];                    }                }                while(top){                    h[st[--top]]=0;                }            }        }        printf(\"%d\\n\",res);    }}`","title":" 内 网  2085 马 农 ","oriTitle":"内网 2085马农"},{"uri":"/posts/zju-openwrt-settings","tags":["IPv6","PT"],"content":"Why 学校 这边 上网 每次 都 要 输入 账号 ， 有 登陆 设备 数量 限制 ， 玉泉 这边 还要 申请 静态 IP 地址 ， 每人 只能 申请 两个 ， 申请 下来 还 需要 隔天 才能 生效 …… 真的 是 有 多 不 方便 就 多 不 方便 。 不过 还好 ， 学校 的 上网 协议 是 标准 的 L2TP VPN 认证 ， 这 几天 想着 把 压箱底 的 小米 路由器 mini 拿 出来 试一试 看看 能 不能 的 openwrt 上 拨 VPN 然后 分享 出来 。 刷 机 {{}} 刷 机 有变 砖 的 风险 ， 最好 先 刷 入 breed  或  uboot 做 一层 保护 {{}} 路由器 原来 我 就 刷 了 的 Pandorabox， 但是 现在 拿出 来看 发现 它 的 官 网 和 软件 源 因为 没有 备案 都 被 和谐 掉 了 ， 版本 也 一直 没有 变化 ， 也许 作者 本身 精力 都 放到 newifi 上面 去 了 吧 。 想想 还是 弃 坑 了 。 于是 决定 刷 入 原生 的 openwrt， 然而 重启 后 久久 未 见 openwrt 字样 的 wifi 名 ， 用 有线 连接 进去 手动 开启 wifi 也 是 失败 了 。 猜测 是 驱动 的 原因 ， 遂 再次 弃 坑 。 最后 翻 了 一下 openwrt 的 wiki， 发现 lede 上面 有 针对 这 款 路由器 的 补丁 ， 上官 网 看 了 看 ， 最近 更新 在 17 年 10 月 ， 感觉 开发 还 挺 活跃 的 ， 于是 又 将 路由器 刷 成 了 lede。 刚 开始 也 没有 wifi， 不过 使用 有线 进入 管理 界面 后 可以 成功 开启 两个 频道 （2.4g 和 5g, 默认 都 叫 LEDE）。 联网 刷 好 机 之后 直接 面临 一个 比较严重 的 问题 ： 如何 在 没 网 的 情况 下 在 路由器 上 安装 l2tp 协议 包 。 这个 说 起来 有点 死锁 的 味道 了 。 首先 常规 的 方法 是 把 xl2tpd 这个 包 以及 其 所有 依赖 都 下载 到 本地 ， 然后 scp 到 路由器 中 ， 在 ssh 里面 使用 opkg 命令 手动 安装 。 这个 比较 麻烦 ， 我 最后 的 解决 方法 是 通过 手机 分享 wifi， 然后 让 路由器 当作 一个 Client 接入 ， 这样 路由器 就 能 通过 手机 热点 连 上网 了 。 直接 在 luci 管理 界面 里面 安装 xl2tpd 这个 包 之后 我们 就 能够 顺利 拨 l2tp vpn 了 。IPv6IPv6 可谓 是 校园网 的 一大 福利 了 。IPv6 是 没有 IPv4 的 nat 概念 的 。 因此 如何 通过 路由器 给 所有 终端设备 提供 可用 的 IPv6 连接 是 一个 问题 。Google 到 了 一篇 不错 的 文章 >OpenWRT 在 默认 情况 下 ， 会 分配 一个 IPv6 私 网 地址 段 ， 登录 网页 管理 ， 在 Network->Interfaces 页面 底下 有 Global network options->IPv6 ULA-Prefix 这里 应该 有 一个 随机 的 fd 开头 的 /64IPv6 地址 段 ， 清空 该 地址 并 保存 >SSH 登录 路由器 ， 修改 /etc/config/dhcp 文件 ， 添加 如下 部分 ， 使用 无 状态 地址 自动 配置 （SLAAC）IPv6， 不 使用 DHCPv6。>>       config dhcp 'lan'>           option dhcpv6 'disabled'>           option ra 'relay'>           option ndp 'relay'>       config dhcp 'wan6'>           option interface 'wan'>            option dhcpv6 'disabled'>            option ra 'relay'>            option ndp 'relay'>            option master '1'NexusHD  校内 PT 网站 NexusHD 只 对 浙大 校园 开放 ， 里面 的 资源 非常 非常 多 而且 速度 也 非常 快 。 下面 是 我 的 一些 配置 流程 ： 安装  ：transmission-daemon-openssl transmission-remote-openssl 和 luci-app-transmission 端口映射  ： 设置 transmission 的 Peer Port 为 51413， 然后 在 防火墙 里面 打开 51413 端口 以及 转发 wan 的 51413 端口 到 lan 上 。 外 接 硬盘  ： 插入 并 挂载 一块 移动硬盘 ( 使用 blkid 查看 硬盘 的 UUID)， 由于 是 NTFS 格式 的 所以 需要 安装 ntfs-3g, 千万别 看 错 了 ，ntfs 只能 只读 挂载 。samba 服务  ： 安装 luci-app-samba  和 samba36-server 提供 samba 服务 。 这样 我们 就 可以 在 任何 联网 设备 中 远程 观看 transmission 下载 下来 视频 了 。 另外 如果 连 着 VPN 的话 ， 校内 网站 也 是 走 的 VPN 流量 ， 这样 PT 下载速度 不仅 受限于 你 当前 的 上网 套餐 也 会 影响 到 你 的 正常 的 上网 速度 。 每次 PT 下载 的 时候 都 断开 VPN 太 过于 麻烦 了 ， 因此 我们 需要 直接 针对 内 网 IP 设置 静态 路由 。 在 /etc/config/network 里面 加入 ：config route        option target '10.0.0.0'        option netmask '255.0.0.0'        option gateway '10.110.64.1'        option interface 'wan'        option metric '1'config route        option target '210.32.0.0'        option netmask '255.255.240.0'        option gateway '10.110.64.1'        option interface 'wan'        option metric '1'config route        option interface 'wan'        option target '210.32.128.0'        option netmask '255.255.192.0'        option gateway '10.110.64.1'        option metric '1'config route        option interface 'wan'        option target '222.205.0.0'        option netmask '255.255.128.0'        option gateway '10.110.64.1'        option metric '1'config route        option interface 'wan'        option target '58.206.0.0'        option netmask '255.255.0.0'        option gateway '10.110.64.1'        option metric '1'config route        option target '58.196.192.0'        option netmask '255.255.224.0'        option gateway '10.110.64.1'        option interface 'wan'        option metric '1'config route        option target '58.196.224.0'        option netmask '255.255.240.0'        option gateway '10.110.64.1'        option interface 'wan'        option metric '1'config route        option interface 'wan'        option gateway '10.110.64.1'        option target '222.205.46.0'        option netmask '255.255.254.0'        option metric '1'config route        option interface 'wan'        option target '222.205.48.0'        option netmask '255.255.248.0'        option gateway '10.110.64.1'        option metric '1'config route        option interface 'wan'        option target '222.205.56.0'        option netmask '255.255.252.0'        option gateway '10.110.64.1'        option metric '1'config route        option interface 'wan'        option target '210.32.160.0'        option netmask '255.255.248.0'        option gateway '10.110.64.1'        option metric '1'Bug#1 DNS 解析 异常 遇到 最 折腾 人 的 bug 是 始终 不能 使用 域名 来 访问 内 网 的 网站 ， 只能 使用 ip 地址 。 明眼人 一 看 就是 dns 的 问题 嘛 。 但是 折腾 来 折腾 去 ， 发现 dns 服务 没有 配置 错 啊 。 最后 终于 通过 Google 找到 了 我 的 答案 ： 去掉 “ 重定向 保护   丢弃  RFC1918  上行 响应 数据 \"（DNS rebind protect） 就行了 。Bug#2 VPN 自动 断线 用 上 后 不久 发现 VPN 还 会 时不时 自动 断线 ，cc98 里面 也 有人 反馈 。 应该 是 学校 网络 的 原因 。 因此 我 写 了 一个 脚本 来 自动 检查 并 配置 ：#!/bin/shifname=vpnCONNECT(){  if_state=ifconfig | grep l2tp  if [ -z \"$if_state\" ]; then    logger -t \"vpn-guard\" \"Try to reconnect $1\"    ifup $1    sleep 10    return 0  fi  return 1}if [ ! -f \"tmp/vpnstatuscheck.lock\" ]; then  touch /tmp/vpnstatuscheck.lock  CONNECT $ifname && /etc/init.d/odhcpd restart  rm /tmp/vpnstatuscheck.lockfi 然后 在 crontab 计划 任务 里面 加入 下面 一行 ， 就 能 让 crontab 每分钟 都 检查 执行 一次 该 脚本 了 。* * * * /etc/vpn-guard.sh >/dev/null 2>&1Bug#3  视频 等 有 规律 卡 顿 如果 不是 视频 / 音频 这种 大 流量 的 联网 活动 ， 网速 非常 好 。 但是 一 到 看 视频 无论 高清 还是 流畅 都 会 隔 段时间 卡 一下 。 这个 问题 很 玄学 ， 我 同学 一年 都 没有 解决 。 不过 我 还是 Google 到 了 原因 ： 因为 学校 的 VPN 的 MTU 值 跟 正常值 不 一致 。（ 曾经 也 遇到 过 这个 问题 ） 在 VPN 接口 里 把 默认 的 MTU 改为 1400 就 完美 了 。","title":"ZJU 校园网 Openwrt 路由器 设置 ","oriTitle":"ZJU校园网Openwrt路由器设置"},{"uri":"/posts/zoj-month-contest-d-determinant-and-matrix","tags":["数论"],"content":"Time Limit: 2 Seconds      Memory Limit: 65536 KB##DescriptionRecently, LBH is learning the curse linear algebra. Thus he is very interested in matrix and determinant now. In order to practice his ability of solving the problem of linear algebra, he just invent some problems by himself. Once the problems was create, he would solve it immediately. However, he meet a problem that was so hard that he couldn't work out even though racked his brains. The problem was described as follow:To a integer martix Mnn(aij), we define two function add(Mnn(aij))=Mnn(aij + 1) and sub(Mnn(aij))=Mnn(aij - 1) which were exactly like this:According to the martix Mnn(aij), we can permutate it and get a full permutation set Perm(Mnn(aij)) = {Mnn(aIiJj)| I and J is a permutation of 1..n }, (Perm(M) is a set, each matrix in Perm(M) is unique). For example:The problem is to get the result of a fomula about an integer matrix Mnn:in which the det(M) meaned to cacluate the determinant of M.InputThere are several test cases.The first line contains an integer T(T ≤ 100) . Then T test cases follow.In each test case, the first line contains one integer n(0&lt; n≤ 10). The number means the giving matrix's size is n×nThen there are n lines followed, each line contains n integers aij(-10≤ aij≤ 10), in the position row i, colum j, it represents the number aij.OutputFor each test case, since the result may be very large, output one line with the result modulo 230.Sample Input`121 11 2`Sample Output`2`Author: LIN, BinghuiSource: ZOJ Monthly, August 2014 这 道 题 全场 现场 只 A 了 一个 人 。 今天 我们 比赛 的 时候 我 A 了 ， 挺 爽 的 。`Javaimport java.util.Scanner;import java.math.*;public class Main {\tstatic long fact[]=new long[15];\tstatic long kind;\tstatic int A=new int10;\tstatic final BigInteger MOD=BigInteger.valueOf(1&lt;&lt;30);\tstatic void getKind(int n){\t\tboolean mark[]=new boolean[10];\t\tfor(int i,j,k,r=0;r&lt;2;r++){\t\t\tfor (i = 0; i &lt; n; ++ i) mark[i] = false;\t\t\tfor (i = 0; i &lt; n; ++ i) {\t\t\t\tif (mark[i]) continue;\t\t\t\tint cnt = 0;\t\t\t\tfor (j = i; j &lt; n; ++ j) {\t\t\t\t\tfor (k = 0; k &lt; n; ++ k) {\t\t\t\t\t\tif (r==1&amp;&amp;Ak != Ak)break;\t\t\t\t\t\tif(r==0&amp;&amp;Ai != Aj)break;\t\t\t\t\t}\t\t\t\t\tif (k == n) {\t\t\t\t\t\t++ cnt;\t\t\t\t\t\tmark[j] = true;\t\t\t\t\t}\t\t\t\t}\t\t\t\tkind /= fact[cnt];\t\t\t}\t\t}\t}\tpublic static void main(String[] args){\t\tScanner cin=new Scanner(System.in);\t\tint n,T=cin.nextInt();\t\tfact[0]=1;\t\tfor(int i=1;i&lt;=10;i++)fact[i]=fact[i-1]*i;\t\twhile(T--&gt;0){\t\t\tn=cin.nextInt();\t\t\tfor(int i=0;i&lt;n;i++){\t\t\t\tfor(int j=0;j&lt;n;j++){\t\t\t\t\tAi=cin.nextInt();\t\t\t\t}\t\t\t}\t\t\tlong res=0;\t\t\tMatrix matrix=new Matrix(n);\t\t\tkind=fact[n]*fact[n];\t\t\tgetKind(n);\t\t\tif(kind%2==1){\t\t\t\tmatrix.valueOf(A, 0);\t\t\t\tres=res ^(matrix.Det().mod(MOD).longValue());\t\t\t}\t\t\tmatrix.valueOf(A, 1);\t\t\tres=res^(matrix.Det().mod(MOD).longValue());\t\t\tmatrix.valueOf(A, -1);\t\t\tres=res^(matrix.Det().mod(MOD).longValue());\t\t\tSystem.out.println(res);\t\t}\t\tcin.close();\t}}class Matrix{\tBigInteger M=new BigInteger10;\tBigInteger ZERO,ONE;\tint n;\tMatrix(int n){\t\tthis.n=n;\t\tZERO=BigInteger.ZERO;\t\tONE=BigInteger.ONE;\t}\tvoid valueOf(int A,int d){\t\tfor(int i=0;i&lt;n;i++){\t\t\tfor(int j=0;j&lt;n;j++){\t\t\t\tMi=BigInteger.valueOf(Ai+d);\t\t\t}\t\t}\t}\tBigInteger Det(){\t\tBigInteger tmp, res = ONE, div = ONE;\t\tint i, j, k;\t\tfor (i = 0; i &lt; n; ++ i) {\t\t\tfor (j = i; j &lt; n; ++ j) {\t\t\t\tif (!Mj.equals(ZERO)) break;\t\t\t}\t\t\tif (j == n) return ZERO;\t\t\tif (j != i) {\t\t\t\t//res = res.negate();\t\t\t\tfor (k = 0; k &lt; n; ++ k) {\t\t\t\t    tmp = Mj;\t\t\t\t\tMj = Mi;\t\t\t\t\tMi = tmp;\t\t\t\t}\t\t\t}\t\t\tres = res.multiply(Mi);\t\t\tfor (j = i + 1; j &lt; n; ++ j) {\t\t\t\tif (Mj.equals(ZERO)) continue;\t\t\t\tdiv = div.multiply(Mi);\t\t\t\tfor (k = i + 1; k &lt; n; ++ k) {\t\t\t\t\tMj = Mj.multiply(Mi).subtract(Mi.multiply(Mj));\t\t\t\t}\t\t\t}\t\t}\t\tres = res.divide(div);\t\tif (res.compareTo(ZERO) &lt; 0) res = res.negate();\t\treturn res;\t}}`","title":"ZOJ month contest D.Determinant and Matrix","oriTitle":"ZOJ month contest D.Determinant and Matrix"},{"uri":"/posts/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86%E4%B9%8Bgo%E5%AE%9E%E7%8E%B0","tags":["algorithm","golang"],"content":" 一个 比 二叉 堆 更 高效 的 数据结构 ， 但是 实现 起来 非常复杂 。 本科 的 时候 看 《 算法 导论 》 的 时候 曾经 研究 过 ， 不是 很 明白 。 今天 终于 对 它 有 了 一个 比较 清晰 的 了解 。package fibonacciHeapconst MinInt = -int(^uint(0)>>1) - 1type Vertex struct {\tvalue  int\tparent *Vertex\tchild  *Vertex\tleft   *Vertex\tright  *Vertex\tmark   bool\tdegree int}type FibonacciHeap struct {\tmin  *Vertex\tsize int}// Insert inserts a node into heap with value vfunc (F FibonacciHeap) Insert(value int) Vertex {\tv := &Vertex{value: value}\tif F.min == nil {\t\tF.min = v\t} else {\t\tF.insertToList(F.min, v)\t\tif F.min.value > v.value {\t\t\tF.min = v\t\t}\t}\tF.size++\treturn v}func (F *FibonacciHeap) Empty() bool {\treturn F.min == nil}func (F FibonacciHeap) Minmum() Vertex {\treturn F.min}func (F FibonacciHeap) ExtractMin() Vertex {\tz := F.min\tif z == nil {\t\treturn nil\t}\tfor z.child != nil {\t\tv := F.extractVertex(z.child)\t\tF.insertToList(F.min, v)\t}\tif z == z.right { //the heap only contains one node\t\tF.min = nil\t} else {\t\tF.min = z.right\t\tz = F.extractVertex(z)\t\tF.consolidate()\t}\tF.size--\treturn z}func (F FibonacciHeap) Merge(Other FibonacciHeap) {\tif F.min == nil { // if current heap is empty\t\tF.min = Other.min\t} else if Other.min != nil {\t\t// cut two circle and rearrange them\t\tF.min.right.left = Other.min.left\t\tOther.min.left.right = F.min.right //reverse\t\tF.min.right = Other.min\t\tOther.min.left = F.min //reverse\t\tif F.min.value > Other.min.value {\t\t\tF.min = Other.min\t\t}\t}\tOther.min = nil}func (F FibonacciHeap) DecreaseKey(v Vertex, value int) bool {\tif v.value  value {\t\treturn false\t}\tif v.value == value {\t\treturn true\t}\tfor v.child != nil {\t\tF.insertToList(F.min, F.extractVertex(v.child))\t}\tv.value = value\tparent := v.parent\tif parent != nil {\t\tF.insertToList(F.min, F.extractVertex(v))\t\tF.cascadingCut(parent)\t} else if F.min == v {\t\tfor cur := v.right; cur != v; cur = cur.right {\t\t\tif v.value > cur.value {\t\t\t\tF.min = cur\t\t\t}\t\t}\t}\treturn true}func (F FibonacciHeap) Modify(v Vertex, value int) {\tswitch {\tcase v.value  value:\t\tF.DecreaseKey(v, value)\t}}func (F FibonacciHeap) DeleteVertex(v Vertex) {\tF.DecreaseKey(v, MinInt)\tF.extractVertex(v)}// insertToList inserts v after posfunc (F FibonacciHeap) insertToList(pos Vertex, v *Vertex) {\tif pos == nil {\t\treturn\t}\tpos.right.left = v\tv.right = pos.right\tpos.right = v\tv.left = pos\tv.parent = pos.parent\tif pos.parent != nil {\t\tpos.parent.degree++\t}}func (F FibonacciHeap) extractVertex(v Vertex) *Vertex {\tif v == nil {\t\treturn nil\t}\tif v.parent != nil {\t\tif v.right != v {\t\t\tv.parent.child = v.right\t\t} else {\t\t\tv.parent.child = nil\t\t}\t\tv.parent.degree--\t\tv.parent = nil\t}\tif v.left != v {\t\tv.left.right = v.right\t\tv.right.left = v.left\t\tv.left = v\t\tv.right = v\t}\tv.mark = false\treturn v}func (F FibonacciHeap) cascadingCut(v Vertex) {\tparent := v.parent\tif parent == nil {\t\treturn\t}\tif v.mark == false {\t\tv.mark = true\t} else {\t\t// when the parent have lost a child\t\tF.extractVertex(v)\t\tF.insertToList(F.min, v)\t\tF.cascadingCut(parent)\t}}func (F *FibonacciHeap) consolidate() {\tif F.min == nil {\t\treturn\t}\tv := F.min\tdegree := v.degree\t// a record table to help merging vertices with the same degree\ttable := make([]*Vertex, degree+1)\tfor {\t\tif len(table) <= degree {\t\t\t// extend table size\t\t\ttable = append(table, make([]*Vertex, degree-len(table)+1)...)\t\t}\t\tif table[degree] == v {\t\t\tbreak\t\t}\t\tif table[degree] == nil {\t\t\t//currently ,there is no vertices having the same degree of v\t\t\ttable[degree] = v\t\t\tv = v.right\t\t} else {\t\t\t// make sure v is the minimal vertex\t\t\tif table[degree].value < v.value {\t\t\t\ttable[degree], v = v, table[degree]\t\t\t}\t\t\t// merge table[degree] to v as his child\t\t\t// make v become root\t\t\ttable[degree] = F.extractVertex(table[degree])\t\t\tif v.child == nil {\t\t\t\tv.child = table[degree]\t\t\t\ttable[degree].parent = v\t\t\t\tv.degree++\t\t\t} else {\t\t\t\t//v.degree has been increased in this function\t\t\t\tF.insertToList(v.child, table[degree])\t\t\t}\t\t\ttable[degree] = nil\t\t}\t\tdegree = v.degree\t}\t// find the min\tF.min = nil\tfor _, v := range table {\t\tif v == nil {\t\t\tcontinue\t\t}\t\tif F.min == nil {\t\t\tF.min = v\t\t} else if v.value < F.min.value {\t\t\tF.min = v\t\t}\t}} 参考 https://www.roading.org/algorithm/introductiontoalgorithm/ 斐 波 那 契 堆 fibonacci-heaps.htmlhttp://www.cnblogs.com/skywang12345/p/3659060.html  [1]: https://ol1kreips.qnssl.com/image.png \"image.png\"","title":" 斐 波 那 契 堆 之 Go 实现 ","oriTitle":"斐波那契堆之Go实现"}]