<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kricsleo</title>
  
  <subtitle>kricsleo&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kricsleo.github.io/"/>
  <updated>2019-02-25T05:09:58.439Z</updated>
  <id>https://kricsleo.github.io/</id>
  
  <author>
    <name>kricsleo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>constraint-validation</title>
    <link href="https://kricsleo.github.io/constraint-validation/"/>
    <id>https://kricsleo.github.io/constraint-validation/</id>
    <published>2019-02-25T03:38:04.000Z</published>
    <updated>2019-02-25T05:09:58.439Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;h5-原生表单校验api&quot;&gt;&lt;a href=&quot;#h5-原生表单校验api&quot; class=&quot;headerlink&quot; title=&quot;h5 原生表单校验api&quot;&gt;&lt;/a&gt;h5 原生表单校验api&lt;/h1&gt;&lt;p&gt;我们通常会对表单的 input 的做各种各样的校验, 比如长度, 大小, 格式等等, 其实在h5中为了方便这些校验原生就有不少的校验类型和方式, 只不过错误提示的样式由于各个浏览器不太一样, 而且无法自定义, 产品和设计一般都不会认可这样的表现, 所以目前还是比较少用到浏览器原生的校验, 不过了解一下还有没有坏处的.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="h5" scheme="https://kricsleo.github.io/tags/h5/"/>
    
  </entry>
  
  <entry>
    <title>BFC</title>
    <link href="https://kricsleo.github.io/BFC/"/>
    <id>https://kricsleo.github.io/BFC/</id>
    <published>2019-02-25T00:50:03.000Z</published>
    <updated>2019-02-25T03:25:33.886Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BFC-BLOCK-FORMATTING-CONTEXT&quot;&gt;&lt;a href=&quot;#BFC-BLOCK-FORMATTING-CONTEXT&quot; class=&quot;headerlink&quot; title=&quot;BFC (BLOCK FORMATTING CONTEXT)&quot;&gt;&lt;/a&gt;BFC (BLOCK FORMATTING CONTEXT)&lt;/h1&gt;&lt;p&gt;关于 BFC (BLOCK FORMATTING CONTEXT: 块格式化上下文)这个专有名词可能听得不多, 但是在实际的页面布局中实际上却是会经常碰到的, 只是没有特意去注意这个现象而已, 这里记录一下它是如何影响我们的布局的.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="css" scheme="https://kricsleo.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>ES6-map-set-symbol</title>
    <link href="https://kricsleo.github.io/ES6-map-set-symbol/"/>
    <id>https://kricsleo.github.io/ES6-map-set-symbol/</id>
    <published>2019-01-18T02:23:08.000Z</published>
    <updated>2019-01-18T05:48:11.499Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6中新的数据类型&quot;&gt;&lt;a href=&quot;#ES6中新的数据类型&quot; class=&quot;headerlink&quot; title=&quot;ES6中新的数据类型&quot;&gt;&lt;/a&gt;ES6中新的数据类型&lt;/h1&gt;&lt;p&gt;在ES6里面引入了一些新的数据类型, 包括 &lt;code&gt;Map&lt;/code&gt; / &lt;code&gt;Set&lt;/code&gt; / &lt;code&gt;Symbol&lt;/code&gt; 等等, 这里了解一下他们的用法和使用场景.&lt;br&gt;
    
    </summary>
    
      <category term="Front-end" scheme="https://kricsleo.github.io/categories/Front-end/"/>
    
    
      <category term="ES6" scheme="https://kricsleo.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Proxy</title>
    <link href="https://kricsleo.github.io/Proxy/"/>
    <id>https://kricsleo.github.io/Proxy/</id>
    <published>2019-01-17T10:50:49.000Z</published>
    <updated>2019-01-21T01:17:25.980Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;拥抱ES6中的新API–Proxy&quot;&gt;&lt;a href=&quot;#拥抱ES6中的新API–Proxy&quot; class=&quot;headerlink&quot; title=&quot;拥抱ES6中的新API–Proxy&quot;&gt;&lt;/a&gt;拥抱ES6中的新API–Proxy&lt;/h1&gt;&lt;p&gt;ES6带来了很多新的方便易用的API, Proxy(代理)就是其中之一, 意思可以理解为对象的代理, 实际上是一个构造函数, 通过这个构造函数我们可以对某个对象进行包装, 然后返回一个新的对象, 然后我们所有对原对象的操作都可以转移到这个新的对象上, 并且我们的操作过程是可以被拦截和过滤的, 这就类似于你请的律师一样, 他会为你处理你的事情, 并在处理的过程中进行一些你设定好的操作, 称为代理.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="ES6" scheme="https://kricsleo.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>todo</title>
    <link href="https://kricsleo.github.io/todo/"/>
    <id>https://kricsleo.github.io/todo/</id>
    <published>2019-01-16T08:22:30.000Z</published>
    <updated>2019-02-25T05:10:49.689Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h1&gt;&lt;p&gt;日常TODO&lt;br&gt;
    
    </summary>
    
      <category term="daily" scheme="https://kricsleo.github.io/categories/daily/"/>
    
    
      <category term="todo" scheme="https://kricsleo.github.io/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>SASS</title>
    <link href="https://kricsleo.github.io/SASS/"/>
    <id>https://kricsleo.github.io/SASS/</id>
    <published>2018-11-28T05:36:01.000Z</published>
    <updated>2018-11-28T05:45:31.969Z</updated>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SASS-笔记&quot;&gt;&lt;a href=&quot;#SASS-笔记&quot; class=&quot;headerlink&quot; title=&quot;SASS 笔记&quot;&gt;&lt;/a&gt;SASS 笔记&lt;/h1&gt;&lt;p&gt;以前使用 SASS 都比较浅显, 正好最近写的多了, 所以记录一下笔记.&lt;/p&gt;
&lt;h2 id=&quot;何
      
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="SASS" scheme="https://kricsleo.github.io/tags/SASS/"/>
    
      <category term="CSS" scheme="https://kricsleo.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>http-2.0</title>
    <link href="https://kricsleo.github.io/http-2-0/"/>
    <id>https://kricsleo.github.io/http-2-0/</id>
    <published>2018-11-16T09:00:58.000Z</published>
    <updated>2018-11-19T01:05:01.665Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于-HTTP-2-0&quot;&gt;&lt;a href=&quot;#关于-HTTP-2-0&quot; class=&quot;headerlink&quot; title=&quot;关于 HTTP/2.0&quot;&gt;&lt;/a&gt;关于 HTTP/2.0&lt;/h1&gt;&lt;p&gt;最近折腾了一段时间的 HTTP/2.0, 目前来说国内外很多大厂都已经用上了 HTTP/2.0, 部署起来也很容易, 这里关于协议的一些细节及部署过程做一个记录.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="HTTP/2.0" scheme="https://kricsleo.github.io/tags/HTTP-2-0/"/>
    
  </entry>
  
  <entry>
    <title>yahoo-best-practices-for-speeding-up-your-Web-Site</title>
    <link href="https://kricsleo.github.io/yahoo-best-practices-for-speeding-up-your-Web-Site/"/>
    <id>https://kricsleo.github.io/yahoo-best-practices-for-speeding-up-your-Web-Site/</id>
    <published>2018-11-15T08:01:33.000Z</published>
    <updated>2018-11-15T08:25:02.351Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;yahoo-的网站优化实践军规&quot;&gt;&lt;a href=&quot;#yahoo-的网站优化实践军规&quot; class=&quot;headerlink&quot; title=&quot;yahoo 的网站优化实践军规&quot;&gt;&lt;/a&gt;yahoo 的网站优化实践军规&lt;/h1&gt;&lt;p&gt;yahoo 的网站优化军规已经出来很多年了, 我是最近才看到, 然后做一下笔记, 也比对一下自己现在做的怎么样.&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://developer.yahoo.com/performance/rules.html?guccounter=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Best Practices for Speeding Up Your Web Site&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="yahoo" scheme="https://kricsleo.github.io/tags/yahoo/"/>
    
      <category term="speed" scheme="https://kricsleo.github.io/tags/speed/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="https://kricsleo.github.io/nginx/"/>
    <id>https://kricsleo.github.io/nginx/</id>
    <published>2018-11-08T02:29:02.000Z</published>
    <updated>2018-11-12T09:18:47.392Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;nginx-的部署与配置笔记&quot;&gt;&lt;a href=&quot;#nginx-的部署与配置笔记&quot; class=&quot;headerlink&quot; title=&quot;nginx 的部署与配置笔记&quot;&gt;&lt;/a&gt;nginx 的部署与配置笔记&lt;/h1&gt;&lt;p&gt;现在很多网站用的都是 nginx 作为代理服务器, 所以为了进行 web 性能的优化, 自然也要折腾一下 nginx 的配置的.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="nginx" scheme="https://kricsleo.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>length-of-url</title>
    <link href="https://kricsleo.github.io/length-of-url/"/>
    <id>https://kricsleo.github.io/length-of-url/</id>
    <published>2018-11-07T08:42:49.000Z</published>
    <updated>2018-11-07T08:52:40.023Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于URL长度的笔记&quot;&gt;&lt;a href=&quot;#关于URL长度的笔记&quot; class=&quot;headerlink&quot; title=&quot;关于URL长度的笔记&quot;&gt;&lt;/a&gt;关于URL长度的笔记&lt;/h1&gt;&lt;p&gt;在了解 cookie 的大小限制的时候看到了一片记录关于 URL 长度的博客, 所以收藏了下来.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="HTTP" scheme="https://kricsleo.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>service-worker</title>
    <link href="https://kricsleo.github.io/service-worker/"/>
    <id>https://kricsleo.github.io/service-worker/</id>
    <published>2018-11-04T13:32:46.000Z</published>
    <updated>2018-11-13T02:10:16.733Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;service-worker&quot;&gt;&lt;a href=&quot;#service-worker&quot; class=&quot;headerlink&quot; title=&quot;service-worker&quot;&gt;&lt;/a&gt;service-worker&lt;/h1&gt;&lt;p&gt;service worker (服务工作线程)可以为网页提供离线访问的功能, 除此之外当然也有&lt;strong&gt;推送通知&lt;/strong&gt;和&lt;strong&gt;后台同步&lt;/strong&gt;的功能, 它是一种 JavaScript 线程, 可以独立在主线程外独立运行, 但是无法直接访问和操作 DOM , 服务工作线程通过响应 postMessage 接口发送的消息来与其控制的页面通信, 页面可在必要时对 DOM 执行操作.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="service-worker" scheme="https://kricsleo.github.io/tags/service-worker/"/>
    
  </entry>
  
  <entry>
    <title>web-font</title>
    <link href="https://kricsleo.github.io/web-font/"/>
    <id>https://kricsleo.github.io/web-font/</id>
    <published>2018-11-01T02:11:36.000Z</published>
    <updated>2018-11-12T11:46:35.237Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网页字体加载过程及优化&quot;&gt;&lt;a href=&quot;#网页字体加载过程及优化&quot; class=&quot;headerlink&quot; title=&quot;网页字体加载过程及优化&quot;&gt;&lt;/a&gt;网页字体加载过程及优化&lt;/h1&gt;&lt;p&gt;现在很多网站为了视觉效果都在使用在线字体, 系统自带的字体可以直接使用, 但是自定义的在线字体需要通过&lt;code&gt;@font-face&lt;/code&gt;来加载. 这里主要结合我自己的博客的实践来记录一下网页字体的加载过程及优化.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="css" scheme="https://kricsleo.github.io/tags/css/"/>
    
      <category term="web-font" scheme="https://kricsleo.github.io/tags/web-font/"/>
    
  </entry>
  
  <entry>
    <title>optimize-my-blog</title>
    <link href="https://kricsleo.github.io/optimize-my-blog/"/>
    <id>https://kricsleo.github.io/optimize-my-blog/</id>
    <published>2018-10-21T06:58:11.000Z</published>
    <updated>2018-10-31T15:05:33.842Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo主题-MaterialFlow-主题改造&quot;&gt;&lt;a href=&quot;#hexo主题-MaterialFlow-主题改造&quot; class=&quot;headerlink&quot; title=&quot;hexo主题 MaterialFlow 主题改造&quot;&gt;&lt;/a&gt;hexo主题 MaterialFlow 主题改造&lt;/h1&gt;&lt;p&gt;打算对博客的访问速度和样式做一个改版优化.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="web优化" scheme="https://kricsleo.github.io/tags/web%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Promise-Generator</title>
    <link href="https://kricsleo.github.io/Promise-Generator/"/>
    <id>https://kricsleo.github.io/Promise-Generator/</id>
    <published>2018-10-18T02:33:04.000Z</published>
    <updated>2018-11-14T08:42:19.611Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;异步解决方案&quot;&gt;&lt;a href=&quot;#异步解决方案&quot; class=&quot;headerlink&quot; title=&quot;异步解决方案&quot;&gt;&lt;/a&gt;异步解决方案&lt;/h1&gt;&lt;p&gt;本文是为了解js的异步操作解决方案发展过程. 从原始的回调地狱到ES6的&lt;code&gt;Promise&lt;/code&gt;和&lt;code&gt;Generator&lt;/code&gt;再到ES7提案阶段的&lt;code&gt;async&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="Generator" scheme="https://kricsleo.github.io/tags/Generator/"/>
    
      <category term="Promise" scheme="https://kricsleo.github.io/tags/Promise/"/>
    
      <category term="async" scheme="https://kricsleo.github.io/tags/async/"/>
    
  </entry>
  
  <entry>
    <title>same-origin-and-CORS</title>
    <link href="https://kricsleo.github.io/same-origin-and-CORS/"/>
    <id>https://kricsleo.github.io/same-origin-and-CORS/</id>
    <published>2018-10-16T03:06:36.000Z</published>
    <updated>2019-01-17T12:27:29.564Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;浏览器同源策略&quot;&gt;&lt;a href=&quot;#浏览器同源策略&quot; class=&quot;headerlink&quot; title=&quot;浏览器同源策略&quot;&gt;&lt;/a&gt;浏览器同源策略&lt;/h1&gt;&lt;p&gt;目前的 web 开发还相当的依赖 cookie , 而cookie的使用限制于浏览器的同源策略(same-origin policy), 同时这个策略也是保证我们网站信息安全的基础, 这篇文章主要了解一下浏览器同源策略具体的含义, 以及在实际开发中如何绕过这一限制来达到跨域请求数据的目的.&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end" scheme="https://kricsleo.github.io/categories/Front-end/"/>
    
    
      <category term="same-origin" scheme="https://kricsleo.github.io/tags/same-origin/"/>
    
      <category term="CORS" scheme="https://kricsleo.github.io/tags/CORS/"/>
    
      <category term="cookie" scheme="https://kricsleo.github.io/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>Content-Type</title>
    <link href="https://kricsleo.github.io/Content-Type/"/>
    <id>https://kricsleo.github.io/Content-Type/</id>
    <published>2018-10-12T02:32:51.000Z</published>
    <updated>2018-10-21T16:40:34.964Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Content-Type&quot;&gt;&lt;a href=&quot;#Content-Type&quot; class=&quot;headerlink&quot; title=&quot;Content-Type&quot;&gt;&lt;/a&gt;Content-Type&lt;/h1&gt;&lt;p&gt;&lt;code&gt;HTTP/1.1&lt;/code&gt;协议规定的&lt;code&gt;HTTP&lt;/code&gt;请求方法有&lt;code&gt;OPTIONS&lt;/code&gt;、&lt;code&gt;GET&lt;/code&gt;、&lt;code&gt;HEAD&lt;/code&gt;、&lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;TRACE&lt;/code&gt;、&lt;code&gt;CONNECT&lt;/code&gt;这几种, 用的最多的是&lt;code&gt;GET&lt;/code&gt;和&lt;code&gt;POST&lt;/code&gt;, 这里主要说一下提交请求时的请求头中&lt;code&gt;Content-Type&lt;/code&gt;字段&lt;br&gt;
    
    </summary>
    
      <category term="通信" scheme="https://kricsleo.github.io/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="Content-Type" scheme="https://kricsleo.github.io/tags/Content-Type/"/>
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="https://kricsleo.github.io/http/"/>
    <id>https://kricsleo.github.io/http/</id>
    <published>2018-10-12T02:29:30.000Z</published>
    <updated>2018-10-23T05:17:32.026Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;http&quot;&gt;&lt;a href=&quot;#http&quot; class=&quot;headerlink&quot; title=&quot;http&quot;&gt;&lt;/a&gt;http&lt;/h1&gt;&lt;p&gt;http虽然内容简单, 容易理解, 但是内容十分庞大, 涉及到现在通信的方方面面, 我打算花点时间陆陆续续的把我接触到的http的相关部分整理出来, 这里作为一个入口页, 后续持续补充.&lt;br&gt;
    
    </summary>
    
      <category term="通信" scheme="https://kricsleo.github.io/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="http" scheme="https://kricsleo.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>object-defineProperty</title>
    <link href="https://kricsleo.github.io/object-defineProperty/"/>
    <id>https://kricsleo.github.io/object-defineProperty/</id>
    <published>2018-10-07T16:06:51.000Z</published>
    <updated>2019-01-17T06:06:28.811Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;属性描述符&quot;&gt;&lt;a href=&quot;#属性描述符&quot; class=&quot;headerlink&quot; title=&quot;属性描述符&quot;&gt;&lt;/a&gt;属性描述符&lt;/h1&gt;&lt;p&gt;在js的对象中通常会有很多个属性, 例如&lt;code&gt;let person = { name: &amp;#39;john&amp;#39;}&lt;/code&gt;中的&lt;code&gt;name&lt;/code&gt;就是&lt;code&gt;person&lt;/code&gt;这个对象的一个属性, 我们可以定义这个属性的一些特性, 也就是来描述这个属性, 比如这个属性是否是可读写的, 是否是可以被枚举的等等, 由此产生出了&lt;strong&gt;属性描述符&lt;/strong&gt;这个概念.&lt;br&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://kricsleo.github.io/categories/front-end/"/>
    
    
      <category term="object" scheme="https://kricsleo.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>MVC-MVP-MVVM</title>
    <link href="https://kricsleo.github.io/MVC-MVP-MVVM/"/>
    <id>https://kricsleo.github.io/MVC-MVP-MVVM/</id>
    <published>2018-09-28T11:51:24.000Z</published>
    <updated>2019-01-17T12:27:29.564Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于-MV&quot;&gt;&lt;a href=&quot;#关于-MV&quot; class=&quot;headerlink&quot; title=&quot;关于 MV*&quot;&gt;&lt;/a&gt;关于 MV*&lt;/h1&gt;&lt;p&gt;为了管理有图形界面的应用程序, 先后提出了 MVC, MVP 和 MVVM 等应用架构模式, 我们也许常常听到这几个词, 尤其对我这个前后端都做过的人来说更是时常接触, 但是对于他们之间的区别却不甚了解, 这几天看了不少文章讲这一块, 在看到 Github 上 livoras 写的文章以后才终在心里有所区分, 这里转载一下 livoras 的原文.&lt;/p&gt;
&lt;p&gt;作者: livoras&lt;br&gt;原文: &lt;a href=&quot;https://github.com/livoras/blog/issues/11&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/livoras/blog/issues/11&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外可以看一下掘金上的这篇文章, 与前端开发结合起来更好理解: &lt;a href=&quot;https://juejin.im/post/593021272f301e0058273468&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浅析前端开发中的 MVC/MVP/MVVM 模式&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Front-end" scheme="https://kricsleo.github.io/categories/Front-end/"/>
    
    
      <category term="MVC" scheme="https://kricsleo.github.io/tags/MVC/"/>
    
      <category term="MVP" scheme="https://kricsleo.github.io/tags/MVP/"/>
    
      <category term="MVVM" scheme="https://kricsleo.github.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS-AMD-CMD-ES6</title>
    <link href="https://kricsleo.github.io/CommonJS-AMD-CMD/"/>
    <id>https://kricsleo.github.io/CommonJS-AMD-CMD/</id>
    <published>2018-09-25T08:49:17.000Z</published>
    <updated>2019-01-17T12:27:29.579Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript-模块化&quot;&gt;&lt;a href=&quot;#JavaScript-模块化&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 模块化&quot;&gt;&lt;/a&gt;JavaScript 模块化&lt;/h1&gt;&lt;p&gt;远古时期, 我们写的 js 都是都是通过 script 标签进行管理, 这使得项目一旦复杂, 页面内便会写上成堆的 script 标签来引入各种外部 js 文件, 而且我们还需要保证 js 的顺序, 因为一个 js 文件内的方法往往依赖另外的 js 来实现, 我们通过确保书写顺序来确保 js 的加载顺序, 这当然是极不方便的, 后来前端工程师们就开始了尝试 js 模块化的探索之旅.&lt;br&gt;
    
    </summary>
    
      <category term="Front-end" scheme="https://kricsleo.github.io/categories/Front-end/"/>
    
    
      <category term="前端模块化" scheme="https://kricsleo.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
</feed>
