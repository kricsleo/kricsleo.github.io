<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>IIFE</title>
      <link href="/2018/09/02/IIFE/"/>
      <url>/2018/09/02/IIFE/</url>
      <content type="html"><![CDATA[<h1 id="转-译-JavaScript：立即执行函数表达式（IIFE）"><a href="#转-译-JavaScript：立即执行函数表达式（IIFE）" class="headerlink" title="[转][译]JavaScript：立即执行函数表达式（IIFE）"></a>[转][译]JavaScript：立即执行函数表达式（IIFE）</h1><blockquote><p>原文: <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife" target="_blank" rel="noopener">http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife</a><br>译文: <a href="https://segmentfault.com/a/1190000003985390" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003985390</a> by Murphywuwu</p></blockquote><hr><p>可能你并没有注意到，我是一个对于专业术语有一点坚持细节人。所有，当我听到流行的但是还存在误解的术语“自执行匿名函数”多次时，我最终决定将我的想法写进这篇文章里。</p><p>除了提供关于这种模式事实上是如何工作的一些全面的信息，更进一步的，实际上我建议我们应该知道我们应该叫它什么。而且，如果你想跳过这里，你可以直接跳到立即调用函数表达式进行阅读，但是我建议你读完整篇文章。</p><a id="more"></a><p>（#: 请注意，<br>本文中大部分内容尊重原创，部分个人的理解我会用括号并加上’#: ‘符号表示。<br>–kricsleo）</p><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h2><p>在 JavaScript 里，每个函数，当被调用时，都会创建一个新的执行上下文。因为在函数里定义的变量和函数是唯一在内部被访问的变量，而不是在外部被访问的变量，当调用函数时，函数提供的上下文提供了一个非常简单的方法创建私有变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(++i);</span><br><span class="line">    &#125;;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记住：`counter`和`counter2`都有他们自己的变量 `i`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = makeCounter();</span><br><span class="line">counter();<span class="comment">//1</span></span><br><span class="line">counter();<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter2 = makeCounter();</span><br><span class="line">counter2();<span class="comment">//1</span></span><br><span class="line">counter2();<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">i;<span class="comment">//ReferenceError: i is not defined(它只存在于makeCounter里)</span></span><br></pre></td></tr></table></figure></p><p>在许多情况下，你可能并不需要makeWhatever这样的函数返回多次累加值，并且可以只调用一次得到一个单一的值，在其他一些情况里，你甚至不需要明确的知道返回值。</p><h3 id="它的核心"><a href="#它的核心" class="headerlink" title="它的核心"></a>它的核心</h3><p>现在，无论你定义一个函数像这样function foo(){}或者var foo = function(){}，调用时，你都需要在后面加上一对圆括号，像这样foo()。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向下面这样定义的函数可以通过在函数名后加一对括号进行调用，像这样`foo()`，</span></span><br><span class="line"><span class="comment">//因为foo相对于函数表达式`function()&#123;/* code */&#125;`只是一个引用变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那这可以说明函数表达式可以通过在其后加上一对括号自己调用自己吗？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span>&#125;(); <span class="comment">//SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure></p><p>正如你所看到的，这里捕获了一个错误。当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的function关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。</p><p>(#: 函数声明与函数表达式:<br>关于这两者的定义你可以参看MDN的说明文档:<a href="https://developer.mozilla.org/zh-CN/docs/web/JavaScript/Reference/Operators/function" target="_blank" rel="noopener">函数表达式</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function" target="_blank" rel="noopener">函数声明</a><br>共同点: 两者都可以用<code>function</code>关键字来创建一个函数，用法也很类似，例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数表达式,这样生成的是一个具名函数,叫`bar`</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>)&#125;</span><br><span class="line"><span class="comment">//或者函数表达式也可以这样写,这样生成的是一个匿名函数,`foo`只是这个匿名函数的引用</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>)&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出我们使用函数声明和函数表达式都可以用来创建一个实现某些功能的函数<br>不同点: </p><ol><li>从上面的例子我们可以看出函数声明只有一种写法,你必须给出函数的名字才行,如<code>foo</code>;<br>而函数表达式则有两种写法,第一种是生成命名函数叫<code>bar</code>,后一种是生成匿名函数,注意函数表达式中的<code>foo</code>并不是函数名,它只是函数的一个引用而已,代表你可以使用<code>foo</code>来间接的调用真正的函数;</li><li>函数声明存在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87" target="_blank" rel="noopener"><strong>提升</strong></a>,而函数表达式不存在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87" target="_blank" rel="noopener"><strong>提升</strong></a>,这意味着如果你是用函数声明的方法创建一个函数,那么你可以在定义这个函数之前就去使用它;<br>但是如果你是用函数表达式的方法来创建一个函数,那么你就必须要在函数被创建了以后才可以去使用这个函数,例如:  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ƒ foo()&#123;console.log(1)&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>)&#125;</span><br><span class="line"></span><br><span class="line">consol.log(foo2); <span class="comment">// Uncaught ReferenceError: consol is not defined</span></span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>)&#125;</span><br></pre></td></tr></table></figure></li></ol><p>你也可以参考<a href="https://github.com/Wscats/Good-text-Share/issues/73" target="_blank" rel="noopener">这里</a>给出的例子</p><ol start="3"><li>额外的一点是我们经常使用函数表达式的方式来创建匿名函数,进而创建IIFE,这一点就跟本文主要内容联系起来了;</li><li><p>还有一个区别是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function#%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">有条件的创建函数</a>,当函数声明出现在非功能模块（比如 if）中时,虽然官方是禁止这样做的,但是实际上浏览器都支持这种做法,但是各个浏览器的处理方式有不同,这一点兼容性问题实在很头疼,所以我们不应该在生成环境代码中使用这种方式，应该使用函数表达式来代替。<br>–kricsleo)</p></li><li><p>问题1：这里我么可以思考一个问题，我们是不是也可以像这样直接调用函数<code>var foo = function(){console.log(1)}()</code>，答案是可以的。</p></li><li>问题2：同样的，我们还可以思考一个问题，像这样的函数声明在后面加上圆括号被直接调用，又会出现什么情况呢？请看下面的解答。</li></ol><h3 id="函数，圆括号，错误"><a href="#函数，圆括号，错误" class="headerlink" title="函数，圆括号，错误"></a>函数，圆括号，错误</h3><p>有趣的是，如果你为一个函数指定一个名字并在它后面放一对圆括号，同样的也会抛出错误，但这次是因为另外一个原因。</p><p>(#:<br>之前的<code>function (){console.log(1)}()</code>报错出现在第一个括号，因为声明一个函数需要名字，这里声明没有给出名字，所以直接报错，走不到第二个括号，但是<code>function foo(){console.log(1)}()</code>报错出现在第二括号，因为这里声明函数是正确的，当处理到第二个括号时，发现第二个括号内没有任何东西，这是不允许的,理由参见下面，所以报错<br>–kricsleo)</p><p>当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号(用来控制运算优先的括号)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();<span class="comment">//SyntaxError: Unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//它等同于如下，一个函数声明跟着一个完全没有关系的表达式:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;</span><br><span class="line">(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h2 id="立即执行函数表达式（IIFE）"><a href="#立即执行函数表达式（IIFE）" class="headerlink" title="立即执行函数表达式（IIFE）"></a>立即执行函数表达式（IIFE）</h2><p>幸运的是，修正语法错误很简单。最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在<code>Javascript</code>里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了<code>function</code>关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。注意理解这里的圆括号和上面的圆括号遇到函数时的表现是不一样的，也就是说。</p><ol><li><p>当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。</p></li><li><p>当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这两种模式都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;());<span class="comment">//Crockford recommends this one，括号内的表达式代表函数立即调用表达式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;)();<span class="comment">//But this one works just as well，括号内的表达式代表函数表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Because the point of the parens or coercing operators is to disambiguate</span></span><br><span class="line"><span class="comment">// between function expressions and function declarations, they can be</span></span><br><span class="line"><span class="comment">// omitted when the parser already expects an expression (but please see the</span></span><br><span class="line"><span class="comment">// "important note" below).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">10</span>;&#125;();</span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;();</span><br><span class="line"><span class="number">0</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节</span></span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;();</span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;();</span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here's another variation, from @kuvos - I'm not sure of the performance</span></span><br><span class="line"><span class="comment">// implications, if any, of using the `new` keyword, but it works.</span></span><br><span class="line"><span class="comment">// http://twitter.com/kuvos/status/18209252090847232</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;</span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;() <span class="comment">// Only need parens if passing arguments</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="关于括号的重要笔记"><a href="#关于括号的重要笔记" class="headerlink" title="关于括号的重要笔记"></a>关于括号的重要笔记</h3><p>在一些情况下，当额外的带着歧义的括号围绕在函数表达式周围是没有必要的(因为这时候的括号已经将其作为一个表达式去表达)，但当括号用于调用函数表达式时，这仍然是一个好主意。</p><p>这样的括号指明函数表达式将会被立即调用，并且变量将会储存函数的结果，而不是函数本身。当这是一个非常长的函数表达式时，这可以节约比人阅读你代码的时间，不用滚到页面底部去看这个函数是否被调用。</p><p>作为规则，当你书写清楚明晰的代码时，有必要阻止 JavaScript 抛出错误的，同样也有必要阻止其他开发者对你抛出错误<code>WTFError</code>!</p><h3 id="保存闭包的状态"><a href="#保存闭包的状态" class="headerlink" title="保存闭包的状态"></a>保存闭包的状态</h3><p>就像当函数通过他们的名字被调用时，参数会被传递，而当函数表达式被立即调用时，参数也会被传递。一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量(这种关系被叫做闭包)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它的运行原理可能并不像你想的那样，因为`i`的值从来没有被锁定。</span></span><br><span class="line"><span class="comment">// 相反的，每个链接，当被点击时（循环已经被很好的执行完毕），因此会弹出所有元素的总数，</span></span><br><span class="line"><span class="comment">// 因为这是 `i` 此时的真实值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; elems.length; i++ ) &#123;</span><br><span class="line">    elems[i].addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        alert(<span class="string">'I am link #'</span> + i)</span><br><span class="line">        &#125;,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而像下面这样改写，便可以了，因为在IIFE里，`i`值被锁定在了`lockedInIndex`里。</span></span><br><span class="line"><span class="comment">// 在循环结束执行时，尽管`i`值的数值是所有元素的总和，但每一次函数表达式被调用时，</span></span><br><span class="line"><span class="comment">// IIFE 里的 `lockedInIndex` 值都是`i`传给它的值,所以当链接被点击时，正确的值被弹出。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; elems.length;i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">lockedInIndex</span>)</span>&#123;</span><br><span class="line">        elems[i].addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert(<span class="string">'I am link #'</span> + lockedInIndex);</span><br><span class="line">            &#125;,<span class="literal">false</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//你同样可以像下面这样使用IIFE，仅仅只用括号包括点击处理函数，并不包含整个`addEventListener`。</span></span><br><span class="line"><span class="comment">//无论用哪种方式，这两个例子都可以用IIFE将值锁定，不过我发现前面一个例子更可读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName( <span class="string">'a'</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++ ) &#123;</span><br><span class="line">    elems[ i ].addEventListener( <span class="string">'click'</span>, (<span class="function"><span class="keyword">function</span>(<span class="params"> lockedInIndex </span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert( <span class="string">'I am link #'</span> + lockedInIndex );</span><br><span class="line">        &#125;;</span><br><span class="line">        &#125;)( i ),<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>记住，在这最后两个例子里，<code>lockedInIndex</code>可以没有任何问题的访问<code>i</code>,但是作为函数的参数使用一个不同的命名标识符可以使概念更加容易的被解释。</p><p>立即执行函数一个最显著的优势是就算它没有命名或者说是匿名，函数表达式也可以在没有使用标识符的情况下被立即调用，一个闭包也可以在没有当前变量污染的情况下被使用。</p><p>自执行匿名函数(“Self-executing anonymous function”)有什么问题呢？<br>你看到它已经被提到好几次了，但是它仍然不是那么清楚的被解释，我提议将术语改成”Immediately-Invoked Function Expression”，或者，IIFE，如果你喜欢缩写的话。</p><p>什么是Immediately-Invoked Function Expression呢？它使一个被立即调用的函数表达式。就像引导你去调用的函数表达式。</p><p>我想Javascript社区的成员应该可以在他们的文章里或者陈述里接受术语，Immediately-Invoked Function Expression和 IIFE，因为我感觉这样更容易让这个概念被理解，并且术语”self-executing anonymous function”真的也不够精确。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是个自执行函数，递归的调用自己本身</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;foo();&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个自执行匿名函数。因为它没有标识符，它必须是使用`arguments.callee`属性来调用它自己</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">arguments</span>.callee();&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这也许算是一个自执行匿名函数，但是仅仅当`foo`标识符作为它的引用时，如果你将它换成用`foo`来调用同样可行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;foo();&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有些人像这样叫'self-executing anonymous function'下面的函数,即使它不是自执行的，因为它并没有调用它自己。然后，它只是被立即调用了而已。</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*code*/</span> &#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//为函数表达式增加标识符(也就是说创造一个命名函数)对我们的调试会有很大帮助。一旦命名，函数将不再匿名。</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//IIFEs同样也可以自执行，尽管，也许他不是最有用的模式</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">arguments</span>.callee();&#125;())</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;foo();&#125;())</span><br><span class="line"></span><br><span class="line"><span class="comment">// One last thing to note: this will cause an error in BlackBerry 5, because</span></span><br><span class="line"><span class="comment">// inside a named function expression, that name is undefined. Awesome, huh?</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; foo(); &#125;());</span><br></pre></td></tr></table></figure></p><p>希望上面的例子可以让你更加清楚的知道术语’self-executing’是有一些误导的，因为他并不是执行自己的函数，尽管函数已经被执行。同样的，匿名函数也没用必要特别指出，因为，Immediately Invoked Function Expression，既可以是命名函数也可以匿名函数。</p><h2 id="最后：模块模式"><a href="#最后：模块模式" class="headerlink" title="最后：模块模式"></a>最后：模块模式</h2><p>当我调用函数表达式时，如果我不至少一次的提醒我自己关于模块模式，我便很可能会忽略它。如果你并不熟悉<code>JavaScript</code>里的模块模式，它和我下面的例子很像，但是返回值用对象代替了函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            i = val;</span><br><span class="line">        &#125;,</span><br><span class="line">        increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;());</span><br><span class="line">    counter.get();<span class="comment">//0</span></span><br><span class="line">    counter.set(<span class="number">3</span>);</span><br><span class="line">    counter.increment();<span class="comment">//4</span></span><br><span class="line">    counter.increment();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    conuter.i;<span class="comment">//undefined (`i` is not a property of the returned object)</span></span><br><span class="line">    i;<span class="comment">//ReferenceError: i is not defined (it only exists inside the closure)</span></span><br></pre></td></tr></table></figure></p><p>模块模式方法不仅相当的厉害而且简单。非常少的代码，你可以有效的利用与方法和属性相关的命名，在一个对象里，组织全部的模块代码即最小化了全局变量的污染也创造了使用变量。</p>]]></content>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ssh-git</title>
      <link href="/2018/08/30/ssh-git/"/>
      <url>/2018/08/30/ssh-git/</url>
      <content type="html"><![CDATA[<h1 id="github的https和ssh连接方式探究"><a href="#github的https和ssh连接方式探究" class="headerlink" title="github的https和ssh连接方式探究"></a>github的https和ssh连接方式探究</h1><p>在本机连接github仓库提交代码时有两种可选方法，一种是使用github账号的用户名和密码的认证方式通过https连接，另一种是使用ssh-key的认证方式通过ssh连接，本文主要研究这两种方式的工作过程以及可能会扩展探究一些相关的知识。<br><a id="more"></a></p><h2 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h2><ol><li>首先在本机下载安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>，一路点next默认安装即可;</li><li>clone一个github上的项目到本地</li></ol><h3 id="选择使用https"><a href="#选择使用https" class="headerlink" title="选择使用https"></a>选择使用https</h3><p>以我的博客所使用<a href="https://github.com/stkevintan/hexo-theme-material-flow" target="_blank" rel="noopener">hexo的materialFlow主题项目</a>为例(这个项目我没有管理权限)，一行命令<code>git clone https://github.com/stkevintan/hexo-theme-material-flow.git</code>即可clone到本地</p><h3 id="选择使用ssh"><a href="#选择使用ssh" class="headerlink" title="选择使用ssh"></a>选择使用ssh</h3><p>此时你就无法直接使用<code>git clone git@github.com:stkevintan/hexo-theme-material-flow.git</code>命令来clone上面那个项目到本地，会产生如下错误提示：</p><blockquote><p>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights and the repository exists.</p></blockquote><p>因为ssh的方式是需要进行认证的，你必须是这个项目的所有者或者管理者，才能有权限去使用ssh方式clone该项目，而上面的https方式则允许任何一个人在不需要验证的情况下去clone项目.</p><p><strong>那么接下来看一下对于一个我们有管理权限的仓库应该如何使用ssh方式去clone到本地</strong></p><p>ssh方式是基于不对称性加密来通信的，你需要使用不对称性算法来生成一对密钥，然后将私钥放置在你本机上，将公钥放置在github服务器上，之后在进行ssh通信时将会使用这对秘钥来完成认证登陆及加密和解密信息，<br>在window上和mac上我们都可以使用<code>ssh-keygen</code>这个命令行工具来生成我们需要的密钥，这是我们想要使用ssh通信的第一步</p><ol><li>生成一对密钥<br>打开你的命令行（window下使用<code>cmd.exe</code>，mac下使用<code>terminal.app</code>），然后按照如下命令来生成密钥<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br><span class="line"><span class="comment"># 参数说明：  </span></span><br><span class="line"><span class="comment"># ssh-keygen: 表示将要使用ssh-keygen这个工具来生成密钥</span></span><br><span class="line"><span class="comment"># -t: 指定要生成的密钥类型，有rsa1(SSH1),dsa(SSH2),ecdsa(SSH2),rsa(SSH2)等类型，较为常用的是rsa类型，此处指定为rsa类型</span></span><br><span class="line"><span class="comment"># -b: 指定要生成的密钥长度 (单位:bit)，对于RSA类型的密钥，最小长度768bits,默认长度为2048bits。DSA密钥必须是1024bits，此处指定为4096bits</span></span><br><span class="line"><span class="comment"># -C: 制定要生成的密钥的注释，这个可以自己随意填写，就相当于给这个密钥留个名，好分辨，比如此处可以用注册github的邮箱号</span></span><br></pre></td></tr></table></figure></li></ol><p>之后会出现如下提示内容：</p><blockquote><p>Generating public/private rsa key pair.<br>Enter file in which to save the key (C:/Users/xxxxx/.ssh/id_rsa):</p></blockquote><p>意思是让你输入这个密钥文件的文件名，一般情况保存默认就可以，直接回车确认。<br><em>（如果你有多个git的账号需要配置，比如你自己在github上有账号需要提交代码，同时自己在公司也有git的账号，有时候需要提交代码到公司的仓库里，那么这时候你就需要额外的配置来保证提交的时候不会冲突，<a href="#多git账户配置">详见下面</a>）</em><br>然后会出现下一个提示内容：</p><blockquote><p>Enter passphrase (empty for no passphrase):</p></blockquote><p>意思是要不要对私钥设置口令（passphrase），如果担心私钥的安全，你可以设置一个，这里一般不设置，直接回车确认即可，最后会出现类似如下的提示内容：</p><blockquote><p>+—[RSA 4096]—-+<br>| o+o     ..  .o  |<br>| oo… o … =   |<br>|+ +.+ o.o.o.+ o  |<br>|oB =.o..E.o* o   |<br>|o = o.o Soo+=    |<br>|   . o .+++ .    |<br>|       o.o       |<br>|      ..         |<br>|      ..         |<br>+—-[SHA256]—–+  </p></blockquote><p>那么恭喜你，你已经生成了一对密钥文件，他们存储在<code>C:/Users/xxxxx/.ssh/</code>（windows）或者<code>~/.ssh</code>（mac）目录下，默认的文件是id_rsa（私钥文件名）和id_rsa.pub（公钥文件名），你可以去打开查看一下里面的内容。</p><ol start="2"><li>部署密钥<br>之前说过了你需要将私钥保存在本机，公钥放置在服务器上，这样之后才能用这对密钥建立ssh通信，那么在github上我们按照如下做法来部署密钥<ol><li>用文本编辑器打开刚才生成的公钥文件id_rsa.pub，拷贝里面的全部内容；</li><li>打开浏览器登陆你的github账户，依次打开你头像上的Settings &gt; SSH and GPG keys &gt; New SSH key;</li><li>填写相关信息，<strong>title</strong>可以类似之前生成密钥时填写的注释信息那样填写你的邮箱名，然后<strong>key</strong>里面填上刚才拷贝的公钥内容，点击<strong>Add SSH key</strong>之后输入一次你的github账户密码进行确认，然后你的公钥就被保存部署到github服务器上了；</li></ol></li><li>测试连接，使用如下命令来测试是否能够通过ssh连接到github<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh git@github.com</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># ssh: 使用ssh进行连接</span></span><br><span class="line"><span class="comment"># git@github.com: ssh连接时需要指定登陆用户名和远程主机名，这里的git就是github的远程服务器的用户名，github.com就是远程服务器的主机名，用'@'符号连接起来</span></span><br></pre></td></tr></table></figure></li></ol><p>当你是第一次连接的时候会提示你如下信息：</p><blockquote><p>The authenticity of host ‘github.com (52.74.223.119)’ can’t be established.<br>RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.<br>Are you sure you want to continue connecting (yes/no)?  </p></blockquote><p>这是因为你是第一次连接该主机，该主机不在你本机的<code>known hosts</code>（已知主机）名单里面，所以询问你是否要继续连接这个陌生的主机，输入<code>yes</code>然后回车确认即可，之后再次连接的时候就不会有这个提示信息了。<br>如果你配置步骤没问题的话应该可以看到下面的连接上之后的欢迎信息(xxxxx代表你的github的账户名)：</p><blockquote><p>Warning: Permanently added ‘github.com,52.74.223.119’ (RSA) to the list of known hosts.<br>PTY allocation request failed on channel 0<br>Hi xxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.<br>Connection to github.com closed. </p></blockquote><ol start="4"><li>使用ssh方式clone项目<br>之前说过了ssh方式只能操作我们有管理权限的项目，所以这里我拿自己做的一个<a href="https://github.com/kricsleo/vehicleKeyboard" target="_blank" rel="noopener">微信小程序的虚拟车牌键盘</a>的项目为例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:kricsleo/vehicleKeyboard.git</span><br></pre></td></tr></table></figure></li></ol><p>这个时候我们就能顺利clone该项目到本机了，因为在我们上面这条命令请求数据的过程中，我们本机和github的服务器会使用我们之前生成的那对密钥来进行相互认证，从而使我们不需要手动输入github的账户名和密码信息来完成认证登陆，同时我们以后修改了项目代码在进行提交的时候也可直接进行提交等相关操作，无需再考虑登陆及连接的问题，git的使用可以参考我之前的一篇<a href="http://kricsleo.com/2018/08/22/git-workflow/" target="_blank" rel="noopener">小总结</a></p><ol start="5"><li>配置个人信息<br>使用git提交更改的时候会为本次提交附上提交人的一些信息，比如提交人的用户名及邮箱信息，我们可以使用git提供的配置功能来提前配置好这些信息，使用如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"John Doe"</span></span><br><span class="line">git config --global user.email <span class="string">"johndoe@example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># git config: 表示使用git的配置工具</span></span><br><span class="line"><span class="comment"># --global: 表示配置全局的信息，你也可以在某个项目下面单独配置这个信息，只需要去掉'--global'即可，</span></span><br><span class="line"><span class="comment"># &lt;- 这样不同的项目就会有不同提交人信息</span></span><br><span class="line"><span class="comment"># user.name / user.email: 后面跟上你自己的用户名和邮箱信息即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后我们可以使用如下命令来查看我们配置的信息</span></span><br><span class="line"><span class="comment">#git config user.name</span></span><br><span class="line"><span class="comment">#git config user.email</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="多git账户配置"><a href="#多git账户配置" class="headerlink" title="多git账户配置"></a>多git账户配置</h2><p>如果你需要生成多对密钥，比如你需要和两个不一样的服务器A和B进行ssh通信，那么这个时候你就可以生成两对密钥，一对用来和A通信，另一对用来和B通信，最常见的情况就是我们自己在github上面会有自己的github账户，自己平时会开发一些自己的项目，然后提交到github上面，在公司里面公司一般会有自己的gitlab服务器，然后给员工开通一个gitlab的账号，有关公司内部的项目就会让员工用gitlab的账户进行开发，然后提交代码到公司的gitlab上面，那么这时候我们可以按照如下的方法来配置一下，保证自己随时提交代码的时候都是能够提交到正确的地方，而不会混乱。</p><ol><li>再生成一对密钥<br>在上面的操作中你已经生成了一对密钥，名字叫做<code>id_rsa</code>和<code>id_rsa.pub</code>（如果你没有改名的话），这个密钥我们已经拿来和github进行通信了，此时我们要想和公司的gitlab通信就需要再生成一对密钥，为了避免这次生成的密钥覆盖我们之前的那对密钥，可以执行如下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"youremail@yourcompany.com” -f ~/.ssh/id_rsa_xx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 参数说明</span></span><br><span class="line"><span class="string"># 这次我们生成密钥的命令只比之前多了一个参数： -f</span></span><br><span class="line"><span class="string"># -f: 表示将这次什么的密钥文件保存为id_rsa_xx，同样放在了之前的那个文件夹，这个文件名你可以自己随意指定，不过最好容易区分一些</span></span><br></pre></td></tr></table></figure></li></ol><p>后面你的操作就和之前生成密钥一样了，生成好密钥之后再看下一步</p><ol start="2"><li>部署新生成的密钥<br>和之前部署github密钥的步骤类似，你登录你公司的gitlab，找到添加<code>ssh-key</code>的地方，然后拷贝新生成的公钥id_rsa_xx.pub文件内容到gitlab里面去并且保存，这样你公司的gitlab服务器上的公钥信息就配置好了</li><li><p>新建配置文件<br>因为现在我们本机上有了两对密钥，提交代码到github时需要使用之前生成的那一对，提交代码到公司的gitlab上需要我们现在刚刚生成的这一对，那么我们就要写一个简单的配置文件来告诉git该如何再提交代码时选择正确的密钥，实际上就是编写SSH的用户配置文件config。<br>在目录<code>~/.ssh</code>(mac环境)或者<code>C:/Users/xxxxx/.ssh/</code>下新建文件<code>config</code>，注意<strong>没有后缀名</strong>的，然后在里面填写上如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#github</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment">#yourcompany</span></span><br><span class="line">Host git.XXXXX.com</span><br><span class="line">    HostName git.XXXXX.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_XX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明，此段内容不用拷贝，是为了加以说明</span></span><br><span class="line"><span class="comment"># Host: 别名，为了方便记忆和区分，可以任意填写</span></span><br><span class="line"><span class="comment"># HostName： 主机名 服务器的主机名，也可以是服务器的ip地址，需要准确填写</span></span><br><span class="line"><span class="comment"># User： 用户名，ssh登录服务器时的用户名，一般是git</span></span><br><span class="line"><span class="comment"># IdentityFile： 密钥文件的路径，填写上你要用来和这个服务器通信使用的密钥文件的路径</span></span><br><span class="line"><span class="comment"># PreferredAuthentications： 强制使用Public Key验证，我这里没有要求这个，你也可以加上</span></span><br></pre></td></tr></table></figure></li><li><p>测试连接<br>使用如下命令来分别测试能否连接到对应的服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试连接公司</span></span><br><span class="line">ssh git@git.XXXXX.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试连接github</span></span><br><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure></li></ol><p>如果能分别看到对应的欢迎信息，那么恭喜你配置正确了。</p><ol start="5"><li>配置个人信息<br>这次我们因为有不同的项目，提交时需要附加上的个人信息也不一样，你提交github时会用你自己的github账户名和邮箱信息，但是提交公司的gitlab时会使用公司给你的账户名和公司个人邮箱，那么我们就需要到具体的项目下面执行如下的命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">"yourname"</span></span><br><span class="line">git config user.email <span class="string">"youremail@XXXXX.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># 与之前我们执行的那条配置个人信息命令相比，只是少了个'--global'参数，因为我们现在不是在全局配置，而是在个别项目中单独配置</span></span><br></pre></td></tr></table></figure></li></ol><p>到这里为止，你的多git账户依旧配置完毕了，后面就可以和平常一样使用git来提交代码了，ssh会为你选择正确的密钥来和服务器认证和通信。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>这篇文章里面给我自己埋了些坑要填</p><ul><li style="list-style: none"><input type="checkbox"> 完全使用https协议该如何用git来开发项目</li><li style="list-style: none"><input type="checkbox"> 另外关于ssh其实自己看了挺多，但是这篇文章里面基本没怎么写，之后可能填上这个坑</li><li style="list-style: none"><input type="checkbox"> 是否可以github和gitlab使用同一对密钥，那样是不是会方便些，另外需要考虑安全问题</li><li style="list-style: none"><input type="checkbox"> 如果文章内容出现错误或者有更多想要了解的可以在下方留言，我会改进的</li></ul><p>(end)</p>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown</title>
      <link href="/2018/08/23/markdown/"/>
      <url>/2018/08/23/markdown/</url>
      <content type="html"><![CDATA[<h1 id="markdown语法整理"><a href="#markdown语法整理" class="headerlink" title="markdown语法整理"></a>markdown语法整理</h1><p>经常使用markdown来做笔记，这里把现在常用的语法先记录一下，万一老年人了记忆不好，也可以查一查<br><a id="more"></a></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># h1</span></span><br><span class="line">......</span><br><span class="line"><span class="section">###### h6</span></span><br><span class="line"></span><br><span class="line">分隔符</span><br><span class="line">最少三个---或<span class="emphasis">***</span></span><br></pre></td></tr></table></figure><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(部分markdown软件不支持)</span><br><span class="line">[TOC]</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; quote(每行最后添加两个空格即表示换行)  </span></span><br><span class="line">quote  </span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; quote(或者采取每行前面都添加引用标志)</span></span><br><span class="line"><span class="quote">&gt; quote</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; quote(多行嵌套引用)</span></span><br><span class="line">&gt;&gt; quote2</span><br><span class="line">&gt;&gt;&gt; quote3</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行内代码<span class="code">`code`</span>行内代码</span><br><span class="line"></span><br><span class="line">多行代码，[<span class="string">支持高亮语言</span>](<span class="link">https://blog.csdn.net/qq_32126633/article/details/78838494#language_key</span>)</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">个人博客</span>](<span class="link">https://kricsleo.github.io/ 'krics的个人博客'</span>)</span><br><span class="line">或者</span><br><span class="line">[<span class="symbol">blog</span>]: <span class="link">https://kricsleo.github.io/ 'krics的个人博客'</span></span><br><span class="line">[<span class="string">个人博客</span>][<span class="symbol">blog</span>]</span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">个人头像</span>](<span class="link">https://kricsleo.github.io/images/avatar.jpg 'krics的个人头像'</span>)</span><br><span class="line">或者</span><br><span class="line">[<span class="symbol">avatar</span>]: <span class="link">https://kricsleo.github.io/images/avatar.jpg 'krics的个人头像'</span></span><br><span class="line">![<span class="string">个人头像</span>][<span class="symbol">avatar</span>]</span><br><span class="line">图片带链接</span><br><span class="line">[<span class="string">![个人头像</span>](<span class="link">https://kricsleo.github.io/images/avatar.jpg 'krics的个人头像'</span>)](<span class="link">https://kricsleo.github.io/images/avatar.jpg</span>)</span><br></pre></td></tr></table></figure><h2 id="序表"><a href="#序表" class="headerlink" title="序表"></a>序表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">有序节点</span><br><span class="line"><span class="bullet">1. </span>节点1</span><br><span class="line"><span class="code">    1. 节点1.1</span></span><br><span class="line"><span class="bullet">2. </span>节点2</span><br><span class="line">无序节点</span><br><span class="line"><span class="bullet">- </span>节点$</span><br><span class="line"><span class="code">    - 节点$.^</span></span><br><span class="line"><span class="bullet">- </span>节点#</span><br><span class="line"><span class="code">    - 节点#.&amp;</span></span><br></pre></td></tr></table></figure><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>[ ] 未完成</span><br><span class="line"><span class="bullet">- </span>[x] 已完成</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 附上[在线生成表格工具](http://www.tablesgenerator.com/markdown_tables)</span></span><br><span class="line">|    a    |       b       |      c     |</span><br><span class="line">|:-------:|:------------- | ----------:|</span><br><span class="line">|   居中   |      左对齐    |    右对齐   |</span><br></pre></td></tr></table></figure><h2 id="语义性"><a href="#语义性" class="headerlink" title="语义性"></a>语义性</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span> or &lt;i&gt;斜体&lt;/i&gt;</span><br><span class="line"><span class="strong">**加粗**</span> or &lt;b&gt;加粗&lt;/b&gt;</span><br><span class="line"><span class="strong">***斜体加粗**</span>* or &lt;em&gt;强调&lt;/em&gt;</span><br><span class="line">~~删除线~~</span><br><span class="line">上标&lt;sup&gt;u&lt;/sup&gt;</span><br><span class="line">下标&lt;sub&gt;d&lt;/sub&gt;</span><br><span class="line">键盘按键&lt;kbd&gt;Ctrl&lt;/kbd&gt;</span><br></pre></td></tr></table></figure><h2 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line"><span class="code">    ...</span></span><br><span class="line">&lt;pre&gt;</span><br></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ul><li style="list-style: none"><input type="checkbox"> 目前还不常用，之后补齐  <h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Markdown[^1]</span><br><span class="line">在页面底端注解</span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">Markdown是一种纯文本标记语言</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">公式</span>](<span class="link">#1</span>)</span><br><span class="line">只能跳转到标题形式的锚点</span><br><span class="line"><span class="section">## [公式具体说明] &#123;#1&#125;</span></span><br></pre></td></tr></table></figure><h2 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Markdown</span><br><span class="line">:   Markdown是一种纯文本标记语言  (冒号后跟一个'Tab'或者四个空格)</span><br></pre></td></tr></table></figure><h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;xxx@163.com&gt;</span><br></pre></td></tr></table></figure><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>markdown的代码绘制流程图个人感觉比较复杂，个人使用的在线绘制工具<a href="https://www.processon.com/diagrams" target="_blank" rel="noopener">ProcessOn</a></p>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git-workflow</title>
      <link href="/2018/08/22/git-workflow/"/>
      <url>/2018/08/22/git-workflow/</url>
      <content type="html"><![CDATA[<h3 id="git的日常使用流程记录"><a href="#git的日常使用流程记录" class="headerlink" title="git的日常使用流程记录"></a>git的日常使用流程记录</h3><p>内容参考于阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="noopener">Git使用规范流程</a>，记录一下git的日常使用流程。<br><a id="more"></a><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015080501.png" alt="常用流程图"></p><h4 id="1-新建分支"><a href="#1-新建分支" class="headerlink" title="1. 新建分支"></a>1. 新建分支</h4><p>开发新功能时都应该新建一个分支，在分支上开发，当功能开发完成时再合并到主分支，并销毁新建的分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git checkout——检出，是我们的常用命令。最为常用的两种情形是创建分支和切换分支</span></span><br><span class="line"><span class="comment"># 先切换到主分支，获取最新代码</span></span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后新建分支，在这个分支上进行新功能开发</span></span><br><span class="line">git checkout -b myfeature</span><br></pre></td></tr></table></figure></p><h4 id="2-提交分支"><a href="#2-提交分支" class="headerlink" title="2. 提交分支"></a>2. 提交分支</h4><p>新功能开发完成以后提交代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认保存所有改动 --all</span></span><br><span class="line">git add</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看发生改动的地方</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交改动，也可以跟上 --verbose，然后就可以列出diff比较的结果，并且附上本次提交信息</span></span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></p><h4 id="3-同步代码"><a href="#3-同步代码" class="headerlink" title="3. 同步代码"></a>3. 同步代码</h4><p>开发过程中可以经常同步主分支的最新代码，保证一直在最新的基础上进行开发<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git fetch 表示取回最新代码</span></span><br><span class="line">git fetch origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将有更新的代码与当前分支合并</span></span><br><span class="line"><span class="comment"># 所取回的更新，在本地主机上要用"远程主机名/分支名"的形式读取。比如origin主机的master，就要用origin/master读取。</span></span><br><span class="line"><span class="comment"># 或者使用： git merge origin/master</span></span><br><span class="line">git rebase origin/master</span><br></pre></td></tr></table></figure></p><h4 id="4-合并多个commit"><a href="#4-合并多个commit" class="headerlink" title="4. 合并多个commit"></a>4. 合并多个commit</h4><p>新功能开发过程中一般会多次commit，但是在功能开发完成以后需要合并到主干时，一般把之前的commit合并成一个或几个关键的commit<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git rebase命令的i参数表示互动（interactive），具体如何合并请参见原文</span></span><br><span class="line">git rebase -i origin/master</span><br></pre></td></tr></table></figure></p><h4 id="5-推送到远程仓库"><a href="#5-推送到远程仓库" class="headerlink" title="5. 推送到远程仓库"></a>5. 推送到远程仓库</h4><p>多个commit经过合理的处理以后就可以把当前分支推送到远程仓库了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送</span></span><br><span class="line">git push --force master myfeature</span><br></pre></td></tr></table></figure></p><h4 id="6-发出Pull-Request"><a href="#6-发出Pull-Request" class="headerlink" title="6. 发出Pull Request"></a>6. 发出Pull Request</h4><p>提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
