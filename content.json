{"pages":[{"title":"archives","permalink":"https://kricsleo.github.io/archives/index.html","text":""},{"title":"categories","permalink":"https://kricsleo.github.io/categories/index.html","text":""}],"posts":[{"title":"Base64-md5","permalink":"https://kricsleo.github.io/2018/09/04/base64-md5/","text":"Base64编码与md5摘要算法探究及日常应用Base64编码和md5摘要算法我们经常听到,本文主要对着两者算法做一个简单的了解探究 Base64Base64是一种基于64个可打印字符来表示二进制数据的表示方法,常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。 Base64来源Base64来源于电子邮件的发展,早期的电子邮件是不支持二进制文件(例如图片)的,并且邮件中也不支持非英语字符,邮件也不能有附件,再后来的发展中工程师对电子邮件的技术规范就行了扩充,也就产生了常说的MIME,全称是全”Multipurpose Internet Mail Extensions”，中译为”多用途互联网邮件扩展”,它包括了多项技术规范.一封传统的电子邮件格式如下:1234567From: &quot;Tommy Lee&quot; &lt;lee@example.com&gt;To: &quot;Jack Zhang&quot; &lt;zhang@example.com&gt;Subject: TestDate: Wed, 17 May 2000 19:08:29 -0400Message-ID: &lt;NDBBIAKOPKHFGPLCODIGIEKBCHAA.lee@example.com&gt;Hello World. 它包含两个部分,第一部分是信封,里面包含发件人,收件人,邮件主题,邮件发送时间,邮件的唯一标识Message-ID,第二部分是正文,也就是邮件的内容,第一部分和第二部分之间用一个空行隔开, MIME对传统邮件的扩展体现在在信封里面新增了三行语句 MIME-Version: 1.0这行语句标志着该邮件使用了MIME规范,收信端将按照该规范进行解析邮件内容 Content-Type: text/plain; charset=”UTF-8”这行语句说明了改邮件的信息类型和编码方式 Content-Type表明信息类型，缺省值为” text/plain” 它包含了主要类型（primary type）和次要类型（subtype）两个部分，两者之间用”/“分割。主要类型有9种，分别是application、audio、example、image、message、model、multipart、text、video,每种主要类型下面又分为多种次要类型,常用的一些Content-Type类型如下: 12345678text/plain：纯文本，文件扩展名.txttext/html：HTML文本，文件扩展名.htm和.htmlimage/jpeg：jpeg格式的图片，文件扩展名.jpgimage/gif：GIF格式的图片，文件扩展名.gifaudio/x-wave：WAVE格式的音频，文件扩展名.wavaudio/mpeg：MP3格式的音频，文件扩展名.mp3video/mpeg：MPEG格式的视频，文件扩展名.mpgapplication/zip：PK-ZIP格式的压缩文件，文件扩展名.zip 如果信息的主要类型是”text”，那么还必须指明编码类型”charset”，缺省值是ASCII，其他可能值有”ISO-8859-1”、”UTF-8”、”GB2312”等等。 Content-transfer-encoding: Base64这里我们的主角就登场了,这行语句表明邮件编码转换的方式,因为现代邮件里面会有图片或者其它原始邮件不支持的内容,那么在发送的时候就需要对内容进行编码转换,将内容转换成邮件支持的ASCII字符,Content-transfer-encoding的值有5种—-“7bit”、”8bit”、”binary”、”quoted-printable”和”Base64”—-其中”7bit”是缺省值，即不用转化的ASCII字符。真正常用是”quoted-printable”和”Base64”两种. quoted-printable编码关于’quoted-printable’简单介绍一下,它主要用于ACSII文本中夹杂少量非ASCII码字符的情况，不适合于转换纯二进制文件.它规定将每一个8位的字节，转换为3个字符,规则如下: 所有可打印的ASCII码字符（十进制值从33到126）都保持原样不变，”=”（十进制值61）除外,其余的字符都要进行编码。 编码后第一个字符是”=”号，这是固定不变的; 编码后二个字符是二个十六进制数，分别代表了这个字节前四位和后四位的数值。例如ASCII码中的换页键的码值是12,那么先转成8位的二进制是00001100,再转成16进制是0C,然后再在前面加上一个’=’号,最后的编码结果是’=0C’. Base64编码首先选出一个字符集,分别是小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“加起来是64个,另外有一个垫字符’=’,然后将其它所有不在这个字符集里面的字符都转换到到这个字符集里面去,转换规则如下: 将每三个字节作为一组，一共是24个二进制位; 再将这24个二进制位分为四组，每个组有6个二进制位; 在每组前面加两个00，扩展成32个二进制位，即四个字节; 查询字符表,找到每个字节在表中对应的符号，这就是Base64的编码值;所以分析最终的结果的话,原始的三个字节经过转换以后会变成4个字节,因此Base64编码后的文本，会比原文本大出三分之一左右。 Base64编码示例编码译文单词’six’:s i x -&lt;转为对应的ASCII值&gt;&gt;&gt; 115 105 120 -&lt;转为对应的二进制&gt;&gt; 01110011 01101001 01111000 -&lt;二进制分为四组&gt;&gt; 011100 110110 100101 111000 -&lt;每组前面添加两个0&gt;&gt; 00011100 00110110 00100101 00111000 -&lt;每组转为对应的10进制&gt;&gt; 28 54 37 56 -&lt;查询Base64字符表转为对应字符&gt;&gt; c 2 l 4则’six’编码后的结果是’c2l4’,你可以用这个工具来验证你的转码结果是否正确. 如果字节数不足三，则处理如下: 二个字节的情况：将这二个字节的一共16个二进制位，按照上面的规则，转成三组，最后一组除了前面加两个0以外，后面也要加两个0。这样得到一个三位的Base64编码，再在末尾补上一个”=”号。比如，”Ma”这个字符串是两个字节，可以转化成三组00010011、00010110、00010000以后，对应Base64值分别为T、W、E，再补上一个”=”号，因此”Ma”的Base64编码就是TWE=。 一个字节的情况：将这一个字节的8个二进制位，按照上面的规则转成二组，最后一组除了前面加二个0以外，后面再加4个0。这样得到一个二位的Base64编码，再在末尾补上两个”=”号。比如，”M”这个字母是一个字节，可以转化为二组00010011、00010000，对应的Base64值分别为T、Q，再补上二个”=”号，因此”M”的Base64编码就是’TQ==’。 再举一个中文的例子，汉字”严”如何转化成Base64编码？ 这里需要注意，汉字本身可以有多种编码，比如gb2312、utf-8、gbk等等，每一种编码的Base64对应值都不一样。下面的例子以utf-8为例。 首先，”严”的utf-8编码为E4B8A5，写成二进制就是三字节的”11100100 10111000 10100101”。将这个24位的二进制字符串，按照第3节中的规则，转换成四组一共32位的二进制值”00111001 00001011 00100010 00100101”，相应的十进制数为57、11、34、37，它们对应的Base64值就为5、L、i、l。 所以，汉字”严”（utf-8编码）的Base64值就是5Lil。 Base64在js中的使用Base64的js实现如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/**** Base64 encode / decode** @author haitao.tu* @date 2010-04-26* @email tuhaitao@foxmail.com**/ function Base64() &#123; // private property _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; // public method for encoding this.encode = function (input) &#123; var output = \"\"; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = _utf8_encode(input); while (i &lt; input.length) &#123; chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 &gt;&gt; 2; enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4); enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6); enc4 = chr3 &amp; 63; if (isNaN(chr2)) &#123; enc3 = enc4 = 64; &#125; else if (isNaN(chr3)) &#123; enc4 = 64; &#125; output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4); &#125; return output; &#125; // public method for decoding this.decode = function (input) &#123; var output = \"\"; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\"); while (i &lt; input.length) &#123; enc1 = _keyStr.indexOf(input.charAt(i++)); enc2 = _keyStr.indexOf(input.charAt(i++)); enc3 = _keyStr.indexOf(input.charAt(i++)); enc4 = _keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4); chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2); chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) &#123; output = output + String.fromCharCode(chr2); &#125; if (enc4 != 64) &#123; output = output + String.fromCharCode(chr3); &#125; &#125; output = _utf8_decode(output); return output; &#125; // private method for UTF-8 encoding _utf8_encode = function (string) &#123; string = string.replace(/\\r\\n/g,\"\\n\"); var utftext = \"\"; for (var n = 0; n &lt; string.length; n++) &#123; var c = string.charCodeAt(n); if (c &lt; 128) &#123; utftext += String.fromCharCode(c); &#125; else if((c &gt; 127) &amp;&amp; (c &lt; 2048)) &#123; utftext += String.fromCharCode((c &gt;&gt; 6) | 192); utftext += String.fromCharCode((c &amp; 63) | 128); &#125; else &#123; utftext += String.fromCharCode((c &gt;&gt; 12) | 224); utftext += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128); utftext += String.fromCharCode((c &amp; 63) | 128); &#125; &#125; return utftext; &#125; // private method for UTF-8 decoding _utf8_decode = function (utftext) &#123; var string = \"\"; var i = 0; var c = c1 = c2 = 0; while ( i &lt; utftext.length ) &#123; c = utftext.charCodeAt(i); if (c &lt; 128) &#123; string += String.fromCharCode(c); i++; &#125; else if((c &gt; 191) &amp;&amp; (c &lt; 224)) &#123; c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); i += 2; &#125; else &#123; c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); i += 3; &#125; &#125; return string; &#125;&#125; md5摘要算法Base64我们说的差不多了,下面说说md5.md5全称’MD5消息摘要算法’（英语：MD5 Message-Digest Algorithm）,其最明显的作用就是对一段文本或者二进制文件进行运算之后得出一个128位的值,我们通常会把计算结果转换成32个16进制的数来表示. 对文本进行运算常用于密码的加密,比如对’password2018’这个字符串进行加密之后得到’f4654d5ac34aca487f0e3cb08d769f8a’,由于md5发生碰撞的概率极低,也就是不同的文本加密后得到同样的结果的可能性微乎其微,所以一般可以认为’f4654d5ac34aca487f0e3cb08d769f8a’这样的结果就唯一标识了’password2018’这个字符串.加密容易解密难,如果你想通过’f4654d5ac34aca487f0e3cb08d769f8a’这个结果去逆向运算得到’password2018’这个原始数据几乎是不可能的,付出的成本也相当于是天价,所以我们的网站登录经常会采取用md5加密用户密码的方式来验证和存储用户账户密码. 对二进制文件的运算常用于确保文件的完整性,比如在一些正规的网站上下载东西时常常附带会有一个.md5的文件,里面的内容类似于MD5 (tanajiya.tar.gz) = 38b8c2c1093dd0fec383a9d9ac940515这样,这里面记录的一串字符就是你要下载的这个文件的md5的运算结果,因为之前说过了一个东西的md5值是唯一的,一个md5结果也同样标识着唯一的一个东西,类似于每个人都有自己独特的指纹一样,一旦这个文件被人篡改过,那么再次对这个文件计算md5就会得到与之前不一样的md5值,所以我们常常会用这个md5结果来验证确保文件的完整性. md5的js实现如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256/* * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message * Digest Algorithm, as defined in RFC 1321. * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002. * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet * Distributed under the BSD License * See http://pajhome.org.uk/crypt/md5 for more info. *//* * Configurable variables. You may need to tweak these to be compatible with * the server-side, but the defaults work in most cases. */var hexcase = 0; /* hex output format. 0 - lowercase; 1 - uppercase */var b64pad = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance */var chrsz = 8; /* bits per input character. 8 - ASCII; 16 - Unicode *//* * These are the functions you'll usually want to call * They take string arguments and return either hex or base-64 encoded strings */function hex_md5(s)&#123; return binl2hex(core_md5(str2binl(s), s.length * chrsz));&#125;function b64_md5(s)&#123; return binl2b64(core_md5(str2binl(s), s.length * chrsz));&#125;function str_md5(s)&#123; return binl2str(core_md5(str2binl(s), s.length * chrsz));&#125;function hex_hmac_md5(key, data) &#123; return binl2hex(core_hmac_md5(key, data)); &#125;function b64_hmac_md5(key, data) &#123; return binl2b64(core_hmac_md5(key, data)); &#125;function str_hmac_md5(key, data) &#123; return binl2str(core_hmac_md5(key, data)); &#125;/* * Perform a simple self-test to see if the VM is working */function md5_vm_test()&#123; return hex_md5(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\";&#125;/* * Calculate the MD5 of an array of little-endian words, and a bit length */function core_md5(x, len)&#123; /* append padding */ x[len &gt;&gt; 5] |= 0x80 &lt;&lt; ((len) % 32); x[(((len + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = len; var a = 1732584193; var b = -271733879; var c = -1732584194; var d = 271733878; for(var i = 0; i &lt; x.length; i += 16) &#123; var olda = a; var oldb = b; var oldc = c; var oldd = d; a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936); d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586); c = md5_ff(c, d, a, b, x[i+ 2], 17, 606105819); b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330); a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897); d = md5_ff(d, a, b, c, x[i+ 5], 12, 1200080426); c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341); b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983); a = md5_ff(a, b, c, d, x[i+ 8], 7 , 1770035416); d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417); c = md5_ff(c, d, a, b, x[i+10], 17, -42063); b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162); a = md5_ff(a, b, c, d, x[i+12], 7 , 1804603682); d = md5_ff(d, a, b, c, x[i+13], 12, -40341101); c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290); b = md5_ff(b, c, d, a, x[i+15], 22, 1236535329); a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510); d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632); c = md5_gg(c, d, a, b, x[i+11], 14, 643717713); b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302); a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691); d = md5_gg(d, a, b, c, x[i+10], 9 , 38016083); c = md5_gg(c, d, a, b, x[i+15], 14, -660478335); b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848); a = md5_gg(a, b, c, d, x[i+ 9], 5 , 568446438); d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690); c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961); b = md5_gg(b, c, d, a, x[i+ 8], 20, 1163531501); a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467); d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784); c = md5_gg(c, d, a, b, x[i+ 7], 14, 1735328473); b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734); a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558); d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463); c = md5_hh(c, d, a, b, x[i+11], 16, 1839030562); b = md5_hh(b, c, d, a, x[i+14], 23, -35309556); a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060); d = md5_hh(d, a, b, c, x[i+ 4], 11, 1272893353); c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632); b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640); a = md5_hh(a, b, c, d, x[i+13], 4 , 681279174); d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222); c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979); b = md5_hh(b, c, d, a, x[i+ 6], 23, 76029189); a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487); d = md5_hh(d, a, b, c, x[i+12], 11, -421815835); c = md5_hh(c, d, a, b, x[i+15], 16, 530742520); b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651); a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844); d = md5_ii(d, a, b, c, x[i+ 7], 10, 1126891415); c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905); b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055); a = md5_ii(a, b, c, d, x[i+12], 6 , 1700485571); d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606); c = md5_ii(c, d, a, b, x[i+10], 15, -1051523); b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799); a = md5_ii(a, b, c, d, x[i+ 8], 6 , 1873313359); d = md5_ii(d, a, b, c, x[i+15], 10, -30611744); c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380); b = md5_ii(b, c, d, a, x[i+13], 21, 1309151649); a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070); d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379); c = md5_ii(c, d, a, b, x[i+ 2], 15, 718787259); b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551); a = safe_add(a, olda); b = safe_add(b, oldb); c = safe_add(c, oldc); d = safe_add(d, oldd); &#125; return Array(a, b, c, d);&#125;/* * These functions implement the four basic operations the algorithm uses. */function md5_cmn(q, a, b, x, s, t)&#123; return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);&#125;function md5_ff(a, b, c, d, x, s, t)&#123; return md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);&#125;function md5_gg(a, b, c, d, x, s, t)&#123; return md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);&#125;function md5_hh(a, b, c, d, x, s, t)&#123; return md5_cmn(b ^ c ^ d, a, b, x, s, t);&#125;function md5_ii(a, b, c, d, x, s, t)&#123; return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);&#125;/* * Calculate the HMAC-MD5, of a key and some data */function core_hmac_md5(key, data)&#123; var bkey = str2binl(key); if(bkey.length &gt; 16) bkey = core_md5(bkey, key.length * chrsz); var ipad = Array(16), opad = Array(16); for(var i = 0; i &lt; 16; i++) &#123; ipad[i] = bkey[i] ^ 0x36363636; opad[i] = bkey[i] ^ 0x5C5C5C5C; &#125; var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz); return core_md5(opad.concat(hash), 512 + 128);&#125;/* * Add integers, wrapping at 2^32. This uses 16-bit operations internally * to work around bugs in some JS interpreters. */function safe_add(x, y)&#123; var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF); var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16); return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#125;/* * Bitwise rotate a 32-bit number to the left. */function bit_rol(num, cnt)&#123; return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));&#125;/* * Convert a string to an array of little-endian words * If chrsz is ASCII, characters &gt;255 have their hi-byte silently ignored. */function str2binl(str)&#123; var bin = Array(); var mask = (1 &lt;&lt; chrsz) - 1; for(var i = 0; i &lt; str.length * chrsz; i += chrsz) bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (i%32); return bin;&#125;/* * Convert an array of little-endian words to a string */function binl2str(bin)&#123; var str = \"\"; var mask = (1 &lt;&lt; chrsz) - 1; for(var i = 0; i &lt; bin.length * 32; i += chrsz) str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (i % 32)) &amp; mask); return str;&#125;/* * Convert an array of little-endian words to a hex string. */function binl2hex(binarray)&#123; var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\"; var str = \"\"; for(var i = 0; i &lt; binarray.length * 4; i++) &#123; str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8+4)) &amp; 0xF) + hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8 )) &amp; 0xF); &#125; return str;&#125;/* * Convert an array of little-endian words to a base-64 string */function binl2b64(binarray)&#123; var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; var str = \"\"; for(var i = 0; i &lt; binarray.length * 4; i += 3) &#123; var triplet = (((binarray[i &gt;&gt; 2] &gt;&gt; 8 * ( i %4)) &amp; 0xFF) &lt;&lt; 16) | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * ((i+1)%4)) &amp; 0xFF) &lt;&lt; 8 ) | ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * ((i+2)%4)) &amp; 0xFF); for(var j = 0; j &lt; 4; j++) &#123; if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad; else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F); &#125; &#125; return str;&#125;"},{"title":"IIFE","permalink":"https://kricsleo.github.io/2018/09/02/IIFE/","text":"[增][转][译]JavaScript：立即执行函数表达式（IIFE） 原文: http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife译文: https://segmentfault.com/a/1190000003985390 by Murphywuwu 可能你并没有注意到，我是一个对于专业术语有一点坚持细节人。所有，当我听到流行的但是还存在误解的术语“自执行匿名函数”多次时，我最终决定将我的想法写进这篇文章里。 除了提供关于这种模式事实上是如何工作的一些全面的信息，更进一步的，实际上我建议我们应该知道我们应该叫它什么。而且，如果你想跳过这里，你可以直接跳到立即调用函数表达式进行阅读，但是我建议你读完整篇文章。 它是什么在 JavaScript 里，每个函数，当被调用时，都会创建一个新的执行上下文。因为在函数里定义的变量和函数是唯一在内部被访问的变量，而不是在外部被访问的变量，当调用函数时，函数提供的上下文提供了一个非常简单的方法创建私有变量。123456789101112131415161718function makeCounter() &#123; var i = 0; return function()&#123; console.log(++i); &#125;; &#125;//记住：`counter`和`counter2`都有他们自己的变量 `i`var counter = makeCounter();counter();//1counter();//2var counter2 = makeCounter();counter2();//1counter2();//2i;//ReferenceError: i is not defined(它只存在于makeCounter里) 在许多情况下，你可能并不需要makeWhatever这样的函数返回多次累加值，并且可以只调用一次得到一个单一的值，在其他一些情况里，你甚至不需要明确的知道返回值。 它的核心现在，无论你定义一个函数像这样function foo(){}或者var foo = function(){}，调用时，你都需要在后面加上一对圆括号，像这样foo()。12345678//向下面这样定义的函数可以通过在函数名后加一对括号进行调用，像这样`foo()`，//因为foo相对于函数表达式`function()&#123;/* code */&#125;`只是一个引用变量var foo = function()&#123;/* code */&#125;//那这可以说明函数表达式可以通过在其后加上一对括号自己调用自己吗？function()&#123; /* code */&#125;(); //SyntaxError: Unexpected token ( 正如你所看到的，这里捕获了一个错误。当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的function关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。 (个人理解: 见扩展’函数声明与函数表达式’) 问题1：这里我么可以思考一个问题，我们是不是也可以像这样直接调用函数var foo = function(){console.log(1)}()，答案是可以的。 问题2：同样的，我们还可以思考一个问题，像这样的函数声明在后面加上圆括号被直接调用，又会出现什么情况呢？请看下面的解答。 函数，圆括号，错误有趣的是，如果你为一个函数指定一个名字并在它后面放一对圆括号，同样的也会抛出错误，但这次是因为另外一个原因。 (个人理解: 见扩展’报错原因分析’) 当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号(用来控制运算优先的括号)。123456789101112//然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式function foo()&#123; /* code */ &#125;();//SyntaxError: Unexpected token//现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：function foo()&#123;/* code */&#125;(1)//它等同于如下，一个函数声明跟着一个完全没有关系的表达式:function foo()&#123;/* code */&#125;(1); 立即执行函数表达式（IIFE）幸运的是，修正语法错误很简单。最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了function关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。注意理解这里的圆括号和上面的圆括号遇到函数时的表现是不一样的，也就是说。 当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。 当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。 123456789101112131415161718192021222324252627//这两种模式都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量(function()&#123;/* code */&#125;());//Crockford recommends this one，括号内的表达式代表函数立即调用表达式(function()&#123;/* code */&#125;)();//But this one works just as well，括号内的表达式代表函数表达式// Because the point of the parens or coercing operators is to disambiguate// between function expressions and function declarations, they can be// omitted when the parser already expects an expression (but please see the// \"important note\" below).var i = function()&#123;return 10;&#125;();true &amp;&amp; function()&#123;/*code*/&#125;();0,function()&#123;&#125;();//如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节!function()&#123;/* code */&#125;();~function()&#123;/* code */&#125;();-function()&#123;/* code */&#125;();+function()&#123;/* code */&#125;();// Here's another variation, from @kuvos - I'm not sure of the performance// implications, if any, of using the `new` keyword, but it works.// http://twitter.com/kuvos/status/18209252090847232new function()&#123; /* code */ &#125;new function()&#123; /* code */ &#125;() // Only need parens if passing arguments 关于括号的重要笔记在一些情况下，当额外的带着歧义的括号围绕在函数表达式周围是没有必要的(因为这时候的括号已经将其作为一个表达式去表达)，但当括号用于调用函数表达式时，这仍然是一个好主意。 这样的括号指明函数表达式将会被立即调用，并且变量将会储存函数的结果，而不是函数本身。当这是一个非常长的函数表达式时，这可以节约比人阅读你代码的时间，不用滚到页面底部去看这个函数是否被调用。 作为规则，当你书写清楚明晰的代码时，有必要阻止 JavaScript 抛出错误的，同样也有必要阻止其他开发者对你抛出错误WTFError! 保存闭包的状态就像当函数通过他们的名字被调用时，参数会被传递，而当函数表达式被立即调用时，参数也会被传递。一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量(这种关系被叫做闭包)。(个人理解: 见扩展’关于闭包’)123456789101112131415161718192021222324252627282930313233343536373839// 它的运行原理可能并不像你想的那样，因为`i`的值从来没有被锁定。// 相反的，每个链接，当被点击时（循环已经被很好的执行完毕），因此会弹出所有元素的总数，// 因为这是 `i` 此时的真实值。var elems = document.getElementsByTagName('a');for(var i = 0;i &lt; elems.length; i++ ) &#123; elems[i].addEventListener('click',function(e)&#123; e.preventDefault(); alert('I am link #' + i) &#125;,false);&#125;// 而像下面这样改写，便可以了，因为在IIFE里，`i`值被锁定在了`lockedInIndex`里。// 在循环结束执行时，尽管`i`值的数值是所有元素的总和，但每一次函数表达式被调用时，// IIFE 里的 `lockedInIndex` 值都是`i`传给它的值,所以当链接被点击时，正确的值被弹出。var elems = document.getElementsByTagName('a');for(var i = 0;i &lt; elems.length;i++) &#123; (function(lockedInIndex)&#123; elems[i].addEventListener('click',function(e)&#123; e.preventDefault(); alert('I am link #' + lockedInIndex); &#125;,false) &#125;)(i);&#125;//你同样可以像下面这样使用IIFE，仅仅只用括号包括点击处理函数，并不包含整个`addEventListener`。//无论用哪种方式，这两个例子都可以用IIFE将值锁定，不过我发现前面一个例子更可读var elems = document.getElementsByTagName( 'a' );for ( var i = 0; i &lt; elems.length; i++ ) &#123; elems[ i ].addEventListener( 'click', (function( lockedInIndex )&#123; return function(e)&#123; e.preventDefault(); alert( 'I am link #' + lockedInIndex ); &#125;; &#125;)( i ),false); &#125; 记住，在这最后两个例子里，lockedInIndex可以没有任何问题的访问i,但是作为函数的参数使用一个不同的命名标识符可以使概念更加容易的被解释。 立即执行函数一个最显著的优势是就算它没有命名或者说是匿名，函数表达式也可以在没有使用标识符的情况下被立即调用，一个闭包也可以在没有当前变量污染的情况下被使用。 自执行匿名函数(“Self-executing anonymous function”)有什么问题呢？你看到它已经被提到好几次了，但是它仍然不是那么清楚的被解释，我提议将术语改成”Immediately-Invoked Function Expression”，或者，IIFE，如果你喜欢缩写的话。 什么是Immediately-Invoked Function Expression呢？它使一个被立即调用的函数表达式。就像引导你去调用的函数表达式。 我想Javascript社区的成员应该可以在他们的文章里或者陈述里接受术语，Immediately-Invoked Function Expression和 IIFE，因为我感觉这样更容易让这个概念被理解，并且术语”self-executing anonymous function”真的也不够精确。1234567891011121314151617181920212223242526272829//下面是个自执行函数，递归的调用自己本身function foo()&#123;foo();&#125;;//这是一个自执行匿名函数。因为它没有标识符，它必须是使用`arguments.callee`属性来调用它自己var foo = function()&#123;arguments.callee();&#125;;//这也许算是一个自执行匿名函数，但是仅仅当`foo`标识符作为它的引用时，如果你将它换成用`foo`来调用同样可行var foo = function()&#123;foo();&#125;;//有些人像这样叫'self-executing anonymous function'下面的函数,即使它不是自执行的，因为它并没有调用它自己。然后，它只是被立即调用了而已。(function()&#123; /*code*/ &#125;());//为函数表达式增加标识符(也就是说创造一个命名函数)对我们的调试会有很大帮助。一旦命名，函数将不再匿名。(function foo()&#123;/* code */&#125;());//IIFEs同样也可以自执行，尽管，也许他不是最有用的模式(function()&#123;arguments.callee();&#125;())(function foo()&#123;foo();&#125;())// One last thing to note: this will cause an error in BlackBerry 5, because// inside a named function expression, that name is undefined. Awesome, huh?(function foo()&#123; foo(); &#125;()); 希望上面的例子可以让你更加清楚的知道术语’self-executing’是有一些误导的，因为他并不是执行自己的函数，尽管函数已经被执行。同样的，匿名函数也没用必要特别指出，因为，Immediately Invoked Function Expression，既可以是命名函数也可以匿名函数。 最后：模块模式当我调用函数表达式时，如果我不至少一次的提醒我自己关于模块模式，我便很可能会忽略它。如果你并不熟悉JavaScript里的模块模式，它和我下面的例子很像，但是返回值用对象代替了函数。123456789101112131415161718192021var counter = (function()&#123; var i = 0; return &#123; get: function()&#123; return i; &#125;, set: function(val)&#123; i = val; &#125;, increment: function()&#123; return ++i; &#125; &#125; &#125;()); counter.get();//0 counter.set(3); counter.increment();//4 counter.increment();//5 conuter.i;//undefined (`i` is not a property of the returned object) i;//ReferenceError: i is not defined (it only exists inside the closure) 模块模式方法不仅相当的厉害而且简单。非常少的代码，你可以有效的利用与方法和属性相关的命名，在一个对象里，组织全部的模块代码即最小化了全局变量的污染也创造了使用变量。 扩展补充以下内容为我个人对原文及译文的扩展分析 1. 函数声明与函数表达式关于这两者的定义你可以参看MDN的说明文档:函数表达式和函数声明共同点: 两者都可以用function关键字来创建一个函数，用法也很类似，例如1234567// 函数声明function foo() &#123;console.log(1)&#125;//函数表达式,这样生成的是一个具名函数,叫`bar`var foo = function bar()&#123;console.log(1)&#125;//或者函数表达式也可以这样写,这样生成的是一个匿名函数,`foo`只是这个匿名函数的引用var foo = function ()&#123;console.log(1)&#125; 可以看出我们使用函数声明和函数表达式都可以用来创建一个实现某些功能的函数不同点: 从上面的例子我们可以看出函数声明只有一种写法,你必须给出函数的名字才行,如foo;而函数表达式则有两种写法,第一种是生成命名函数叫bar,后一种是生成匿名函数,注意函数表达式中的foo并不是函数名,它只是函数的一个引用而已,代表你可以使用foo来间接的调用真正的函数; 函数声明存在提升,而函数表达式不存在提升,这意味着如果你是用函数声明的方法创建一个函数,那么你可以在定义这个函数之前就去使用它;但是如果你是用函数表达式的方法来创建一个函数,那么你就必须要在函数被创建了以后才可以去使用这个函数,例如: 12345console.log(foo); // ƒ foo()&#123;console.log(1)&#125;function foo()&#123;console.log(1)&#125;consol.log(foo2); // Uncaught ReferenceError: consol is not definedvar foo2 = function bar()&#123;console.log(1)&#125; 你也可以参考这里给出的例子 额外的一点是我们经常使用函数表达式的方式来创建匿名函数,进而创建IIFE,这一点就跟本文主要内容联系起来了; 还有一个区别是有条件的创建函数,当函数声明出现在非功能模块（比如 if）中时,虽然官方是禁止这样做的,但是实际上浏览器都支持这种做法,但是各个浏览器的处理方式有不同,这一点兼容性问题实在很头疼,所以我们不应该在生成环境代码中使用这种方式，应该使用函数表达式来代替。 2. 报错原因function (){console.log(1)}()报错出现在第一个括号，因为声明一个函数需要名字，这里声明没有给出名字，所以直接报错，走不到第二个括号，但是function foo(){console.log(1)}()报错出现在第二括号，因为这里声明函数是正确的，当处理到第二个括号时，发现第二个括号内没有任何东西，这是不允许的,所以报错,理由参见文章中注释处 3. 关于闭包在ES6之前只存在两种作用域,一是全局作用域,此作用域当浏览器打开一个页面时就会被创建,你可以通过window对象来访问这个全局作用域中的成员,另外一个就是函数作用域,当js引擎执行一个函数时就会为这个函数创建一个属于该函数的作用域,(在ES6中引入了新的作用域:块级作用域,使用let标识符来生成一个只在块级范围内可访问的变量,关于let的特性你可以参见这里ECMAScript 6 入门).12345678910function foo() &#123; let i = 1; return function log() &#123; console.log(++i) &#125;&#125;let logger = foo();logger(); // 2logger(); // 3 理解闭包必须先理解js的函数作用域,之前说过了每次执行一个函数时就会为这个函数创建一个属于它自己的函数作用域,一旦这个函数运行完毕,那么它的作用域就会被销毁,其中的保存的信息一般也会被销毁,但是,这是一般的情况,那么什么是不一般的情况呢? 这时我们就要利用浏览器销毁变量及作用域的特性来搞事了,浏览器的垃圾回收机制(有两种垃圾回收机制,这里以最常用的标记清除法为例)会定时的检查变量是否被引用,也就是是否有指针指向该数据的存储区域,如果有,那么说明有人可能要使用该数据,则不能销毁该区域,如果没有,说明没人再能够访问这个数据了,那么就可以放心的去销毁该区域来回收内存. 而闭包正好利用了这个特性,例如上面的例子中,函数foo每次执行时会返回一个新函数叫做log,log函数内部需要访问它外面的变量i才能正常工作,返回的新函数被赋给了变量logger,那么这里的指向关系是logger -&gt; log -&gt; i,那么在之后的js执行过程中,由于外部的变量logger通过一系列的指向,最终时能够访问的最开始的那个变量i的,那么按照垃圾回收机制,函数foo的作用域将一直不能够被销毁,因为它内部的变量i还有人用着呢!并且我们发现类似i这样的变量能够保存很重要的一些信息,比如函数被调用的次数等等,我们就可以用来计数或者其它你能发挥创造力的用途. 关于缺点的话也是很明显的,因为闭包内的变量一直将被保留着,如果我们创建大量这样的变量或者大量的闭包,那么浏览器可用内存就会越来越小造成卡顿,应该考虑情况适当使用."},{"title":"ssh-git","permalink":"https://kricsleo.github.io/2018/08/30/ssh-git/","text":"github的https和ssh连接方式探究在本机连接github仓库提交代码时有两种可选方法，一种是使用github账号的用户名和密码的认证方式通过https连接，另一种是使用ssh-key的认证方式通过ssh连接，本文主要研究这两种方式的工作过程以及可能会扩展探究一些相关的知识。 两种方式 首先在本机下载安装Git，一路点next默认安装即可; clone一个github上的项目到本地 选择使用https以我的博客所使用hexo的materialFlow主题项目为例(这个项目我没有管理权限)，一行命令git clone https://github.com/stkevintan/hexo-theme-material-flow.git即可clone到本地 选择使用ssh此时你就无法直接使用git clone git@github.com:stkevintan/hexo-theme-material-flow.git命令来clone上面那个项目到本地，会产生如下错误提示： fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists. 因为ssh的方式是需要进行认证的，你必须是这个项目的所有者或者管理者，才能有权限去使用ssh方式clone该项目，而上面的https方式则允许任何一个人在不需要验证的情况下去clone项目. 那么接下来看一下对于一个我们有管理权限的仓库应该如何使用ssh方式去clone到本地 ssh方式是基于不对称性加密来通信的，你需要使用不对称性算法来生成一对密钥，然后将私钥放置在你本机上，将公钥放置在github服务器上，之后在进行ssh通信时将会使用这对秘钥来完成认证登陆及加密和解密信息，在window上和mac上我们都可以使用ssh-keygen这个命令行工具来生成我们需要的密钥，这是我们想要使用ssh通信的第一步 生成一对密钥打开你的命令行（window下使用cmd.exe，mac下使用terminal.app），然后按照\b如下命令来生成密钥123456ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"# 参数说明： # ssh-keygen: 表示将要使用ssh-keygen这个工具来生成密钥# -t: 指定要生成的密钥类型，有rsa1(SSH1),dsa(SSH2),ecdsa(SSH2),rsa(SSH2)等类型，较为常用的是rsa类型，此处指定为rsa类型# -b: 指定要生成的密钥长度 (单位:bit)，对于RSA类型的密钥，最小长度768bits,默认长度为2048bits。DSA密钥必须是1024bits，此处指定为4096bits# -C: 制定要生成的密钥的注释，这个可以自己随意填写，就相当于给这个密钥留个名，好分辨，比如此处可以用注册github的邮箱号 之后会出现如下提示内容： Generating public/private rsa key pair.Enter file in which to save the key (C:/Users/xxxxx/.ssh/id_rsa): 意思是让你输入这个密钥文件的文件名，一般情况保存默认就可以，直接回车确认。（如果你有多个git的账号需要配置，比如你自己在github上有账号需要提交代码，同时自己在公司也有git的账号，有时候需要提交代码到公司的仓库里，那么这时候你就需要额外的配置来保证提交的时候不会冲突，详见下面）然后会出现下一个提示内容： Enter passphrase (empty for no passphrase): 意思是要不要对私钥设置口令（passphrase），如果担心私钥的安全，你可以设置一个，这里一般不设置，直接回车确认即可，最后会出现类似如下的提示内容： +—[RSA 4096]—-+| o+o .. .o || oo… o … = ||+ +.+ o.o.o.+ o ||oB =.o..E.o* o ||o = o.o Soo+= || . o .+++ . || o.o || .. || .. |+—-[SHA256]—–+ 那\b么恭喜你，你已经生成了一对密钥文件，\b他们存储在C:/Users/xxxxx/.ssh/（windows）或者~/.ssh（mac）目录下，默认的文件是id_rsa（私钥文件名）和id_rsa.pub（公钥文件名），你可以去打开查看一下里面的内容。 部署密钥之前说过了你需要将私钥保存在本机，公钥放置在服务器上，这样之后才能用这对密钥建立ssh通信，那么在github上我们按照如下做法来部署密钥 用文本编辑器打开刚才生成的公钥文件id_rsa.pub，拷贝里面的全部内容； 打开浏览器登陆你的github账户，依次打开你头像上的Settings &gt; SSH and GPG keys &gt; New SSH key; 填写相关信息，title可以类似之前生成密钥时填写的注释信息那样填写你的邮箱名，然后key里面填上刚才拷贝的公钥内容，点击Add SSH key之后输入一次你的github账户密码进行确认，然后你的公钥就被保存部署到github服务器上了； 测试连接，使用如下命令来测试是否能够通过ssh连接到github1234ssh git@github.com# 参数说明：# ssh: 使用ssh进行连接# git@github.com: ssh连接时需要指定登陆用户名和远程主机名，这里的git就是github的远程服务器的用户名，github.com就是远程服务器的主机名，用'@'符号连接起来 当你是第一次连接的时候会提示你如下信息： The authenticity of host ‘github.com (52.74.223.119)’ can’t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 这是因为你是第一次连接该主机，该主机不在你本机的known hosts（已知主机）名单里面，所以询问你是否要继续连接这个陌生的主机，输入yes然后回车确认即可，之后再次连接的时候就不会有这个提示信息了。如果你配置步骤没问题的话应该可以看到下面的连接上之后的欢迎信息(xxxxx代表你的github的账户名)： Warning: Permanently added ‘github.com,52.74.223.119’ (RSA) to the list of known hosts.PTY allocation request failed on channel 0Hi xxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 使用ssh方式clone项目之前说过了ssh方式只能操作我们有管理权限的项目，所以这里我拿自己做的一个微信小程序的虚拟车牌键盘的项目为例1git clone git@github.com:kricsleo/vehicleKeyboard.git 这个时候我们就能顺利clone该项目到本机了，因为在我们上面这条命令请求数据的过程中，我们本机和github的服务器会使用我们之前生成的那对密钥来进行相互认证，从而使我们不需要手动输入github的账户名和密码信息来完成认证登陆，同时我们以后修改了项目代码在进行提交的时候也可直接进行提交等相关操作，无需再考虑登陆及连接的问题，git的使用可以参考我之前的一篇小总结 配置个人信息使用git提交更改的时候会为本次提交附上提交人的\b一些信息，比如提交人的用户名及邮箱信息，我们可以使用git提供的配置功能来提前配置好这些信息，使用如下：123456789101112git config --global user.name \"John Doe\"git config --global user.email \"johndoe@example.com\"# 参数说明：# git config: 表示使用git的配置工具# --global: 表示配置全局的信息，你也可以在某个项目下面单独配置这个信息，只需要去掉'--global'即可，# &lt;- 这样不同的项目就会有不同提交人信息# user.name / user.email: 后面跟上你自己的用户名和邮箱信息即可# 之后我们可以使用如下命令来查看我们配置的信息#git config user.name#git config user.email 多git账户配置如果你需要生成多对密钥，比如你需要和两个不一样的服务器A和B进行ssh通信，那么这个时候你就可以生成两对密钥，一对用来和A通信，另一对用来和B通信，最常见的情况就是我们自己在github上面会有自己的github账户，自己平时会开发一些自己的项目，然后提交到github上面，在公司里面公司一般会有自己的gitlab服务器，然后给员工开通一个gitlab的账号，有关公司内部的项目就会让员工用gitlab的账户进行开发，然后提交代码到公司的gitlab上面，那么这时候我们可以按照如下的方法来配置一下，保证自己随时提交代码的时候都是能够提交到正确的地方，而不会混乱。 再生成一对密钥在上面的操作中你已经生成了一对密钥，名字叫做id_rsa和id_rsa.pub（如果你没有改名的话），这个密钥我们已经拿来和github进行通信了，此时我们要想和公司的gitlab通信就需要再生成一对密钥，为了避免这次生成的密钥覆盖我们之前的那对密钥，可以执行如下命令：12345ssh-keygen -t rsa -b 4096 -C \"youremail@yourcompany.com” -f ~/.ssh/id_rsa_xx# 参数说明# 这次我们生成密钥的命令只比之前多了一个参数： -f# -f: 表示将这次什么的密钥文件保存为id_rsa_xx，同样放在了之前的那个文件夹，这个文件名你可以自己随意指定，不过最好容易区分一些 后面你的操作就和之前生成密钥一样了，生成好密钥之后再看下一步 部署新生成的密钥和之前部署github密钥的步骤类似，你登录你公司的gitlab，找到添加ssh-key的地方，然后拷贝新生成的公钥id_rsa_xx.pub文件内容到gitlab里面去并且保存，这样你公司的gitlab服务器上的公钥信息就配置好了 新建配置文件因为现在我们本机上有了两对密钥，提交代码到github时需要使用之前生成的那一对，提交代码到公司的gitlab上需要我们现在刚刚生成的这一对，那么我们就要写一个简单的配置文件来告诉git该如何再提交代码时选择正确的密钥，实际上就是编写SSH的用户配置文件config。在目录~/.ssh(mac环境)或者C:/Users/xxxxx/.ssh/下新建文件config，注意没有后缀名的，然后在里面填写上如下内容： 12345678910111213141516171819#githubHost github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa#yourcompanyHost git.XXXXX.com HostName git.XXXXX.com User git IdentityFile ~/.ssh/id_rsa_XX# 参数说明，此段内容不用拷贝，是为了加以说明# Host: 别名，为了方便记忆和区分，可以任意填写# HostName： 主机名 服务器的主机名，也可以是服务器的ip地址，需要准确填写# User： 用户名，ssh登录服务器时的用户名，一般是git# IdentityFile： 密钥文件的路径，填写上你要用来和这个服务器通信使用的密钥文件的路径# PreferredAuthentications： 强制使用Public Key验证，我这里没有要求这个，你也可以加上 测试连接使用如下命令来分别测试能否连接到对应的服务器 12345# 测试连接公司ssh git@git.XXXXX.com# 测试连接githubssh git@github.com 如果能分别看到对应的欢迎信息，那么恭喜你配置正确了。 配置个人信息这次我们因为有不同的项目，提交时需要附加上的个人信息也不一样，你提交github时会用你自己的github账户名和邮箱信息，但是提交公司的gitlab时会使用公司给你的账户名和公司个人邮箱，那么我们就需要到具体的项目下面执行如下的命令：12345git config user.name \"yourname\"git config user.email \"youremail@XXXXX.com\"# 参数说明# 与之前我们执行的那条配置个人信息命令相比，只是少了个'--global'参数，因为我们现在不是在全局配置，而是在个别项目中单独配置 到这里为止，你的多git账户依旧配置完毕了，后面就可以和平常一样使用git来提交代码了，ssh会为你选择正确的密钥来和服务器认证和通信。 备注这篇文章里面给我自己埋了些坑要填 完全使用https协议该如何用git来开发项目 另外关于ssh其实自己看了挺多，但是这篇文章里面基本没怎么写，之后可能填上这个坑 是否可以github和gitlab使用同一对密钥，那样是不是会方便些，另外需要考虑安全问题 如果文章内容出现错误或者有更多想要了解的可以在下方留言，我会改进的 (end)"},{"title":"markdown","permalink":"https://kricsleo.github.io/2018/08/23/markdown/","text":"markdown语法整理经常使用markdown来做笔记，这里把现在常用的语法先记录一下，万一老年人了记忆不好，也可以查一查 标题123456# h1......###### h6分隔符最少三个---或*** 目录12(部分markdown软件不支持)[TOC] 引用123456789&gt; quote(\b每行最后添加两个空格即表示换行) quote &gt; quote(或者采取每行前面都添加引用标志)&gt; quote&gt; quote(多行嵌套引用)&gt;&gt; quote2&gt;&gt;&gt; quote3 代码123行内代码`code`行内代码多行代码，[支持\b高亮语言](https://blog.csdn.net/qq_32126633/article/details/78838494#language_key) 链接1234[个人博客](https://kricsleo.github.io/ 'krics的个人博客')或者[blog]: https://kricsleo.github.io/ 'krics的个人博客'[个人博客][blog] 图片123456![个人头像](https://kricsleo.github.io/images/avatar.jpg 'krics的个人头像')或者[avatar]: https://kricsleo.github.io/images/avatar.jpg 'krics的个人头像'![个人头像][avatar]图片带链接[![个人头像](https://kricsleo.github.io/images/avatar.jpg 'krics的个人头像')](https://kricsleo.github.io/images/avatar.jpg) 序表123456789有序节点1. 节点1 1. 节点1.12. 节点2无序节点- 节点$ - 节点$.^- 节点# - 节点#.&amp; 任务12- [ ] 未完成- [x] 已完成 表格1234# 附上[在线生成表格工具](http://www.tablesgenerator.com/markdown_tables)| a | b | c ||:-------:|:------------- | ----------:|| 居中 | 左对齐 | 右对齐 | 语义性1234567*斜体* or &lt;i&gt;斜体&lt;/i&gt;**加粗** or &lt;b&gt;加粗&lt;/b&gt;***斜体加粗*** or &lt;em&gt;强调&lt;/em&gt;~~删除线~~上标&lt;sup&gt;u&lt;/sup&gt;下标&lt;sub&gt;d&lt;/sub&gt;键盘按键&lt;kbd&gt;Ctrl&lt;/kbd&gt; 格式化显示123&lt;pre&gt; ...&lt;pre&gt; 公式 目前还不常用，之后补齐 脚注123Markdown[^1]在页面底端注解[^1]: Markdown是一种纯文本标记语言 定义型列表12Markdown: Markdown是一种纯文本标记语言 (冒号后跟一个'Tab'或者四个空格) 邮箱1&lt;xxx@163.com&gt; 流程图markdown的代码绘制流程图个人感觉比较复杂，个人使用的在线绘制工具ProcessOn"},{"title":"git-workflow","permalink":"https://kricsleo.github.io/2018/08/22/git-workflow/","text":"git的日常使用流程记录内容参考于阮一峰老师的Git使用规范流程，记录一下git的日常使用流程。 1. 新建分支开发新功能时都应该新建一个分支，在分支上开发，当功能开发完成时再合并到主分支，并销毁新建的分支。1234567# git checkout——检出，是我们的常用命令。最为常用的两种情形是创建分支和切换分支# 先切换到主分支，获取最新代码git checkout mastergit pull# 然后新建分支，在这个分支上进行新功能开发git checkout -b myfeature 2. 提交分支新功能开发完成以后提交代码12345678# 默认保存所有改动 --allgit add# 查看发生改动的地方git status# 提交改动，也可以跟上 --verbose，然后就可以列出diff比较的结果，并且附上本次提交信息git commit 3. 同步代码开发过程中可以经常同步主分支的最新代码，保证一直在最新的基础上进行开发1234567# git fetch 表示取回最新代码git fetch origin# 将有更新的代码与当前分支合并# 所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如origin主机的master，就要用origin/master读取。# 或者使用： git merge origin/mastergit rebase origin/master 4. 合并多个commit新功能开发过程中一般会多次commit，但是在功能开发完成以后需要合并到主干时，一般把之前的commit合并成一个或几个关键的commit12# git rebase命令的i参数表示互动（interactive），具体如何合并请参见原文git rebase -i origin/master 5. 推送到远程仓库多个commit经过合理的处理以后就可以把当前分支推送到远程仓库了12# git push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送git push --force master myfeature 6. 发出Pull Request提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。 参考文档: http://www.ruanyifeng.com/blog/2014/06/git_remote.html (end)"}]}