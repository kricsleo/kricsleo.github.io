{"pages":[{"title":"categories","permalink":"https://kricsleo.github.io/categories/index.html","text":""},{"title":"archives","permalink":"https://kricsleo.github.io/archives/index.html","text":""}],"posts":[{"title":"IIFE","permalink":"https://kricsleo.github.io/2018/09/02/IIFE/","text":"[增][转][译]JavaScript：立即执行函数表达式（IIFE） 原文: http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife译文: https://segmentfault.com/a/1190000003985390 by Murphywuwu 可能你并没有注意到，我是一个对于专业术语有一点坚持细节人。所有，当我听到流行的但是还存在误解的术语“自执行匿名函数”多次时，我最终决定将我的想法写进这篇文章里。 除了提供关于这种模式事实上是如何工作的一些全面的信息，更进一步的，实际上我建议我们应该知道我们应该叫它什么。而且，如果你想跳过这里，你可以直接跳到立即调用函数表达式进行阅读，但是我建议你读完整篇文章。 它是什么在 JavaScript 里，每个函数，当被调用时，都会创建一个新的执行上下文。因为在函数里定义的变量和函数是唯一在内部被访问的变量，而不是在外部被访问的变量，当调用函数时，函数提供的上下文提供了一个非常简单的方法创建私有变量。123456789101112131415161718function makeCounter() &#123; var i = 0; return function()&#123; console.log(++i); &#125;; &#125;//记住：`counter`和`counter2`都有他们自己的变量 `i`var counter = makeCounter();counter();//1counter();//2var counter2 = makeCounter();counter2();//1counter2();//2i;//ReferenceError: i is not defined(它只存在于makeCounter里) 在许多情况下，你可能并不需要makeWhatever这样的函数返回多次累加值，并且可以只调用一次得到一个单一的值，在其他一些情况里，你甚至不需要明确的知道返回值。 它的核心现在，无论你定义一个函数像这样function foo(){}或者var foo = function(){}，调用时，你都需要在后面加上一对圆括号，像这样foo()。12345678//向下面这样定义的函数可以通过在函数名后加一对括号进行调用，像这样`foo()`，//因为foo相对于函数表达式`function()&#123;/* code */&#125;`只是一个引用变量var foo = function()&#123;/* code */&#125;//那这可以说明函数表达式可以通过在其后加上一对括号自己调用自己吗？function()&#123; /* code */&#125;(); //SyntaxError: Unexpected token ( 正如你所看到的，这里捕获了一个错误。当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的function关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。 (个人理解: 见扩展’函数声明与函数表达式’) 问题1：这里我么可以思考一个问题，我们是不是也可以像这样直接调用函数var foo = function(){console.log(1)}()，答案是可以的。 问题2：同样的，我们还可以思考一个问题，像这样的函数声明在后面加上圆括号被直接调用，又会出现什么情况呢？请看下面的解答。 函数，圆括号，错误有趣的是，如果你为一个函数指定一个名字并在它后面放一对圆括号，同样的也会抛出错误，但这次是因为另外一个原因。 (个人理解: 见扩展’报错原因分析’) 当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号(用来控制运算优先的括号)。123456789101112//然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式function foo()&#123; /* code */ &#125;();//SyntaxError: Unexpected token//现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：function foo()&#123;/* code */&#125;(1)//它等同于如下，一个函数声明跟着一个完全没有关系的表达式:function foo()&#123;/* code */&#125;(1); 立即执行函数表达式（IIFE）幸运的是，修正语法错误很简单。最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了function关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。注意理解这里的圆括号和上面的圆括号遇到函数时的表现是不一样的，也就是说。 当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。 当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。 123456789101112131415161718192021222324252627//这两种模式都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量(function()&#123;/* code */&#125;());//Crockford recommends this one，括号内的表达式代表函数立即调用表达式(function()&#123;/* code */&#125;)();//But this one works just as well，括号内的表达式代表函数表达式// Because the point of the parens or coercing operators is to disambiguate// between function expressions and function declarations, they can be// omitted when the parser already expects an expression (but please see the// \"important note\" below).var i = function()&#123;return 10;&#125;();true &amp;&amp; function()&#123;/*code*/&#125;();0,function()&#123;&#125;();//如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节!function()&#123;/* code */&#125;();~function()&#123;/* code */&#125;();-function()&#123;/* code */&#125;();+function()&#123;/* code */&#125;();// Here's another variation, from @kuvos - I'm not sure of the performance// implications, if any, of using the `new` keyword, but it works.// http://twitter.com/kuvos/status/18209252090847232new function()&#123; /* code */ &#125;new function()&#123; /* code */ &#125;() // Only need parens if passing arguments 关于括号的重要笔记在一些情况下，当额外的带着歧义的括号围绕在函数表达式周围是没有必要的(因为这时候的括号已经将其作为一个表达式去表达)，但当括号用于调用函数表达式时，这仍然是一个好主意。 这样的括号指明函数表达式将会被立即调用，并且变量将会储存函数的结果，而不是函数本身。当这是一个非常长的函数表达式时，这可以节约比人阅读你代码的时间，不用滚到页面底部去看这个函数是否被调用。 作为规则，当你书写清楚明晰的代码时，有必要阻止 JavaScript 抛出错误的，同样也有必要阻止其他开发者对你抛出错误WTFError! 保存闭包的状态就像当函数通过他们的名字被调用时，参数会被传递，而当函数表达式被立即调用时，参数也会被传递。一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量(这种关系被叫做闭包)。(个人理解: 见扩展’关于闭包’)123456789101112131415161718192021222324252627282930313233343536373839// 它的运行原理可能并不像你想的那样，因为`i`的值从来没有被锁定。// 相反的，每个链接，当被点击时（循环已经被很好的执行完毕），因此会弹出所有元素的总数，// 因为这是 `i` 此时的真实值。var elems = document.getElementsByTagName('a');for(var i = 0;i &lt; elems.length; i++ ) &#123; elems[i].addEventListener('click',function(e)&#123; e.preventDefault(); alert('I am link #' + i) &#125;,false);&#125;// 而像下面这样改写，便可以了，因为在IIFE里，`i`值被锁定在了`lockedInIndex`里。// 在循环结束执行时，尽管`i`值的数值是所有元素的总和，但每一次函数表达式被调用时，// IIFE 里的 `lockedInIndex` 值都是`i`传给它的值,所以当链接被点击时，正确的值被弹出。var elems = document.getElementsByTagName('a');for(var i = 0;i &lt; elems.length;i++) &#123; (function(lockedInIndex)&#123; elems[i].addEventListener('click',function(e)&#123; e.preventDefault(); alert('I am link #' + lockedInIndex); &#125;,false) &#125;)(i);&#125;//你同样可以像下面这样使用IIFE，仅仅只用括号包括点击处理函数，并不包含整个`addEventListener`。//无论用哪种方式，这两个例子都可以用IIFE将值锁定，不过我发现前面一个例子更可读var elems = document.getElementsByTagName( 'a' );for ( var i = 0; i &lt; elems.length; i++ ) &#123; elems[ i ].addEventListener( 'click', (function( lockedInIndex )&#123; return function(e)&#123; e.preventDefault(); alert( 'I am link #' + lockedInIndex ); &#125;; &#125;)( i ),false); &#125; 记住，在这最后两个例子里，lockedInIndex可以没有任何问题的访问i,但是作为函数的参数使用一个不同的命名标识符可以使概念更加容易的被解释。 立即执行函数一个最显著的优势是就算它没有命名或者说是匿名，函数表达式也可以在没有使用标识符的情况下被立即调用，一个闭包也可以在没有当前变量污染的情况下被使用。 自执行匿名函数(“Self-executing anonymous function”)有什么问题呢？你看到它已经被提到好几次了，但是它仍然不是那么清楚的被解释，我提议将术语改成”Immediately-Invoked Function Expression”，或者，IIFE，如果你喜欢缩写的话。 什么是Immediately-Invoked Function Expression呢？它使一个被立即调用的函数表达式。就像引导你去调用的函数表达式。 我想Javascript社区的成员应该可以在他们的文章里或者陈述里接受术语，Immediately-Invoked Function Expression和 IIFE，因为我感觉这样更容易让这个概念被理解，并且术语”self-executing anonymous function”真的也不够精确。1234567891011121314151617181920212223242526272829//下面是个自执行函数，递归的调用自己本身function foo()&#123;foo();&#125;;//这是一个自执行匿名函数。因为它没有标识符，它必须是使用`arguments.callee`属性来调用它自己var foo = function()&#123;arguments.callee();&#125;;//这也许算是一个自执行匿名函数，但是仅仅当`foo`标识符作为它的引用时，如果你将它换成用`foo`来调用同样可行var foo = function()&#123;foo();&#125;;//有些人像这样叫'self-executing anonymous function'下面的函数,即使它不是自执行的，因为它并没有调用它自己。然后，它只是被立即调用了而已。(function()&#123; /*code*/ &#125;());//为函数表达式增加标识符(也就是说创造一个命名函数)对我们的调试会有很大帮助。一旦命名，函数将不再匿名。(function foo()&#123;/* code */&#125;());//IIFEs同样也可以自执行，尽管，也许他不是最有用的模式(function()&#123;arguments.callee();&#125;())(function foo()&#123;foo();&#125;())// One last thing to note: this will cause an error in BlackBerry 5, because// inside a named function expression, that name is undefined. Awesome, huh?(function foo()&#123; foo(); &#125;()); 希望上面的例子可以让你更加清楚的知道术语’self-executing’是有一些误导的，因为他并不是执行自己的函数，尽管函数已经被执行。同样的，匿名函数也没用必要特别指出，因为，Immediately Invoked Function Expression，既可以是命名函数也可以匿名函数。 最后：模块模式当我调用函数表达式时，如果我不至少一次的提醒我自己关于模块模式，我便很可能会忽略它。如果你并不熟悉JavaScript里的模块模式，它和我下面的例子很像，但是返回值用对象代替了函数。123456789101112131415161718192021var counter = (function()&#123; var i = 0; return &#123; get: function()&#123; return i; &#125;, set: function(val)&#123; i = val; &#125;, increment: function()&#123; return ++i; &#125; &#125; &#125;()); counter.get();//0 counter.set(3); counter.increment();//4 counter.increment();//5 conuter.i;//undefined (`i` is not a property of the returned object) i;//ReferenceError: i is not defined (it only exists inside the closure) 模块模式方法不仅相当的厉害而且简单。非常少的代码，你可以有效的利用与方法和属性相关的命名，在一个对象里，组织全部的模块代码即最小化了全局变量的污染也创造了使用变量。 扩展补充以下内容为我个人对原文及译文的扩展分析 1. 函数声明与函数表达式关于这两者的定义你可以参看MDN的说明文档:函数表达式和函数声明共同点: 两者都可以用function关键字来创建一个函数，用法也很类似，例如1234567// 函数声明function foo() &#123;console.log(1)&#125;//函数表达式,这样生成的是一个具名函数,叫`bar`var foo = function bar()&#123;console.log(1)&#125;//或者函数表达式也可以这样写,这样生成的是一个匿名函数,`foo`只是这个匿名函数的引用var foo = function ()&#123;console.log(1)&#125; 可以看出我们使用函数声明和函数表达式都可以用来创建一个实现某些功能的函数不同点: 从上面的例子我们可以看出函数声明只有一种写法,你必须给出函数的名字才行,如foo;而函数表达式则有两种写法,第一种是生成命名函数叫bar,后一种是生成匿名函数,注意函数表达式中的foo并不是函数名,它只是函数的一个引用而已,代表你可以使用foo来间接的调用真正的函数; 函数声明存在提升,而函数表达式不存在提升,这意味着如果你是用函数声明的方法创建一个函数,那么你可以在定义这个函数之前就去使用它;但是如果你是用函数表达式的方法来创建一个函数,那么你就必须要在函数被创建了以后才可以去使用这个函数,例如: 12345console.log(foo); // ƒ foo()&#123;console.log(1)&#125;function foo()&#123;console.log(1)&#125;consol.log(foo2); // Uncaught ReferenceError: consol is not definedvar foo2 = function bar()&#123;console.log(1)&#125; 你也可以参考这里给出的例子 额外的一点是我们经常使用函数表达式的方式来创建匿名函数,进而创建IIFE,这一点就跟本文主要内容联系起来了; 还有一个区别是有条件的创建函数,当函数声明出现在非功能模块（比如 if）中时,虽然官方是禁止这样做的,但是实际上浏览器都支持这种做法,但是各个浏览器的处理方式有不同,这一点兼容性问题实在很头疼,所以我们不应该在生成环境代码中使用这种方式，应该使用函数表达式来代替。 2. 报错原因function (){console.log(1)}()报错出现在第一个括号，因为声明一个函数需要名字，这里声明没有给出名字，所以直接报错，走不到第二个括号，但是function foo(){console.log(1)}()报错出现在第二括号，因为这里声明函数是正确的，当处理到第二个括号时，发现第二个括号内没有任何东西，这是不允许的,所以报错,理由参见文章中注释处 3. 关于闭包在ES6之前只存在两种作用域,一是全局作用域,此作用域当浏览器打开一个页面时就会被创建,你可以通过window对象来访问这个全局作用域中的成员,另外一个就是函数作用域,当js引擎执行一个函数时就会为这个函数创建一个属于该函数的作用域,(在ES6中引入了新的作用域:块级作用域,使用let标识符来生成一个只在块级范围内可访问的变量,关于let的特性你可以参见这里ECMAScript 6 入门).12345678910function foo() &#123; let i = 1; return function log() &#123; console.log(++i) &#125;&#125;let logger = foo();logger(); // 2logger(); // 3 理解闭包必须先理解js的函数作用域,之前说过了每次执行一个函数时就会为这个函数创建一个属于它自己的函数作用域,一旦这个函数运行完毕,那么它的作用域就会被销毁,其中的保存的信息一般也会被销毁,但是,这是一般的情况,那么什么是不一般的情况呢? 这时我们就要利用浏览器销毁变量及作用域的特性来搞事了,浏览器的垃圾回收机制(有两种垃圾回收机制,这里以最常用的标记清除法为例)会定时的检查变量是否被引用,也就是是否有指针指向该数据的存储区域,如果有,那么说明有人可能要使用该数据,则不能销毁该区域,如果没有,说明没人再能够访问这个数据了,那么就可以放心的去销毁该区域来回收内存. 而闭包正好利用了这个特性,例如上面的例子中,函数foo每次执行时会返回一个新函数叫做log,log函数内部需要访问它外面的变量i才能正常工作,返回的新函数被赋给了变量logger,那么这里的指向关系是logger -&gt; log -&gt; i,那么在之后的js执行过程中,由于外部的变量logger通过一系列的指向,最终时能够访问的最开始的那个变量i的,那么按照垃圾回收机制,函数foo的作用域将一直不能够被销毁,因为它内部的变量i还有人用着呢!并且我们发现类似i这样的变量能够保存很重要的一些信息,比如函数被调用的次数等等,我们就可以用来计数或者其它你能发挥创造力的用途. 关于缺点的话也是很明显的,因为闭包内的变量一直将被保留着,如果我们创建大量这样的变量或者大量的闭包,那么浏览器可用内存就会越来越小造成卡顿,应该考虑情况适当使用."},{"title":"ssh-git","permalink":"https://kricsleo.github.io/2018/08/30/ssh-git/","text":"github的https和ssh连接方式探究在本机连接github仓库提交代码时有两种可选方法，一种是使用github账号的用户名和密码的认证方式通过https连接，另一种是使用ssh-key的认证方式通过ssh连接，本文主要研究这两种方式的工作过程以及可能会扩展探究一些相关的知识。 两种方式 首先在本机下载安装Git，一路点next默认安装即可; clone一个github上的项目到本地 选择使用https以我的博客所使用hexo的materialFlow主题项目为例(这个项目我没有管理权限)，一行命令git clone https://github.com/stkevintan/hexo-theme-material-flow.git即可clone到本地 选择使用ssh此时你就无法直接使用git clone git@github.com:stkevintan/hexo-theme-material-flow.git命令来clone上面那个项目到本地，会产生如下错误提示： fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists. 因为ssh的方式是需要进行认证的，你必须是这个项目的所有者或者管理者，才能有权限去使用ssh方式clone该项目，而上面的https方式则允许任何一个人在不需要验证的情况下去clone项目. 那么接下来看一下对于一个我们有管理权限的仓库应该如何使用ssh方式去clone到本地 ssh方式是基于不对称性加密来通信的，你需要使用不对称性算法来生成一对密钥，然后将私钥放置在你本机上，将公钥放置在github服务器上，之后在进行ssh通信时将会使用这对秘钥来完成认证登陆及加密和解密信息，在window上和mac上我们都可以使用ssh-keygen这个命令行工具来生成我们需要的密钥，这是我们想要使用ssh通信的第一步 生成一对密钥打开你的命令行（window下使用cmd.exe，mac下使用terminal.app），然后按照\b如下命令来生成密钥123456ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"# 参数说明： # ssh-keygen: 表示将要使用ssh-keygen这个工具来生成密钥# -t: 指定要生成的密钥类型，有rsa1(SSH1),dsa(SSH2),ecdsa(SSH2),rsa(SSH2)等类型，较为常用的是rsa类型，此处指定为rsa类型# -b: 指定要生成的密钥长度 (单位:bit)，对于RSA类型的密钥，最小长度768bits,默认长度为2048bits。DSA密钥必须是1024bits，此处指定为4096bits# -C: 制定要生成的密钥的注释，这个可以自己随意填写，就相当于给这个密钥留个名，好分辨，比如此处可以用注册github的邮箱号 之后会出现如下提示内容： Generating public/private rsa key pair.Enter file in which to save the key (C:/Users/xxxxx/.ssh/id_rsa): 意思是让你输入这个密钥文件的文件名，一般情况保存默认就可以，直接回车确认。（如果你有多个git的账号需要配置，比如你自己在github上有账号需要提交代码，同时自己在公司也有git的账号，有时候需要提交代码到公司的仓库里，那么这时候你就需要额外的配置来保证提交的时候不会冲突，详见下面）然后会出现下一个提示内容： Enter passphrase (empty for no passphrase): 意思是要不要对私钥设置口令（passphrase），如果担心私钥的安全，你可以设置一个，这里一般不设置，直接回车确认即可，最后会出现类似如下的提示内容： +—[RSA 4096]—-+| o+o .. .o || oo… o … = ||+ +.+ o.o.o.+ o ||oB =.o..E.o* o ||o = o.o Soo+= || . o .+++ . || o.o || .. || .. |+—-[SHA256]—–+ 那\b么恭喜你，你已经生成了一对密钥文件，\b他们存储在C:/Users/xxxxx/.ssh/（windows）或者~/.ssh（mac）目录下，默认的文件是id_rsa（私钥文件名）和id_rsa.pub（公钥文件名），你可以去打开查看一下里面的内容。 部署密钥之前说过了你需要将私钥保存在本机，公钥放置在服务器上，这样之后才能用这对密钥建立ssh通信，那么在github上我们按照如下做法来部署密钥 用文本编辑器打开刚才生成的公钥文件id_rsa.pub，拷贝里面的全部内容； 打开浏览器登陆你的github账户，依次打开你头像上的Settings &gt; SSH and GPG keys &gt; New SSH key; 填写相关信息，title可以类似之前生成密钥时填写的注释信息那样填写你的邮箱名，然后key里面填上刚才拷贝的公钥内容，点击Add SSH key之后输入一次你的github账户密码进行确认，然后你的公钥就被保存部署到github服务器上了； 测试连接，使用如下命令来测试是否能够通过ssh连接到github1234ssh git@github.com# 参数说明：# ssh: 使用ssh进行连接# git@github.com: ssh连接时需要指定登陆用户名和远程主机名，这里的git就是github的远程服务器的用户名，github.com就是远程服务器的主机名，用'@'符号连接起来 当你是第一次连接的时候会提示你如下信息： The authenticity of host ‘github.com (52.74.223.119)’ can’t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 这是因为你是第一次连接该主机，该主机不在你本机的known hosts（已知主机）名单里面，所以询问你是否要继续连接这个陌生的主机，输入yes然后回车确认即可，之后再次连接的时候就不会有这个提示信息了。如果你配置步骤没问题的话应该可以看到下面的连接上之后的欢迎信息(xxxxx代表你的github的账户名)： Warning: Permanently added ‘github.com,52.74.223.119’ (RSA) to the list of known hosts.PTY allocation request failed on channel 0Hi xxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 使用ssh方式clone项目之前说过了ssh方式只能操作我们有管理权限的项目，所以这里我拿自己做的一个微信小程序的虚拟车牌键盘的项目为例1git clone git@github.com:kricsleo/vehicleKeyboard.git 这个时候我们就能顺利clone该项目到本机了，因为在我们上面这条命令请求数据的过程中，我们本机和github的服务器会使用我们之前生成的那对密钥来进行相互认证，从而使我们不需要手动输入github的账户名和密码信息来完成认证登陆，同时我们以后修改了项目代码在进行提交的时候也可直接进行提交等相关操作，无需再考虑登陆及连接的问题，git的使用可以参考我之前的一篇小总结 配置个人信息使用git提交更改的时候会为本次提交附上提交人的\b一些信息，比如提交人的用户名及邮箱信息，我们可以使用git提供的配置功能来提前配置好这些信息，使用如下：123456789101112git config --global user.name \"John Doe\"git config --global user.email \"johndoe@example.com\"# 参数说明：# git config: 表示使用git的配置工具# --global: 表示配置全局的信息，你也可以在某个项目下面单独配置这个信息，只需要去掉'--global'即可，# &lt;- 这样不同的项目就会有不同提交人信息# user.name / user.email: 后面跟上你自己的用户名和邮箱信息即可# 之后我们可以使用如下命令来查看我们配置的信息#git config user.name#git config user.email 多git账户配置如果你需要生成多对密钥，比如你需要和两个不一样的服务器A和B进行ssh通信，那么这个时候你就可以生成两对密钥，一对用来和A通信，另一对用来和B通信，最常见的情况就是我们自己在github上面会有自己的github账户，自己平时会开发一些自己的项目，然后提交到github上面，在公司里面公司一般会有自己的gitlab服务器，然后给员工开通一个gitlab的账号，有关公司内部的项目就会让员工用gitlab的账户进行开发，然后提交代码到公司的gitlab上面，那么这时候我们可以按照如下的方法来配置一下，保证自己随时提交代码的时候都是能够提交到正确的地方，而不会混乱。 再生成一对密钥在上面的操作中你已经生成了一对密钥，名字叫做id_rsa和id_rsa.pub（如果你没有改名的话），这个密钥我们已经拿来和github进行通信了，此时我们要想和公司的gitlab通信就需要再生成一对密钥，为了避免这次生成的密钥覆盖我们之前的那对密钥，可以执行如下命令：12345ssh-keygen -t rsa -b 4096 -C \"youremail@yourcompany.com” -f ~/.ssh/id_rsa_xx# 参数说明# 这次我们生成密钥的命令只比之前多了一个参数： -f# -f: 表示将这次什么的密钥文件保存为id_rsa_xx，同样放在了之前的那个文件夹，这个文件名你可以自己随意指定，不过最好容易区分一些 后面你的操作就和之前生成密钥一样了，生成好密钥之后再看下一步 部署新生成的密钥和之前部署github密钥的步骤类似，你登录你公司的gitlab，找到添加ssh-key的地方，然后拷贝新生成的公钥id_rsa_xx.pub文件内容到gitlab里面去并且保存，这样你公司的gitlab服务器上的公钥信息就配置好了 新建配置文件因为现在我们本机上有了两对密钥，提交代码到github时需要使用之前生成的那一对，提交代码到公司的gitlab上需要我们现在刚刚生成的这一对，那么我们就要写一个简单的配置文件来告诉git该如何再提交代码时选择正确的密钥，实际上就是编写SSH的用户配置文件config。在目录~/.ssh(mac环境)或者C:/Users/xxxxx/.ssh/下新建文件config，注意没有后缀名的，然后在里面填写上如下内容： 12345678910111213141516171819#githubHost github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa#yourcompanyHost git.XXXXX.com HostName git.XXXXX.com User git IdentityFile ~/.ssh/id_rsa_XX# 参数说明，此段内容不用拷贝，是为了加以说明# Host: 别名，为了方便记忆和区分，可以任意填写# HostName： 主机名 服务器的主机名，也可以是服务器的ip地址，需要准确填写# User： 用户名，ssh登录服务器时的用户名，一般是git# IdentityFile： 密钥文件的路径，填写上你要用来和这个服务器通信使用的密钥文件的路径# PreferredAuthentications： 强制使用Public Key验证，我这里没有要求这个，你也可以加上 测试连接使用如下命令来分别测试能否连接到对应的服务器 12345# 测试连接公司ssh git@git.XXXXX.com# 测试连接githubssh git@github.com 如果能分别看到对应的欢迎信息，那么恭喜你配置正确了。 配置个人信息这次我们因为有不同的项目，提交时需要附加上的个人信息也不一样，你提交github时会用你自己的github账户名和邮箱信息，但是提交公司的gitlab时会使用公司给你的账户名和公司个人邮箱，那么我们就需要到具体的项目下面执行如下的命令：12345git config user.name \"yourname\"git config user.email \"youremail@XXXXX.com\"# 参数说明# 与之前我们执行的那条配置个人信息命令相比，只是少了个'--global'参数，因为我们现在不是在全局配置，而是在个别项目中单独配置 到这里为止，你的多git账户依旧配置完毕了，后面就可以和平常一样使用git来提交代码了，ssh会为你选择正确的密钥来和服务器认证和通信。 备注这篇文章里面给我自己埋了些坑要填 完全使用https协议该如何用git来开发项目 另外关于ssh其实自己看了挺多，但是这篇文章里面基本没怎么写，之后可能填上这个坑 是否可以github和gitlab使用同一对密钥，那样是不是会方便些，另外需要考虑安全问题 如果文章内容出现错误或者有更多想要了解的可以在下方留言，我会改进的 (end)"},{"title":"markdown","permalink":"https://kricsleo.github.io/2018/08/23/markdown/","text":"markdown语法整理经常使用markdown来做笔记，这里把现在常用的语法先记录一下，万一老年人了记忆不好，也可以查一查 标题123456# h1......###### h6分隔符最少三个---或*** 目录12(部分markdown软件不支持)[TOC] 引用123456789&gt; quote(\b每行最后添加两个空格即表示换行) quote &gt; quote(或者采取每行前面都添加引用标志)&gt; quote&gt; quote(多行嵌套引用)&gt;&gt; quote2&gt;&gt;&gt; quote3 代码123行内代码`code`行内代码多行代码，[支持\b高亮语言](https://blog.csdn.net/qq_32126633/article/details/78838494#language_key) 链接1234[个人博客](https://kricsleo.github.io/ 'krics的个人博客')或者[blog]: https://kricsleo.github.io/ 'krics的个人博客'[个人博客][blog] 图片123456![个人头像](https://kricsleo.github.io/images/avatar.jpg 'krics的个人头像')或者[avatar]: https://kricsleo.github.io/images/avatar.jpg 'krics的个人头像'![个人头像][avatar]图片带链接[![个人头像](https://kricsleo.github.io/images/avatar.jpg 'krics的个人头像')](https://kricsleo.github.io/images/avatar.jpg) 序表123456789有序节点1. 节点1 1. 节点1.12. 节点2无序节点- 节点$ - 节点$.^- 节点# - 节点#.&amp; 任务12- [ ] 未完成- [x] 已完成 表格1234# 附上[在线生成表格工具](http://www.tablesgenerator.com/markdown_tables)| a | b | c ||:-------:|:------------- | ----------:|| 居中 | 左对齐 | 右对齐 | 语义性1234567*斜体* or &lt;i&gt;斜体&lt;/i&gt;**加粗** or &lt;b&gt;加粗&lt;/b&gt;***斜体加粗*** or &lt;em&gt;强调&lt;/em&gt;~~删除线~~上标&lt;sup&gt;u&lt;/sup&gt;下标&lt;sub&gt;d&lt;/sub&gt;键盘按键&lt;kbd&gt;Ctrl&lt;/kbd&gt; 格式化显示123&lt;pre&gt; ...&lt;pre&gt; 公式 目前还不常用，之后补齐 脚注123Markdown[^1]在页面底端注解[^1]: Markdown是一种纯文本标记语言 定义型列表12Markdown: Markdown是一种纯文本标记语言 (冒号后跟一个'Tab'或者四个空格) 邮箱1&lt;xxx@163.com&gt; 流程图markdown的代码绘制流程图个人感觉比较复杂，个人使用的在线绘制工具ProcessOn"},{"title":"git-workflow","permalink":"https://kricsleo.github.io/2018/08/22/git-workflow/","text":"git的日常使用流程记录内容参考于阮一峰老师的Git使用规范流程，记录一下git的日常使用流程。 1. 新建分支开发新功能时都应该新建一个分支，在分支上开发，当功能开发完成时再合并到主分支，并销毁新建的分支。1234567# git checkout——检出，是我们的常用命令。最为常用的两种情形是创建分支和切换分支# 先切换到主分支，获取最新代码git checkout mastergit pull# 然后新建分支，在这个分支上进行新功能开发git checkout -b myfeature 2. 提交分支新功能开发完成以后提交代码12345678# 默认保存所有改动 --allgit add# 查看发生改动的地方git status# 提交改动，也可以跟上 --verbose，然后就可以列出diff比较的结果，并且附上本次提交信息git commit 3. 同步代码开发过程中可以经常同步主分支的最新代码，保证一直在最新的基础上进行开发1234567# git fetch 表示取回最新代码git fetch origin# 将有更新的代码与当前分支合并# 所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如origin主机的master，就要用origin/master读取。# 或者使用： git merge origin/mastergit rebase origin/master 4. 合并多个commit新功能开发过程中一般会多次commit，但是在功能开发完成以后需要合并到主干时，一般把之前的commit合并成一个或几个关键的commit12# git rebase命令的i参数表示互动（interactive），具体如何合并请参见原文git rebase -i origin/master 5. 推送到远程仓库多个commit经过合理的处理以后就可以把当前分支推送到远程仓库了12# git push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送git push --force master myfeature 6. 发出Pull Request提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。 (end)"}]}